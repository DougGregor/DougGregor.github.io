<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-literals"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-literals"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-literals"/><title>Swift for C++ Practitioners, Part 9: Extensible Literals | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 9: Extensible Literals | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 9: Extensible Literals | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 9: Extensible Literals"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 9: Extensible Literals"/><meta property="og:description" content="Swift for C++ Practitioners, Part 9: Extensible Literals"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-06-25 06:58:00 +0000</p><p>Last updated on 2024-07-01 03:52:10 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 9: Extensible Literals</h1><p>One of the things that I <em>really</em> liked about C++ was the ability to create great libraries: the combination of classes, templates, and operator overloading made it possible to create abstractions that nicely describe a subject domain (whether graphs, matrices, parsers, whatever) within a library.</p><p>Swift provides similar affordances to create the right abstractions to model a subject domain. I've already talked about <a href="../swift-for-cxx-practitioners-value-types">value types</a> and <a href="swift-for-cxx-practitioners-generics.md">generics</a> at length, so we won't go into those again. However, Swift also has additional features that let you customize the language to your needs, including the ability to interact with literals (like <code>0</code> or <code>"https://douggregor.net"</code>), overload operators to your heart's content, provide specific access behavior for properties, or define your own declarative sub-language (DSL) embedded in Swift. These features, used well, can enable beautiful library designs that get at the heart of describing a domain.</p><p>I'm going to tackle language extensibility in several different posts, because there's a lot to explore, including a few side quests into other parts of the language. For this post, we're going to dive ito something that you use everyday but probably don't think about much in C++: literals.</p><p>Literals are constant values written in the source code. In Swift, there are quite a few different kinds of literals:</p><ul><li><em>Integer literals</em>: numbers like <code>42</code> and <code>-10</code>.</li><li><em>Floating-point literals</em>: numbers like <code>3.14159</code></li><li><em>Boolean literals</em>: <code>true</code> and <code>false</code></li><li><em>String literals</em>: strings like <code>"Hello, world!"</code></li><li><em>Interpolated string literals</em>: strings with interpolations in them, such as <code>"Hello, \(name)!"</code></li><li><em>Nil literal</em>: <code>nil</code></li><li><em>Array literal</em>: an array of things, such as <code>[a, b, c]</code></li><li><em>Dictionary literal</em>: a list of key-value pairs, such as <code>[a: x, b: y, c: z]</code></li></ul><p>In most programming languages, literals have a specific type. <code>0</code> in C++ is an <code>int</code>, <code>3.14159</code> is a <code>double</code>. C++ also has suffixes that are part of the literal to let you change the literal type: <code>0u</code> is an <code>unsigned int</code>, <code>3.14159f</code> is a <code>float</code>, and so on. C++ also allows many kinds of implicit conversion, which lets us be somewhat cavalier with the exact type of literals: you can write <code>int8_t x = 64;</code> and the literal <code>int</code> will be implicitly converted to <code>int8_t</code>. One hopes to get a compiler warning if the literal doesn't fit into the type of <code>x</code>.</p><p>In Swift, literals pick up the type of their enclosing context. So, we can write the equivalent to the above <code>x</code> as:</p><pre><code><span class="keyword">let</span> x: <span class="type">UInt8</span> = <span class="number">64</span>
</code></pre><p>and the literal <code>64</code> will pick up the type <code>UInt8</code> from its context. You can also be explicit about what type you want your literal to have by using the <code>as</code> operator: <code>64 as UInt8</code> will ensure that the integer literal <code>64</code> is treated as a <code>UInt8</code>. You can use the <code>as</code> operator to perform an implicit conversion explicitly in Swift: <code>x as Any</code> will put the value of <code>x</code> into a value types as <code>Any</code>.</p><p>With the so-called "collection" literals (for arrays and dictionaries), the contextual type can affect both the collection type and its element type. For example, if I were to write:</p><pre><code><span class="keyword">let</span> numbers: <span class="type">Set</span>&lt;<span class="type">UInt8</span>&gt; = [ <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span> ]
</code></pre><p>Then the array literal has type <code>Set&lt;UInt8&gt;</code>, meaning that each of the elements in the array literal will have type <code>UInt8</code>. This inference can go both ways: consider something like this:</p><pre><code><span class="keyword">let</span> someNumbers: <span class="type">Set</span>&lt;<span class="keyword">_</span>&gt; = [ <span class="number">1</span> <span class="keyword">as</span> <span class="type">UInt8</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">16</span>, <span class="number">32</span>, <span class="number">64</span> ]
</code></pre><p>The <code>_</code> is a placeholder for "I don't want to write the type, figure it out for me". I've specified that I want a <code>Set</code>, so the array literal will be of a <code>Set</code> type, but the element type will be dictated by the array literal elements themselves: here the only one given a specific type is given <code>UInt8</code>, so the type of <code>someNumbers</code> will be <code>Set&lt;UInt8&gt;</code>.</p><p>If there is no contextual type for a literal, it will default to an appropriate type: <code>Bool</code> for Boolean literals, <code>Int</code> for integer literals, <code>Double</code> for floating-point literals, <code>String</code> for string literals, <code>Array</code> for array literals, and <code>Dictionary</code> for dictionary literals. This is what enables type inference for something like</p><pre><code><span class="keyword">let</span> favoriteConstants = [ <span class="string">"Ï€"</span> : <span class="number">3.14159</span>, <span class="string">"e"</span>: <span class="number">2.71828</span> ]
</code></pre><p>to determine that <code>favoriteConstants</code> has the type <code>[String: Double]</code> aka <code>Dictionary&lt;String, Double&gt;</code>.</p><p>Type inference is nice and all, but I promised <em>extensibility</em>. Let's get to that.</p><h2>The <code>ExpressibleBy*Literal</code> protocols</h2><p>The types I listed above that work as literal types aren't magical. They are defined in the standard library, and declare conformances to protocols in the "expressible by" family. Each kind of literal has one or more protocols associated with it: a type that conforms to one of these protocols can be constructed from the corresponding literal type. Here's the mapping from literal kinds to protocols:</p><ul><li><em>Integer literals</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebyintegerliteral"><code>ExpressibleByIntegerLiteral</code></a></li><li><em>Floating-point literals</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebyfloatliteral"><code>ExpressibleByFloatLiteral</code></a></li><li><em>Boolean literals</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebybooleanliteral"><code>ExpressibleByBooleanLiteral</code></a></li><li><em>String literals</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebystringliteral"><code>ExpressibleByStringLiteral</code></a> (and friends; we'll get there')</li><li><em>Interpolated string literals</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebystringinterpolation"><code>ExpressibleByStringInterpolation</code></a></li><li><em>Nil literal</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebynilliteral"><code>ExpressibleByNilLiteral</code></a></li><li><em>Array literal</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebyarrayliteral"><code>ExpressibleByArrayLiteral</code></a></li><li><em>Dictionary literal</em>: <a href="https://developer.apple.com/documentation/swift/expressiblebydictionaryliteral"><code>ExpressibleByDictionaryLiteral</code></a></li></ul><p>If you had some kind of collection type that you wanted to work be constructible from an array literal, you would make it conform to <code>ExpressibleByArrayLiteral</code>. For our example, let's create a single type that conforms to <em>lots</em> of these protocols: a representation of a JSON value. We can describe any JSON value as an enum, like this:</p><pre><code><span class="keyword">enum</span> JSONValue {
    <span class="keyword">case</span> null
    <span class="keyword">case</span> object(<span class="type">String</span>)
    <span class="keyword">case</span> number(<span class="type">Double</span>)
    <span class="keyword">case</span> array([<span class="type">JSONValue</span>])
    <span class="keyword">case</span> dictionary([<span class="type">String</span>: <span class="type">JSONValue</span>])
}
</code></pre><p>We can represent the JSON <code>null</code> value with a <code>nil</code> literal by introducing a conformance to <code>ExpressibleByNilLiteral</code>, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByNilLiteral</span> {
    <span class="keyword">init</span>(nilLiteral: ()) {
        <span class="keyword">self</span> = .<span class="dotAccess">null</span>
    }
}
</code></pre><p>There's one oddity here to point out: the parameter <code>nilLiteral</code> has the type <code>()</code>, which is an empty tuple. Here, it's used so that we can provide a special name for this initializer (<code>init(nilLiteral:)</code>) even though there's no need for a specific value with a <code>nil</code> literal. Fun fact: the Swift standard library has a type <code>Void</code> that's defined like this:</p><pre><code><span class="keyword">typealias</span> Void = ()
</code></pre><p>Functions that have no specified return type in Swift are said to return <code>Void</code>, somewhat like in C++. But the analogy to C++ <code>void</code> stops there. Empty tuple types are normal types in Swift: you can have variables and properties of empty tuple type, and they have a size of zero (<em>gasp</em>). One can create a value of empty tuple type with the expression <code>()</code>. Some languages refer to these types as "unit" types.</p><p>For the next two cases of <code>JSONValue</code>, we can provide string, integer, and floating-point literal conformances:</p><pre><code><span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByStringLiteral</span> {
    <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) {
        <span class="keyword">self</span> = .<span class="call">object</span>(value)
    }
}

<span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByIntegerLiteral</span> {
    <span class="keyword">init</span>(integerLiteral value: <span class="type">Int</span>) {
        <span class="keyword">self</span> = .<span class="call">number</span>(<span class="type">Double</span>(value))
    }
}

<span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByFloatLiteral</span> {
    <span class="keyword">init</span>(floatLiteral value: <span class="type">Double</span>) {
        <span class="keyword">self</span> = .<span class="call">number</span>(value)
    }
}
</code></pre><p>We can now create a <code>JSONValue</code> instance from a nil literal (<code>nil</code>), string literal (<code>"Hello"</code>), integer literal ('42'), or floating-point literal ('3.14159').</p><p>Let's do some collections to finish it off:</p><pre><code><span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByArrayLiteral</span> {
    <span class="keyword">init</span>(arrayLiteral elements: <span class="type">JSONValue</span>...) {
        <span class="keyword">self</span> = .<span class="call">array</span>(elements)
    }
}

<span class="keyword">extension</span> <span class="type">JSONValue</span>: <span class="type">ExpressibleByDictionaryLiteral</span> {
    <span class="keyword">init</span>(dictionaryLiteral elements: (<span class="type">String</span>, <span class="type">JSONValue</span>)...) {
        <span class="keyword">self</span> = .<span class="call">dictionary</span>(.<span class="keyword">init</span>(uniqueKeysWithValues: elements))
    }
}
</code></pre><p>The only new bit of syntax is the <code>...</code>. These are variadic parameters (not variadic <em>generics</em>), which accept any number of arguments, all of the same type. Within the body of the function/initializer, variadic parameters are accessed as arrays. So, the <code>init(arrayLiteral:)</code> initializer can directly put the <code>elements</code> array into its <code>array</code> case, because it already contains JSON values. The <code>init(dictionaryLiteral:)</code> initializer accepts an array of <code>(String, JSONValue)</code> pairs, which it uniques based on key to place in the dictionary.</p><p>Now, we can go ahead and write out JSON literals in Swift:</p><pre><code><span class="keyword">let</span> math: <span class="type">JSONValue</span> = [ 
    <span class="string">"Ï€"</span> : <span class="number">3.14159</span>,
    <span class="string">"e"</span>: <span class="number">2.71828</span>,
    <span class="string">"i"</span>: <span class="string">"sqrt(i)"</span>,
    <span class="string">"zero"</span>: <span class="number">0</span>,
    <span class="string">"undefined"</span>: <span class="keyword">nil</span>
]
</code></pre><p>If we were to print the above variable without any additional customization, we'd get something like this (formatting is mine):</p><pre><code><span class="call">dictionary</span>(
    [
         <span class="string">"zero"</span>: <span class="type">Extensibility</span>.<span class="type">JSONValue</span>.<span class="call">number</span>(<span class="number">0.0</span>),
          <span class="string">"Ï€"</span>: <span class="type">Extensibility</span>.<span class="type">JSONValue</span>.<span class="call">number</span>(<span class="number">3.14159</span>),
          <span class="string">"i"</span>: <span class="type">Extensibility</span>.<span class="type">JSONValue</span>.<span class="call">object</span>(<span class="string">"sqrt(i)"</span>),
          <span class="string">"e"</span>: <span class="type">Extensibility</span>.<span class="type">JSONValue</span>.<span class="call">number</span>(<span class="number">2.71828</span>),
          <span class="string">"undefined"</span>: <span class="type">Extensibility</span>.<span class="type">JSONValue</span>.<span class="property">null</span>
    ]
)
</code></pre><h3>Aside: Hashing in Swift</h3><p>If you try the above example yourself, you might notice an interesting difference in the output: the dictionary key/value pairs could get printed in a different order from what I have above. Run the program again---you'll likely get a different order! Swift's hashed collections (<code>Dictionary</code> and <code>Set</code>) choose a random seed at program start to mix into hash elements, so you'll get different hash values for the same values from one run to the next. This was motivated partially by security and partially to promote correctness.</p><p>The security angle is that knowing how a hash table performs hashes allows you to craft a set of inputs that all hash to the same value, making operations on the hash table linear when they shouldn't be, leading to a potential denial-of-service attack. By changing the random seed on each execution, it makes it harder to provide a set of inputs like this.</p><p>The correctness angle is, essentially, that it's often too easy to mistakenly depend on the iteration order of a hashed data structure or the specific hash value of a type. One approach I've seen proposed for C++ is to prohibit iteration on hashed data structures entirely (e.g., by not providing <code>begin</code>/<code>end</code> on a custom version of <code>unordered_map</code> or <code>unordered_set</code>). Swift's approach to allow the iteration, but have the ordering changing from one program run to the next. That way, you can iterate to make use of collection algorithms, but if it affects your output (e.g., because you forgot to sort at the end), you're very likely to notice because your unit tests will break.</p><h2>Strings and characters</h2><p>String literals have their own hierarchy of protocols. <code>ExpressibleByStringLiteral</code> is the most capable, allowing an arbitrary, well-formed UTF-8 string literal. A string literal like <code>"Hello"</code> will go through this protocol.</p><p><code>ExpressibleByStringLiteral</code> inherits from the <code>ExpressibleByExtendedGraphemeClusterLiteral</code> protocol. The name is a mouthful, but this protocol is used for string literals that consist of a single extended grapheme cluster---the closest thing what a human would think of as a "character". The string literal "ðŸ‡ºðŸ‡¦" is a single extended grapheme cluster (although it has several Unicode scalars in it). Any type that conforms to <code>ExpressibleByStringLiteral</code> can handle such a string literal, but the converse is not true: some types might only be able to represent a single character, not an entire string. The standard library's <code>Character</code> type, for example, conforms to only <code>ExpressibleByExtendedGraphemeClusterLiteral</code>:</p><pre><code><span class="keyword">let</span> c1: <span class="type">Character</span> = <span class="string">"ðŸ‡ºðŸ‡¦"</span>      <span class="comment">// okay</span>
<span class="keyword">let</span> c2: <span class="type">Character</span> = <span class="string">"Hello"</span>   <span class="comment">// error: Character does not conform to ExpressibleByStringLiteral</span>
</code></pre><p>There is one more protocol in the string literal family: <code>ExpressibleByUnicodeScalarLiteral</code>, from which <code>ExpressibleByExtendedGraphemeClusterLiteral</code> inherits, handles string literals that can be represented by a single Unicode scalar such as <code>"!"</code> or <code>"ê¹€"</code>. The <code>Unicode.Scalar</code> type in the Swift standard library conforms to this protocol. One benefit to <code>ExpressibleByUnicodeScalarLiteral</code> is that all Unicode scalars can fit into a single 32-bit word, whereas extended grapheme clusters can require several scalars.</p><h2>String interpolation</h2><p>The final "expressible by" protocol we'll explore is <code>ExpressibleByStringInterpolation</code>. This is the protocol a type can conform to for string literals that include interpolations, i.e., something like this:</p><pre><code><span class="keyword">let</span> s = <span class="string">"Ï€=</span>\(<span class="number">3.14159</span>)<span class="string">, but the answer is</span> \(<span class="number">42</span>)<span class="string">"</span>
</code></pre><p>The closest analogy in C++ is probably output streaming (with <code>&gt;&gt;</code>) to a <a href="https://cplusplus.com/reference/sstream/ostringstream/"><code>std::ostringstream</code></a>, which lets you mix string literals and values to be formatted. That's a pure library solution; in Swift, we have string interpolation syntax in the language, and libraries can opt in to supporting string interpolation by conforming to <code>ExpressibleByStringInterpolation</code>. Why might a library want to do that? Well, you can think of string interpolation as a general templating engine built that lets you layer on type safety in an appropriate manner.</p><p>Say you want to create a SQL query that's customized by some user-supplied values. You could absolutely do this with normal strings and interpolation:</p><pre><code><span class="keyword">let</span> query: <span class="type">String</span> = <span class="string">"""
SELECT * FROM</span> \(tableName)
<span class="string">ORDER BY</span> \(fieldName)<span class="string">;
"""</span>
</code></pre><p>That code just <em>screams</em> "SQL injection attack", so we need to do better. By creating a SQL query type that supports string interpolation, it can make sure to properly escape any values interpolated into the string, as well as performing any other validation that's needed. The <a href="https://github.com/swiftlang/swift-syntax?tab=readme-ov-file">swift-syntax package</a> for manipulating Swift source code uses this approach to make it easy to create Swift source code from templates, like this:</p><pre><code><span class="keyword">let</span> sourceFile: <span class="type">SourceFileSyntax</span> = <span class="string">"""
    let</span> \(varName)<span class="string">: Int =</span> \(value)
    <span class="string">print(</span>\(varName) <span class="string">+ 42)
    """</span>
</code></pre><h3>The <code>ExpressibleByStringInterpolation</code> protocol</h3><p>To create your own strongly-typed templating solution with string interpolation, you'll need to create a type that conforms to the <code>ExpressibleByStringInterpolation</code> protocol:</p><pre><code><span class="keyword">public protocol</span> ExpressibleByStringInterpolation: <span class="type">ExpressibleByStringLiteral</span> {
    <span class="keyword">associatedtype</span> StringInterpolation: <span class="type">StringInterpolationProtocol</span> <span class="keyword">where</span> <span class="type">StringLiteralType</span> == <span class="type">StringInterpolation</span>.<span class="type">StringLiteralType</span>

    <span class="keyword">init</span>(stringInterpolation: <span class="type">StringInterpolation</span>)
}
</code></pre><p><code>ExpressibleByStringInterpolation</code> inherits from <code>ExpressibleByStringLiteral</code>, because anything that can be created from a string interpolation must also be able to handle the simpler case of a non-interpolated string literal. For a string interpolation with a given contextual type (let's call it <code>MyString</code>), the compiler will create an instance of the type <code>MyString.StringInterpolation</code> to collect the various parts of the string interpolation. That instance will then be passed into <code>init(stringInterpolation:)</code> to create the final string.</p><p>The <code>StringInterpolation</code> type conforms to the <code>StringInterpolationProtocol</code> protocol, which is a little odd because it only lists two requirements... even though the compiler requires that every type conforming to <code>StringInterpolationProtocol</code> support addition operations <em>not</em> described by the requirements. We refer to this as an <em>ad hoc</em> protocol, and it's a pragmatic compromise: we lose some descriptive benefits (you can't just look at the protocol to figure out how to write a fully-conforming type), but we gain a bit of expressive power through the use of overloading. We'll get back to that last part in a bit; for now, here's the protocol as written:</p><pre><code><span class="keyword">public protocol</span> StringInterpolationProtocol {
    <span class="keyword">associatedtype</span> StringLiteralType
    
    <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>)
    
    <span class="keyword">mutating func</span> appendLiteral(<span class="keyword">_</span> literal: <span class="type">StringLiteralType</span>)
}
</code></pre><p>The initializer (<code>init(literalCapacity:interpolationCount:)</code>) is called to initialize an instance of the <code>StringInterpolation</code> type, and is provided with the total number of characters in the string literal parts and the number of "interpolation" segments (for the values that are placed into string). So, if we have a string interpolation like this:</p><pre><code><span class="keyword">let</span> myStr: <span class="type">MyString</span> = <span class="string">"Ï€=</span>\(<span class="number">3.14159</span>)<span class="string">, but the answer is</span> \(<span class="number">42</span>)<span class="string">"</span>
</code></pre><p>The call to create the instance will be <code>MyString.StringInterpolation(literalCapacity: 23, interpolationCount: 2)</code>. Once created, the contents of the interpolation will be passed to the instance with method calls: <code>appendLiteral</code> for each string literal part (e.g., the first call is <code>appendLiteral("Ï€=")</code>) and <code>appendInterpolation</code> for each interpolated value (e.g., the second call is <code>appendInterpolation(3.14159)</code>), alternating. Once all of the pieces of the string interpolation have been sent to the <code>StringInterpolation</code> instance, that value is passed to the initializer of the <code>ExpressibleByStringInterpolation</code>-conforming type, i.e., <code>MyString(stringInterpolation: /*the MyString.StringInterpolation instance*/)</code>.</p><h3>String interpolation in action</h3><p>To see this in action, let's create a string interpolation type that's only for debugging purposes:</p><pre><code><span class="keyword">struct</span> MyString: <span class="type">ExpressibleByStringInterpolation</span> {
    <span class="keyword">typealias</span> StringLiteralType = <span class="type">String</span>
    
    <span class="keyword">init</span>(stringLiteral value: <span class="type">String</span>) {
        <span class="call">print</span>(<span class="string">#"MyString(stringLiteral: "</span>\#(value)<span class="string">")"#)</span>
    }
    
    <span class="keyword">init</span>(stringInterpolation: <span class="type">StringInterpolation</span>) {
        <span class="call">print</span>(<span class="string">"MyString(stringInterpolation:)"</span>)
    }
    
    <span class="keyword">struct</span> StringInterpolation: <span class="type">StringInterpolationProtocol</span> {
        <span class="keyword">init</span>(literalCapacity: <span class="type">Int</span>, interpolationCount: <span class="type">Int</span>) {
            <span class="call">print</span>(<span class="string">"MyString.StringInterpolation(literalCapacity:</span> \(literalCapacity)<span class="string">, interpolationCount:</span> \(interpolationCount)<span class="string">)"</span>)
        }
        
        <span class="keyword">mutating func</span> appendLiteral(<span class="keyword">_</span> string: <span class="type">String</span>) {
            <span class="call">print</span>(<span class="string">#"appendLiteral("</span>\#(string)<span class="string">")"#)</span>
        }
        
        <span class="keyword">mutating func</span> appendInterpolation(<span class="keyword">_</span> value: <span class="type">Int</span>) {
            <span class="call">print</span>(<span class="string">#"appendInterpolation(</span>\#(value)<span class="string">: Int)"#)</span>
        }
        
        <span class="keyword">mutating func</span> appendInterpolation(<span class="keyword">_</span> value: <span class="type">Double</span>) {
            <span class="call">print</span>(<span class="string">#"appendInterpolation(</span>\#(value)<span class="string">: Double)"#)</span>
        }
    }
}
</code></pre><p>When we initialize a value of type <code>MyString</code> from a string interpolation, we'll see the set of calls that will be performed. Here's the output from the string interpolation example we've been using:</p><pre><code><span class="type">MyString</span>.<span class="type">StringInterpolation</span>(literalCapacity: <span class="number">23</span>, interpolationCount: <span class="number">2</span>)
<span class="call">appendLiteral</span>(<span class="string">"Ï€="</span>)
<span class="call">appendInterpolation</span>(<span class="number">3.14159</span>: <span class="type">Double</span>)
<span class="call">appendLiteral</span>(<span class="string">", but the answer is "</span>)
<span class="call">appendInterpolation</span>(<span class="number">42</span>: <span class="type">Int</span>)
<span class="call">appendLiteral</span>(<span class="string">""</span>)
<span class="type">MyString</span>(stringInterpolation:)
</code></pre><p>There are a few things to notice: the <code>appendLiteral</code> calls alternate with <code>appendInterpolation</code> calls, even when the string literal is empty. This means that there are always <code>interpolationCount * 2 + 1</code> calls to <code>appendLiteral</code> along with <code>interpolationCount</code> calls to <code>appendInterpolation</code>.</p><p>Additionally, the two interpolated values have different types (<code>Double</code> and <code>Int</code>, respectively), and end up calling different overloads of <code>appendInterpolation</code>. This is where the <em>ad hoc</em> nature of the <code>StringInterpolationProtocol</code> comes in: you can define different overloads of <code>appendInterpolation</code> for each of the types that your type is intended to support. If you don't want to support a type, don't provide an <code>appendInterpolation</code> overload for it. If you want to support entire classes of types, add a generic <code>appendInterpolation</code> with the appropriate constraints on it. Moreover, you can add additional parameters to <code>appendInterpolation</code> that can be used to customize rendering. For example, we could support an optional "radix" for integer interpolations:</p><pre><code><span class="keyword">mutating func</span> appendInterpolation(<span class="keyword">_</span> value: <span class="type">Int</span>, radix: <span class="type">Int</span>) {
    <span class="call">print</span>(<span class="string">#"appendInterpolation(</span>\#(value)<span class="string">, radix:</span> \#(radix)<span class="string">")#)</span>
}
</code></pre><p>Now, if we have a string interpolation like this:</p><pre><code><span class="string">"The value of</span> \(value) <span class="string">in hexadecimal is</span> \(value, radix: <span class="number">16</span>)<span class="string">"</span> <span class="keyword">as</span> <span class="type">MyString</span>
</code></pre><p>we'll get this series of calls:</p><pre><code><span class="type">MyString</span>.<span class="type">StringInterpolation</span>(literalCapacity: <span class="number">32</span>, interpolationCount: <span class="number">2</span>)
<span class="call">appendLiteral</span>(<span class="string">"The value of "</span>)
<span class="call">appendInterpolation</span>(<span class="number">42</span>: <span class="type">Int</span>)
<span class="call">appendLiteral</span>(<span class="string">" in hexadecimal is "</span>)
<span class="call">appendInterpolation</span>(<span class="number">42</span>, radix: <span class="number">16</span>)
<span class="call">appendLiteral</span>(<span class="string">""</span>)
<span class="type">MyString</span>(stringInterpolation:)
</code></pre><h3>Extending the default string interpolation behavior</h3><p>If all you want is to customize the way your own types get interpolated into strings, you don't need to create a new <code>ExpressibleByStringInterpolation</code> type at all. Instead, you can add on to the default string interpolation behavior by adding your own <code>appendInterpolation</code> operations to the standard library's <a href="https://developer.apple.com/documentation/swift/defaultstringinterpolation"><code>DefaultStringInterpolation</code></a> type. For example, say we want to be able to render a string with inline Markdown format, as described by this enum:</p><pre><code><span class="keyword">enum</span> InlineMarkdownStyle {
  <span class="keyword">case</span> regular
  <span class="keyword">case</span> italicized
  <span class="keyword">case</span> bold
  <span class="keyword">case</span> underlined
  <span class="keyword">case</span> monospaced
}
</code></pre><p>Now, we can add string interpolation support for supplying the inline markdown style to a string literal (but please do so with better escaping than I did):</p><pre><code><span class="keyword">extension</span> <span class="type">DefaultStringInterpolation</span> {
    <span class="keyword">mutating func</span> appendInterpolation(<span class="keyword">_</span> value: <span class="type">String</span>, markdownStyle: <span class="type">InlineMarkdownStyle</span>) {
        <span class="keyword">switch</span> markdownStyle {
        <span class="keyword">case</span> .<span class="dotAccess">regular</span>:    <span class="call">write</span>(value)
        <span class="keyword">case</span> .<span class="dotAccess">italicized</span>: <span class="call">write</span>(<span class="string">"*</span>\(value)<span class="string">*"</span>)
        <span class="keyword">case</span> .<span class="dotAccess">bold</span>:       <span class="call">write</span>(<span class="string">"**</span>\(value)<span class="string">**"</span>)
        <span class="keyword">case</span> .<span class="dotAccess">underlined</span>: <span class="call">write</span>(<span class="string">"_</span>\(value)<span class="string">_"</span>)
        <span class="keyword">case</span> .<span class="dotAccess">monospaced</span>: <span class="call">write</span>(<span class="string">"`</span>\(value)<span class="string">`"</span>)
        }
    }
}
</code></pre><p>Now, we can do this:</p><pre><code><span class="call">print</span>(<span class="string">"String interpolation is</span> \(<span class="string">"so"</span>, markdownStyle: .<span class="dotAccess">italicized"</span>) \(positiveAdjective, markdownStyle: .<span class="dotAccess">bold</span>).<span class="string">")</span>
</code></pre><p>and if <code>positiveAdjective</code> were <code>"cool"</code>, this would print:</p><pre><code><span class="type">String</span> interpolation <span class="keyword">is</span> *so* **cool**.
</code></pre><h2>Wrap-up and what's next?</h2><p>Literals in Swift are a surprisingly deep topic. The surface is very much like other languages, including C++: you have numeric literals, Boolean literals, and string literals, plus some additional support for array and dictionary literals that's straightforward. But Swift literals are affected by their contextual type, and any library can opt to supply its own literal types by conforming to the various `ExpressibleBy<em>Literal</em> protocols, allowing one to express structured data cleanly. String interpolation is also highly extensible, allowing one to create type-safe templating engines that work well with the language syntax.</p><p>Next up, we're going to look at operator overloading, where the story is much the same: on the surface, it's fairly similar to C++ and other languages that have such overloading. But dig a little deeper and there's a world of customization you can do to create elegant domain-specific embedded languages (DSELs).</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>
