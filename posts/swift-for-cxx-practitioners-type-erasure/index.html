<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure"/><title>Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 5: Type erasure & metatypes"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 5: Type erasure & metatypes"/><meta property="og:description" content="Swift for C++ Practitioners, Part 5: Type erasure & metatypes"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-04-11 15:14:00 +0000</p><p>Last updated on 2024-05-20 16:20:30 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes</h1><p>What do you do in C++ when you want to support different types, but don't want to have one template instantiation per type? Yes, you can introduce a class hierarchy with virtual functions, but more often a better answer is to use <em>type erasure</em>. Type erasure is a mechanism for <em>runtime polymorphism</em>, allowing you to provide different types at runtime while using the same code expressed with a single, concrete type. The C++ standard library contains two type-erased utility types: <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a> and <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>. In both cases, you can have a concrete value whose underlying type can change:</p><pre><code>std::any a = <span class="number">17</span>;              <span class="comment">// okay, stores an int</span>
a = std::<span class="call">string</span>(<span class="string">"hello"</span>);     <span class="comment">// now it stores a std::string!</span>

std::function&lt;<span class="call">int</span>(int, int)&gt; op = [](int a, int b) { <span class="keyword">return</span> a + b; }; <span class="comment">// okay, it adds integers</span>
op = [](int a, int b) { <span class="keyword">return</span> a * b; }                               <span class="comment">// now it multiplies them!</span>
</code></pre><p>Type erasure in C++ has been around for a long time, and it's a useful technique. <a href="https://www.boost.org/doc/libs/1_84_0/doc/html/any.html">Boost.Any</a> popularized the idea, and now there are numerous blog posts describing implementation techniques and C++ libraries implementing them.</p><p>In Swift, it's part of the language, and you can type-erase any protocol using the keyword <code>any</code>. In this post, we're going to dive into how Swift handles type erasure, and explore related features like <em>metatypes</em> and <em>opaque types</em>.</p><h2>The basics of type erasure</h2><p>For example, let's bring back that the <code>Quantifiable</code> protocol from the last post. It looked like this:</p><pre><code><span class="keyword">protocol</span> Quantifiable {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span>
}
</code></pre><p>One can conform types to <code>Quantifiable</code> and write generic algorithms using <code>Quantifiable</code> as a constraint. If we want to use runtime polymorphism to store a value of any <code>Quantifiable</code> type, we can do so with <code>any Quantifiable</code> like this:</p><pre><code><span class="keyword">var</span> q: any <span class="type">Quantifiable</span> = <span class="number">1</span>   <span class="comment">// okay, Int conforms to Quantifiable</span>
<span class="call">print</span>(q.<span class="call">cost</span>())               <span class="comment">// can use the members of the Quantifiable protocol</span>

q = <span class="string">"Hello"</span>                   <span class="comment">// okay, String conforms to Quantifiable</span>
</code></pre><p>You can think of the type of <code>q</code> as being "anything that is <code>Quantifiable</code>": the actual type isn't known until runtime, and can change by reassigning the variable to another value with a different type.</p><p>One can compose multiple protocols together using the <code>&amp;</code> sign. For example, a value of type <code>any Quantifiable &amp; Describable</code> can hold a value of any type that conforms to both <code>Quantifiable</code> and <code>Describable</code>, and you can use any operations that are available to a <code>Describable</code> type or <code>Quantifiable</code> type:</p><pre><code><span class="keyword">var</span> dq: any <span class="type">Quantifiable</span> &amp; <span class="type">Describable</span> = <span class="number">1</span>
dq.<span class="call">cost</span>()
dq.<span class="call">describe</span>()
</code></pre><p>The Swift equivalent to <code>std::any</code> is called, simply, <code>Any</code>: it is effectively an <code>any</code> type with no protocols listed, so it can store a value of any type in it. Now, just like with <code>std::any</code>, you can't do much with a value of type <code>Any</code> other than copy it around, because there are aren't many operations that work on all types.</p><h2>Dynamic casting</h2><p>One thing you can do with values of <code>Any</code> type is to perform a runtime check of the actual stored type. This is accomplished with the same <code>as?</code> cast we introduced for downcasting to a subclass. For example, here's a function that checks whether a value of type <code>Any</code> is actually an <code>Int</code>:</p><pre><code><span class="keyword">func</span> maybeIntValue(<span class="keyword">_</span> value: <span class="type">Any</span>) -&gt; <span class="type">Int</span>? {
  <span class="keyword">if let</span> integer = value <span class="keyword">as</span>? <span class="type">Int</span> {
    <span class="keyword">return</span> integer
  }
  
  <span class="keyword">return nil</span>
}
</code></pre><p>The same works for <code>switch</code> statements, where a <code>case</code> can use the <code>as</code> operator to apply only when a dynamic cast to the type succeeds. Here's a <code>switch</code> to identify a number of concrete types:</p><pre><code><span class="keyword">func</span> whatAmI(<span class="keyword">_</span> value: <span class="type">Any</span>) {
  <span class="keyword">switch</span> value {
    <span class="keyword">case let</span> bool <span class="keyword">as</span> <span class="type">Bool</span>: <span class="call">print</span>(<span class="string">"Bool</span> \(bool)<span class="string">"</span>)
    <span class="keyword">case let</span> integer <span class="keyword">as</span> <span class="type">Int</span>: <span class="call">print</span>(<span class="string">"Integer</span> \(integer)<span class="string">"</span>)
    <span class="keyword">case let</span> double <span class="keyword">as</span> <span class="type">Double</span>: <span class="call">print</span>(<span class="string">"Double</span> \(double)<span class="string">"</span>)
    <span class="keyword">case let</span> string <span class="keyword">as</span> <span class="type">String</span>: <span class="call">print</span>(<span class="string">"String</span> \(string)<span class="string">"</span>)
    <span class="keyword">default</span>: <span class="call">print</span>(<span class="string">"I don't know what this is"</span>)
  }
}
</code></pre><p>Such a <code>switch</code> must have a <code>default</code> clause, because there's no way to enumerate every type. The Swift compiler will produce an error <code>switch must be exhaustive</code> if you forget.</p><p>One particularly important aspect of dynamic casting is that you can cast to an <code>any</code> type, which lets you discover the capabilities of a value at runtime. For example, one can cast to <code>any Quantifiable</code> to determine whether a value conforms to <code>Quantifiable</code>.</p><pre><code><span class="keyword">var</span> value: <span class="type">Any</span> = <span class="number">1</span>
<span class="keyword">if let</span> q = value <span class="keyword">as</span>? any <span class="type">Quantifiable</span> {
  <span class="call">print</span>(<span class="string">"Cost is</span> \(q.<span class="call">cost</span>())<span class="string">"</span>)
}
</code></pre><p>Dynamic casting allows one to rediscover type information that has been removed by type erasure. It's common in very dynamic programs where values are dynamically produced in one place, such as via a global registry or deserialization, and consumed elsewhere. To build something like that, which dynamically creates values of potentially unknown type, we need one more Swift feature: metatypes.</p><h2>Metatypes</h2><p>In the prior post on generics, I noted that Swift doesn't have an equivalent to the <code>decltype</code> type in C++. Swift does, however, have a function named <code>type(of:)</code>, which produces the type of its argument. However, it's not producing a type, but a value representing the type, i.e., a <em>metatype</em>.</p><p>Metatypes in Swift are spelled with the <code>.Type</code> suffix, so if we have a type <code>Point</code>:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  
  <span class="keyword">static var</span> origin: <span class="type">Point</span> = <span class="type">Point</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)
}
</code></pre><p>The metatype of <code>Point</code> has the type <code>Point.Type</code>. One can form a value of this type with the expression <code>Point.self</code>.</p><pre><code><span class="keyword">let</span> pointType: <span class="type">Point</span>.<span class="type">Type</span> = <span class="type">Point</span>.<span class="keyword">self</span>
</code></pre><p>What can you do with a metatype? For one thing, you can access static methods and properties, or call an initializer of that type to produce a new value, like this:</p><pre><code><span class="keyword">let</span> point = pointType.<span class="keyword">init</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>)
<span class="keyword">let</span> origin = pointType.<span class="property">origin</span>
</code></pre><p>Technically, when you write <code>Point(x: 0.0, y: 0.0)</code>, you're using syntactic sugar for <code>PointType.self.init(x: 0.0, y: 0.0)</code>.</p><p>The <code>type(of:)</code> operation has this generic signature:</p><pre><code><span class="keyword">func</span> type&lt;T&gt;(of value: <span class="type">T</span>) -&gt; <span class="type">T</span>.<span class="type">Type</span>
</code></pre><p>So if we pass an instance of <code>Point</code> to <code>type(of:)</code>, we get back a <code>Point.Type</code> instance.</p><h3>Class metatypes</h3><p>Metatypes of structs and enums, by themselves, aren't very interesting, because you could generally just refer to the type. With classes, metatypes become a lot more interesting because an instance of class type could actually store one of its subclasses. Let's build a small class hierarchy:</p><pre><code><span class="keyword">class</span> Person {
  <span class="keyword">var</span> name: <span class="type">String</span>
  
  <span class="keyword">required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
  }
  
  <span class="keyword">class var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"PERSON"</span>}
}

<span class="keyword">class</span> Programmer: <span class="type">Person</span> {
  <span class="keyword">var</span> favoriteLanguage: <span class="type">String</span>? = <span class="keyword">nil
  
  required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, favoriteLanguage: <span class="keyword">nil</span>)
  }
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, favoriteLanguage: <span class="type">String</span>?) {
    <span class="keyword">self</span>.<span class="property">favoriteLanguage</span> = favoriteLanguage
    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)
  }
  
  <span class="keyword">override class var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"PROGRAMMER"</span> }
}
</code></pre><p>Please ignore the <code>required</code> and <code>class var</code> for the moment---we'll get there shortly. First, let's imagine that we have a <code>person</code> instance, and we ask for its type via <code>type(of: person)</code>:</p><pre><code><span class="keyword">var</span> person: <span class="type">Person</span> = <span class="comment">/*build some kind of person */</span>
<span class="keyword">var</span> personType: <span class="type">Person</span>.<span class="type">Type</span> = <span class="call">type</span>(of: person)
</code></pre><p>Statically, the type of <code>person</code> can only be expressed as <code>Person.Type</code>. But dynamically, the <code>person</code> instance can store a <code>Person</code> object, or a <code>Programmer</code> object, or any instance of any other subclass of <code>Person</code>. The <code>type(of:)</code> operation produces a value of (static) type <code>Person.Type</code>, which dynamically could be <code>Person.self</code>, <code>Programmer.self</code>, or any other subclass's metatype. It's obvious, and a little mind-bending, but then it's obvious again.</p><p>What can we do with a metatype? For one, we can use <code>class</code> methods and properties, which are the overridable equivalent of <code>static</code> methods and properties. (Within a class, <code>static</code> is a synonym for <code>class final</code>). For example, the following:</p><pre><code><span class="call">print</span>(personType.<span class="property">serializecClassName</span>)
</code></pre><p>If <code>person</code> dynamically stores a <code>Person</code> instance, the metatype in <code>personType</code> will be <code>Person.self</code>, and it'll print <code>PERSON</code>. If <code>person</code> dynamically stores a <code>Programmer</code> instance, the metatype in <code>personType</code> will be <code>Programmer.self</code> and it'll print <code>PROGRAMMER</code>.</p><p>We can also initialize a new object by calling <code>personType.init(name:)</code>:</p><pre><code><span class="keyword">let</span> newPerson = personType.<span class="keyword">init</span>(name: <span class="string">"Doug"</span>)
</code></pre><p>and <code>newPerson</code> will have the same type as <code>person</code>. Note that this needs the initializer to be marked <code>required</code>: a <code>required</code> initializer must be implemented by every subclass. They're also needed to satisfy <code>init</code> requirements of a protocol to which the class conforms. For example:</p><pre><code><span class="keyword">protocol</span> InitByName {
  <span class="keyword">init</span>(name: <span class="type">String</span>)
}

<span class="keyword">extension</span> <span class="type">Person</span>: <span class="type">InitByName</span> { 
  <span class="comment">// okay, because init(name:) is a required initializer</span>
}
</code></pre><p>Why do we need <code>required</code>? Making <code>Person</code> conform to <code>InitByName</code> implies that every subclass of <code>Person</code> also conforms to <code>InitByName</code>, because one should always be able to substitute an instance of a subclass where the superclass was expected (this is the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>). That means you need to be able to create an instance of any subclass by calling <code>init(name:)</code>. Making an initializer <code>required</code> ensures that all subclasses (and subclasses of subclasses, and so on) implement it.</p><p>At this point, we could build a simple registry mapping from the serialized class names to actual <code>Person</code> types:</p><pre><code><span class="keyword">var</span> knownPersonTypes: [<span class="type">String</span>: <span class="type">Person</span>.<span class="property">type</span>] = [:]

<span class="keyword">func</span> addPersonType(<span class="keyword">_</span> personType: <span class="type">Person</span>.<span class="type">Type</span>) {
  knownPersonTypes[personType.<span class="property">serializedTypeName</span>] = personType
}

<span class="call">addPersonType</span>(<span class="type">Person</span>.<span class="keyword">self</span>)
<span class="call">addPersonType</span>(<span class="type">Programmer</span>.<span class="keyword">self</span>)
</code></pre><p>Then we can build a <code>Person</code> instance based on the serialized name and the <code>name</code> field:</p><pre><code><span class="keyword">func</span> instantiatePerson(className: <span class="type">String</span>, name: <span class="type">String</span>) -&gt; <span class="type">Person</span>? {
  knownPersonTypes[className]?.<span class="keyword">init</span>(name: name)
}
</code></pre><h3><code>any</code> metatypes</h3><p>Class metatypes opened up the ability to use dynamic dispatch via subclassing, but there's a more general way: metatypes work with <code>any</code>, so we can express the "type of a some type that conforms to a protocol." For example, a value of type <code>any InitByName.Type</code> stores the metatype for some type that conforms to <code>InitByName</code>. That can be <code>Person</code> (or any of its subclasses), or some <code>struct</code> or <code>enum</code> that conforms to the protocol:</p><pre><code><span class="keyword">struct</span> Fruit: <span class="type">InitByName</span> {
	<span class="keyword">var</span> name: <span class="type">String</span>
  <span class="keyword">static var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"FRUIT"</span> }
}
</code></pre><p>The same registry code from before works just as well when we generalize <code>Person</code> to <code>any InitByName</code>. Here it is:</p><pre><code><span class="keyword">var</span> knownTypes: [<span class="type">String</span>: any <span class="type">InitByName</span>.<span class="type">Type</span>] = [:]

<span class="keyword">func</span> addInitByNameType(<span class="keyword">_</span> type: any <span class="type">InitByName</span>.<span class="type">Type</span>) {
  knownTypes[type.<span class="property">serializedTypeName</span>] = type
}

<span class="keyword">func</span> instantiate(typeName: <span class="type">String</span>, name: <span class="type">String</span>) -&gt; (any <span class="type">InitByName</span>)? {
  knownTypes[typeName]?.<span class="keyword">init</span>(name: name)
}
</code></pre><p>Note how the result of calling the initializer of a value of type <code>any InitByName.Type</code> is a value of type <code>any InitByName</code>. We don't know what metatype will be stored in the <code>any InitByName.Type</code> (although we could check with <code>as?</code> or a <code>case</code>), but we do know that its instance will conform to <code>InitByName</code>, so it's represented as <code>any InitByName</code>.</p><h3>Explicitly-specified generic function arguments</h3><p>C++ allows you to explicitly specify the template arguments for a function template. C++ libraries tend to make use of this feature when a type should be explicitly specified by the caller. For example, imagine a "numeric cast" template like this:</p><pre><code>template&lt;typename <span class="type">To</span>, typename <span class="type">From</span>&gt;
<span class="type">To</span> <span class="call">numeric_cast</span>(const <span class="type">From</span>&amp; from);
</code></pre><p>In C++, the template argument for <code>To</code> can't be inferred by a normal call like <code>numeric_cast(d)</code>, so we explicitly specify the type at the call site, e.g.,:</p><pre><code>double d = <span class="number">17.0</span>;
int x = numeric_cast&lt;int&gt;(d);
</code></pre><p>Now, Swift is actually a bit different here. We can write essentially the same generic function:</p><pre><code><span class="keyword">func</span> numericCast&lt;To: <span class="type">Numeric</span>, From: <span class="type">Numeric</span>&gt;(<span class="keyword">_</span> value: <span class="type">From</span>) -&gt; <span class="type">To</span>
</code></pre><p>but it's going to behave differently at the call site. Swift's type inference uses more contextual cues that C++'s template argument deduction, so a call like this will work fine in Swift:</p><pre><code><span class="keyword">let</span> x: <span class="type">Int</span> = <span class="call">numericCast</span>(d)
</code></pre><p>If you don't have type context to infer the type, i.e., if you just write:</p><pre><code><span class="call">numericCast</span>(d)  <span class="comment">// type inference fails to find a `To` type</span>
</code></pre><p>then type inference will fail to infer a <code>To</code> type. An <code>as</code> coercion can fix this:</p><pre><code><span class="call">numericCast</span>(d) <span class="keyword">as</span> <span class="type">Int</span>
</code></pre><p>Given that type inference usually figures out the types for us, and Swift already has the general notion of using <code>as</code> to provide type information when it doesn't, Swift never got the ability to explicitly provide generic arguments for functions. <code>numericCast&lt;Int&gt;(d)</code> is an error in Swift.</p><p>But what if you <em>want</em> to require the type to be specified at the call site, and not rely entirely on type inference? Turns out that you can use metatypes, and the result is really nice:</p><pre><code><span class="keyword">func</span> numericCast&lt;From: <span class="type">Numeric</span>, To: <span class="type">Numeric</span>&gt;(<span class="keyword">_</span> value: <span class="type">From</span>, to type: <span class="type">To</span>.<span class="type">Type</span>) -&gt; <span class="type">To</span>
</code></pre><p>Here, we've added a <code>to</code> parameter of the metatype of <code>To</code>. The user specifies the metatype of the type to convert to at the call site, like this:</p><pre><code><span class="keyword">let</span> x = <span class="call">numericCast</span>(d, to: <span class="type">Int</span>.<span class="keyword">self</span>)
</code></pre><p>The type of <code>To</code> is inferred from the argument. It also reads really nicely: "numeric cast <code>d</code> to <code>Int</code>".</p><p>Will Swift eventually gain the ability to explicitly specify the generic arguments of a generic function? Maybe someday, but not having this feature led to the discovery of the metatype-based solution above, and I think the end result is better for readability.</p><h2>Associated types</h2><p>Associated types have some interesting interactions with type erasure. Let's explore those now, bringing back the <code>Collection</code> protocol from the prior post on Swift generics to develop these ideas further:</p><pre><code><span class="keyword">protocol</span> Collection {
  <span class="keyword">associatedtype</span> Value
  <span class="keyword">associatedtype</span> Index: <span class="type">Equatable</span>

  <span class="keyword">var</span> startIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">var</span> endIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">func</span> index(after index: <span class="type">Index</span>) -&gt; <span class="type">Index</span>
  
  <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Value</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">var</span> first: <span class="type">Value</span>? { 
    startIndex == endIndex ? <span class="keyword">nil</span> : <span class="keyword">self</span>[startIndex]
  }
}
</code></pre><h3>Erasure of associated types</h3><p>Let's say we have a value <code>c</code> of type <code>any Collection</code>:</p><pre><code><span class="keyword">var</span> c: any <span class="type">Collection</span>
</code></pre><p>At runtime, <code>c</code> could store an <code>[Int]</code> or a <code>[String: (any InitByName).Type]</code>, or a <code>Set&lt;String&gt;</code> or any other collection. If we ask for the <code>first</code> value in <code>c</code>:</p><pre><code><span class="keyword">let</span> f = c.<span class="property">first</span>
</code></pre><p>what type should we expect to get? We know it's the <code>Value</code> type of the underlying collection, but since we don't know what the collection itself is, we don't know the <code>Value</code> type of it, either. Therefore, the type of the <code>first</code> is also type-erased by replacing each occurrence of an associated type (here, it's <code>Value</code>) with an <code>any</code> type based on the constraints placed on that associated type. There are no constraints on <code>Value</code>, so the type of <code>first</code> (<code>Value?</code>) is type-erased to <code>Any?</code>.</p><p>For an associated type like <code>Index</code> that has constraints, we'll get a more interesting resulting type: <code>Index</code> will be type-erased to <code>any Equatable</code>, so if we grab the start and end index of our collection, we'll get <code>any Equatable</code> values:</p><pre><code><span class="keyword">var</span> si = c.<span class="property">startIndex</span>   <span class="comment">// inferred type is 'any Equatable'</span>
<span class="keyword">let</span> ei = c.<span class="property">endIndex</span>     <span class="comment">// inferred type is 'any Equatable'</span>
</code></pre><p>The type erasure for associated types happens automatically, and generally means that once you've erased some type information, that type information stays erased until you do something explicit to bring type information back. Most of the time, that's fine, but it can be surprising.</p><h3>Equality of types</h3><p>Now that we have the start and end indices, it's completely reasonable that we'd want to be able to loop over the elements of our collection <code>c</code>, perhaps like this:</p><pre><code><span class="keyword">while</span> si != <span class="call">ei</span> {
  <span class="keyword">let</span> element = c.<span class="property">subscript</span>[si]
  <span class="call">doSomething</span>(element)
  si = c.<span class="call">index</span>(after: si)
}
</code></pre><p>However, this can't work. Let's focus on the <code>si != ei</code>, which is trying to use the <code>!=</code> operator from the <code>Equatable</code> protocol:</p><pre><code><span class="keyword">protocol</span> Equatable {
  <span class="keyword">static func</span> ==(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
  <span class="keyword">static func</span> !=(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
}
</code></pre><p>Remember that <code>Self</code> is the actual, concrete type that conforms to the protocol <code>Equatable</code>. When we write <code>si != ei</code>, where each of <code>si</code> and <code>ei</code> are of type <code>any Equatable</code>, the actual type for <code>Self</code> is stored inside that <code>any Equatable</code> and can vary at runtime. Here in the call, there's no static guarantee that both <code>si</code> and <code>ei</code> have the same underlying type as run-time, so the compiler has to reject the call. Otherwise, we could end up trying to compare an <code>Int</code> to a <code>String</code>, but there's no operator for that.</p><h3>Opening <code>any</code> types</h3><p>To make this work, we're going to have to <em>dynamically</em> check that both sides have the same type, <em>then</em> use their operator. Let's build a function to check equality of two distinct <code>Equatable</code> types. To do so, we're going to use generics:</p><pre><code><span class="keyword">func</span> isEqual&lt;T: <span class="type">Equatable</span>, U: <span class="type">Equatable</span>&gt;(<span class="keyword">_</span> lhs: <span class="type">T</span>, rhs: <span class="type">U</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">if let</span> rhsAsT = rhs <span class="keyword">as</span>? <span class="type">T</span> {
    <span class="keyword">return</span> lhs == rhsAsT
  }
  
  <span class="keyword">if let</span> lhsAsU = lhs <span class="keyword">as</span>? <span class="type">U</span> {
    <span class="keyword">return</span> lhsAsU == rhs
  }
  
  <span class="keyword">return false</span>
}
</code></pre><p>The types <code>T</code> and <code>U</code> could be different, so we first try to cast <code>rhs</code> to a <code>T</code>: if that succeeds, we can compare the values as <code>T</code> instances because <code>T</code> is <code>Equatable</code>. We also try in the other direction, to compare as <code>U</code> instances (via <code>U: Equatable</code>). If both fail, the types are incomparable, and we return <code>false</code>. Now, our loop condition can be</p><pre><code><span class="keyword">while</span> !<span class="call">isEqual</span>(si, ei) { ... }
</code></pre><p>But how does that <em>work</em>? We passed two <code>any Equatable</code> values (which are firmly runtime-polymorphic) into a generic function (which is statically-polymorphic), and it... just... works. This is what I meant be moving between static and dynamic polymorphism in Swift.</p><p>What's happening under the hood is called "opening" the <code>any</code> type. Effectively, the compiler is reaching in to each <code>any Equatable</code> value to pull out the concrete type, and binding the appropriate generic parameter (<code>T</code> or <code>U</code>) to that concrete type. Swift can do this due to separate compilation of generics, so the <code>isEqual</code> function implementation can work with types that aren't known until runtime.</p><p>We could write a similar function to perform the subscript of the collection, but it would be a lot easier if we turned the whole loop into a generic function on the collection. Say, a for-each operation:</p><pre><code><span class="keyword">func</span> forEach&lt;C: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> c: <span class="type">C</span>, body: (<span class="type">C</span>.<span class="type">Value</span>) -&gt; <span class="type">Void</span>) {
  <span class="keyword">var</span> si = c.<span class="property">startIndex</span>
  <span class="keyword">let</span> ei = c.<span class="property">endIndex</span>
  <span class="keyword">while</span> si != <span class="call">ei</span> {
    <span class="keyword">let</span> current = c[si]
    <span class="call">body</span>(current)
    si = c.<span class="call">index</span>(after: si)
  }
}
</code></pre><p>This operation is generic: we have a name for the collection type (<code>C</code>), and know the relationship to its <code>Value</code> and <code>Index</code> types, so we have strong type equality. We can call this function with a value of type <code>any Collection</code>:</p><pre><code><span class="call">forEach</span>(c) { element <span class="keyword">in</span>
  <span class="call">doSomething</span>(element)
}
</code></pre><p>That call opens up the type of <code>c</code>, binding it to <code>forEach</code>'s generic parameter <code>C</code>. The call itself still needs to erase the associated type, so the <code>element</code> parameter of the closure will be the type-erased <code>Value</code> type, i.e., <code>Any</code>.</p><h3>Primary associated types</h3><p>Sometimes, it can be useful to be able to make some of the associated types concrete even when using an <code>any</code> type. For example, we might want to be able to take any collection stores <code>String</code> values. We can do so with <em>primary</em> associated types, which use generic argument syntax to specify associated types. The primary associated types are listed in angle brackets following the protocol name:</p><pre><code><span class="keyword">protocol</span> Collection&lt;Value&gt; {
  <span class="keyword">associatedtype</span> Value
  <span class="keyword">associatedtype</span> Index: <span class="type">Equatable</span>
  <span class="comment">// ...</span>
}
</code></pre><p>This enables <code>any</code> types to specify the <code>Value</code> type. For example, <code>any Collection&lt;String&gt;</code> is any type that conforms to <code>Collection</code> and has <code>String</code> as its value type. A value of such a type could store a <code>[String]</code>, <code>Set&lt;String&gt;</code>, or other collection:</p><pre><code><span class="keyword">var</span> strings: any <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;
strings = [<span class="string">"Hello"</span>, <span class="string">"World"</span>]
<span class="call">print</span>(strings.<span class="property">first</span> ?? <span class="string">"Empty collection"</span>) <span class="comment">// "Hello"</span>
strings = [<span class="string">"Hello"</span>, <span class="string">"World"</span>] <span class="keyword">as</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;
<span class="call">print</span>(strings.<span class="property">first</span> ?? <span class="string">"Empty collection"</span>) <span class="comment">// "Hello" or "World"; ordering in sets is not guaranteed</span>

strings = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// error: cannot convert value of type 'Int' to expected element type 'String'</span> 
</code></pre><p>Even when there are primary associated types, one can use <code>any</code> types without mentioning them. In such cases, the associated type will be type-erased. For example, with the above protocol, <code>any Collection</code> will have its <code>Value</code> type type-erased to <code>Any</code>.</p><p>Why did we choose to make <code>Value</code> a primary associated type and not <code>Index</code>? It's all about the use cases, and here your instincts from C++ containers will serve you well: you generally care about the value type of a container because you're operating on its elements, but its iterator type is generally not interesting except as a mechanism to get at the elements. More importantly, although you generally get to choose the value type of your container, but the iterator comes with it, so only the value type makes sense as a primary associated type.</p><h2>When to type-erase?</h2><p>Type erasure via <code>any</code> is not free: an instance of an <code>any</code> type has a fixed-sized buffer along with information about the (dynamically) stored type and each of the protocols that type conforms to. When the stored value is larger than that buffer, the <code>any</code> instance will be heap-allocated. Every operation on an instance of <code>any</code> goes through the equivalent of a <code>virtual</code> method dispatch, including copying and destruction. If you've ever looked into the implementation of <code>std::any</code> or <code>std::function</code>, you'll have a good mental model for how <code>any</code> types work under the hood in Swift, and why they aren't cheap. The Swift optimizer will do some amount of specialization of <code>any</code> types, but for it to succeed it needs to see both the creation and use of the <code>any</code> type, so it's not recommended to rely heavily on this optimization.</p><p>Use <code>any</code> types when you need to store heterogeneous data that potentially accepts any number of types. If there's a small, fixed number of types that you might store (say, a choice among a few basic types), consider using an <code>enum</code> instead:</p><pre><code><span class="keyword">enum</span> StoredValue: <span class="type">Hashable</span> {
  <span class="keyword">case</span> integer(<span class="type">Int</span>)
  <span class="keyword">case</span> floating(<span class="type">Double</span>)
  <span class="keyword">case</span> string(<span class="type">String</span>)
}
</code></pre><p>Operations on the <code>StoredValue</code> enum will be more efficient than operating on an <code>any Hashable</code> instance, because <code>StoredValue</code> is a concrete type.</p><p>More importantly, prefer generic operations to operations on <code>any</code> values. There is no reason to have a function that accepts a single <code>any</code> value, for example:</p><pre><code><span class="keyword">func</span> operateOnAny(strings: any <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;) { ... }
</code></pre><p>because the same function can be expressed generically as follows:</p><pre><code><span class="keyword">func</span> operateOnAny&lt;C: <span class="type">Collection</span>&gt;(strings: <span class="type">C</span>) <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span> == <span class="type">String</span> { ... }
</code></pre><p>Due to opening of <code>any</code> types, which we talked about earlier, the two functions above are effectively interchangeable for callers. The generic function is better for performance, however, both because calls passing a concrete type like <code>[String]</code> avoid the formation of the <code>any Collection&lt;String&gt;</code> value and because it's easier for the compiler to specialize the generic version for <code>[String]</code> when it's profitable.</p><p>This is another place where your C++ instincts are good and you shouldn't ignore them: you wouldn't write a function to take a <code>std::any</code> parameter unless you really couldn't write it as a function template taking an arbitrary <code>T</code>, so think of <code>any</code> types the same way in Swift.</p><p>It's a <em>little</em> unfortunate that the more efficient generic function is more verbose than the less-efficient one. I've been holding off on introducing one last bit of syntactic sugar that gets rid of that advantage, because it needs a little explanation. Spoiler alert: the <code>some</code> keyword is used to introduce unnamed generic parameters with syntax parallel to that of <code>any</code> types, so the second function can be written as:</p><pre><code><span class="keyword">func</span> operateOnAny(strings: <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;) { ... }
</code></pre><p>Each <code>some</code> type introduces an unnamed generic parameter whose constraints are listed after the <code>some</code>. Swift <code>some</code> types are also called <em>opaque</em> types, because they hide the name of the underlying type: an unnamed generic parameter can't be named (duh), so the actual collection type based into <code>operateOnAny(strings:)</code> is hidden from the function body. Opaque types are also useful in the return type of a function to hide the specific return type from the caller.</p><h2>Implementation hiding with opaque types</h2><p><code>any</code> types effectively hide the underlying type from clients, allowing it to change dynamically at run time. These are two different things: the first is about hiding implementation details behind an abstraction barrier (e.g., we know that we have a <code>Collection</code> of <code>String</code>s, but not the specific type of the collection itself) and the other is about allowing the underlying representation to change dynamically (e.g., we can choose <code>Set&lt;String&gt;</code> or <code>[String]</code> depending on what's best for the problem at hand).</p><p>Swift has a notion of <em>opaque</em> types that let you hide the implementation type behind an abstraction barrier without allowing it to change dynamically at runtime. This gives you, as the implementer, the freedom to limit your API surface area (by not exposing specific conrete types) and evolve your implementations over time, without breaking clients. For example, let's consider implementing a generic function <code>uniqued</code> on a <code>Collection</code> that produces a new collection with duplicates removed. We could have such a function return a <code>Set</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">func</span> uniqued() -&gt; <span class="type">Set</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>)
  }
}
</code></pre><p>That implementation was easy, but it's perhaps not the best one. It might be better to unique into an array and return that, or return some different type entirely. The problem is that we have to decide right at the point where we create this function what the act type will be, and assess all of the tradeoffs.</p><p>We could introduce a special type to capture the "uniqued collection", like <code>UniquedCollection&lt;Self&gt;</code>. That's probably what we would do in C++, perhaps burying it in an <code>impl</code> or <code>detail</code> namespace to discourage users from depending on it.</p><p>Opaque types let us describe the result type based on its capabilities (in terms of protocols) without stating its identity:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>) <span class="comment">// okay, Set&lt;Value&gt; is a Collection&lt;Value&gt;</span>
  }
}
</code></pre><p>A user that calls <code>uniqued()</code> can't spell the type of the result, but it can be inferred and is known to be a collection containing the same value type as the collection it was applied to:</p><pre><code><span class="keyword">let</span> uniquedNumbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>].<span class="call">uniqued</span>()   <span class="comment">// okay, type is opaque to the user</span>
<span class="call">print</span>(uniquedNumbers.<span class="property">first</span>)                         <span class="comment">// prints the (1)</span>
</code></pre><p>If we later decide to change the type returned by <code>unique()</code>, we can, because we never exposed the type to the user. So we can change our implementation to produce an array:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Array</span>(<span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>)) <span class="comment">// okay, unique via a set but return an array</span>
  }
}
</code></pre><p>or a private type of some sort:</p><pre><code><span class="keyword">private struct</span> UniquedCollection&lt;C: <span class="type">Collection</span>&gt;: <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span>: <span class="type">Hashable</span> {
  ...
}

<span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">UniquedCollection</span>(<span class="keyword">self</span>) <span class="comment">// okay, unique via a set but return an array</span>
  }
}
</code></pre><p>Because the type is opaque to clients, these implementation changes won't affect them at all: they're under-the-hood improvements made by the author of <code>uniqued()</code>.</p><h3><code>some</code> vs. <code>any</code></h3><p>In Swift, <code>any</code> types can be read to mean "any type that satisfies these requirements" whereas <code>some</code> types are read to mean "some specific type that satisfied these requirements". The key point here is that <code>some</code> types maintain identity whereas <code>any</code> types do not: if I take that <code>uniquedNumbers</code> type from above, I can iterate over it directly:</p><pre><code><span class="keyword">let</span> uniquedNumbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>].<span class="call">uniqued</span>()
<span class="keyword">var</span> ci = uniquedNumbers.<span class="property">startIndex</span>
<span class="keyword">let</span> ei = uniquedNumbers.<span class="property">endIndex</span>
<span class="keyword">while</span> ci != <span class="call">ei</span> { <span class="comment">// okay, Index type of the opaque type of uniquedNumbers</span>
  <span class="call">print</span>(uniquedNumbers[ci])
  ci = uniquedNumbers.<span class="call">index</span>(after: ci)
}
</code></pre><p>This puts some restrictions on the body of functions returning <code>some</code> types. Specifically, every <code>return</code> statement must produce a value of the same type. This is called the <em>underlying type</em>, and the Swift compiler will detect a mismatch:</p><pre><code><span class="number">66</span> | <span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
<span class="number">67</span> |   <span class="keyword">func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
   |        `- error: function declares an opaque <span class="keyword">return</span> type '<span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt;', but the <span class="keyword">return</span> 
   |           statements <span class="keyword">in</span> its body <span class="keyword">do</span> not have matching underlying types
<span class="number">68</span> |     <span class="keyword">if</span> isEmpty {
<span class="number">69</span> |       <span class="keyword">return</span> [<span class="type">Element</span>]()
   |                      `- note: <span class="keyword">return</span> statement has underlying type '[<span class="type">Self</span>.<span class="type">Value</span>]'
<span class="number">70</span> |     }
<span class="number">71</span> | 
<span class="number">72</span> |     <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">self</span>)
   |                       `- note: <span class="keyword">return</span> statement has underlying type '<span class="type">Set</span>&lt;<span class="type">Self</span>.<span class="type">Value</span>&gt;'
<span class="number">73</span> |   }
<span class="number">74</span> | }
</code></pre><p>Note that the identity of the underlying type is hidden from clients of the function, but it is known to the compiler, so hiding a type via an opaque type isn't a performance pessimization the way an <code>any</code> type is.</p><h3>Hiding complicated result types</h3><p>Opaque result types really shine when they're used to hide unnecessary implementation details. To see what I mean, think about the types that are produced from a C++ library that uses <a href="https://en.wikipedia.org/wiki/Expression_templates">expression templates</a>: every single operator introduces another wrapper type (often two of them), producing a final result whose type encodes the entire operation. For example, one might have a <code>parallel_array</code> type that uses expression templates, and an expression like:</p><pre><code>auto result = a * x + b
</code></pre><p>would produce a type such as <code>expr&lt;add_expr&lt;expr&lt;mul_expr&lt;expr&lt;parallel_array&lt;double&gt;&gt;, expr&lt;double&gt;&gt;&gt;, expr&lt;parallel_array&lt;double&gt;&gt;&gt;</code>. Add some namespace qualifiers in there and it gets overwhelming, fast.</p><p>It gets particularly bad when you have to name the result type for some reason, e.g.,</p><pre><code>template&lt;typename <span class="type">A</span>, typename <span class="type">X</span>, typename <span class="type">B</span>&gt;
expr&lt;add_expr&lt;expr&lt;mul_expr&lt;<span class="type">A</span>, <span class="type">X</span>&gt;&gt;, <span class="type">Y</span>&gt; <span class="call">mul_add</span>(<span class="type">A</span> a, <span class="type">X</span> x, <span class="type">B</span> b) {
  <span class="keyword">return</span> a * x + b;
}
</code></pre><p>Expression templates can be a useful tool in Swift for the same reasons they're useful in C++, and Swift would have exactly the same issue with an explosion in user-facing types from simple uses. However, opaque result types let us hide the information behind a <code>some</code> type. For example,</p><pre><code><span class="keyword">protocol</span> ArrayExpr&lt;Value&gt; {
  <span class="keyword">associatedtype</span> Value: <span class="type">Numeric</span>
}

<span class="keyword">private struct</span> MulScalarOp&lt;LHS: <span class="type">ArrayExpr</span>&gt;: <span class="type">ArrayExpr</span> {
  <span class="keyword">typealias</span> Value = <span class="type">LHS</span>.<span class="type">Value</span>

  <span class="keyword">init</span>(lhs: <span class="type">LHS</span>, rhs: <span class="type">LHS</span>.<span class="type">Value</span>) { ... }
}

<span class="keyword">func</span> *&lt;<span class="type">Value</span>&gt;(lhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, rhs: <span class="type">Value</span>) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; { 
  <span class="type">MulScalarOp</span>(lhs: lhs, rhs: value)
}

<span class="keyword">private struct</span> AddArrayOp&lt;LHS: <span class="type">ArrayExpr</span>, RHS: <span class="type">ArrayExpr</span>&gt; <span class="keyword">where</span> <span class="type">LHS</span>.<span class="type">Value</span> == <span class="type">RHS</span>.<span class="type">Value</span> {
  <span class="keyword">typealias</span> Value = <span class="type">LHS</span>.<span class="type">Value</span>

  <span class="keyword">init</span>(lhs: <span class="type">LHS</span>, rhs: <span class="type">RHS</span>) { ... }
}

<span class="keyword">func</span> +&lt;<span class="type">Value</span>&gt;(lhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, rhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; { 
  <span class="type">AddArrayOp</span>(lhs: lhs, rhs: rhs)
}
</code></pre><p>Now, code like this:</p><pre><code><span class="keyword">let</span> result = a * x + b
</code></pre><p>produces an opaque type like <code>some ArrayExpr&lt;Double&gt;</code> that avoids exposing all of the implementation details of the expression templates. Add operation like the C++ <code>mul_add</code> earlier can be expressed in terms of opaque types so one never has to name the complicated types:</p><pre><code><span class="keyword">func</span> mulAdd&lt;Value&gt;(<span class="keyword">_</span> a: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, <span class="keyword">_</span> x: <span class="type">Value</span>, <span class="keyword">_</span> b: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; {
  a * x + b
}
</code></pre><p>We're still expressing the fundamental type constraints here: both <code>a</code> and <code>b</code> are array expressions of some type, whose underlying value type is <code>Value</code>, and <code>x</code> is a scalar of type <code>Value</code>. But we've abstracted away the actual array expression types so they can be propagated behind-the-scenes.</p><p>However, the compiler can still see the underlying types, so it can optimize the expression templates in the same manner one would expect.</p><h2>Wrap up</h2><p>Type erasure in Swift leverages the same notion of protocols and constraints as generics, but moves from the realm of static polymorphism (concrete types known at compile time) to runtime polymorphism (types only known at runtime). Type erasure makes it easy to create heterogeneous data structures, which contain values of types not known until runtime.</p><p>Because of Swift's model of separate compilation, one can move easily between static and dynamic polymorphism: a value that conforms to a protocol <code>P</code> can be type-erased into a value of type <code>any P</code>, moving from static to dynamic polymorphism. Conversely, a value of type <code>any P</code> can be passed to a generic function requiring a type conforming to <code>P</code>, moving from dynamic back to static polymorphism. So while most of the time you should probably be using generics for abstraction, because they maintain more type information and are therefore easier to optimize, you can use type erasure locally in those places where you need the runtime polymorphism.</p><p>We also discussed metatypes. Metatypes are first-class values in Swift, and are the answer to the question "what's the type of this value?". Metatypes can be used to identify the types of values, construct new instances of the identified type (when there is a suitable <code>init</code> requirement), and dynamically query the capabilities of a given type with queries such as "does this type conform to the protocol <code>Decodable</code>?".</p><p>Next up, we'll explore Swift's take on error handling, comparing against C++'s model of exceptions.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li><li><a href="/tags/generics">Generics</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>