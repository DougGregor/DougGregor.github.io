<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-global-variables"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-global-variables"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-global-variables"/><title>Swift for C++ Practitioners, Part 8: Global Variables | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 8: Global Variables | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 8: Global Variables | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 8: Global Variables"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 8: Global Variables"/><meta property="og:description" content="Swift for C++ Practitioners, Part 8: Global Variables"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-05-21 06:58:00 +0000</p><p>Last updated on 2024-06-15 05:10:50 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 8: Global Variables</h1><p>At the end of part 7, I promised I was going to talk about Swift language extensibility next. That post is taking some time, and today the differences between global variables in C++ and Swift came up in a discussion. So, here's a little interlude on our way to language extensibility to talk about global variables.</p><h2>Global variables &amp; static variables</h2><p>The basic idea of global variables is the same in Swift as in C++. In C++ you can define a variable at namespace scope, like this:</p><pre><code><span class="type">Registry</span> *globalRegistry = new <span class="type">Registry</span>()
</code></pre><p>and it's accessible from anywhere. Swift has the same for variables declared at module scope, e.g.,</p><pre><code><span class="keyword">let</span> globalRegistry: <span class="type">Registry</span> = <span class="type">Registry</span>()
</code></pre><p>You can draw the same parallels between C++ and Swift static variables, so where in C++ you would write:</p><pre><code><span class="keyword">class</span> Registry {
public:
  <span class="comment">// Declaration</span>
  <span class="keyword">static</span> <span class="type">Registry</span> *sharedRegistry;
};

<span class="comment">// Definition</span>
<span class="type">Registry</span> *<span class="type">Registry</span>::sharedRegistry = new <span class="type">Registry</span>();
</code></pre><p>in Swift you can do the same:</p><pre><code><span class="keyword">class</span> Registry {
  <span class="keyword">static let</span> sharedRegistry: <span class="type">Registry</span> = <span class="type">Registry</span>()
}
</code></pre><p>Totally straightforward, no surprises here... yet.</p><h2>(No) generic static variables</h2><p>In C++, it's fairly common to have static variables within a class template. For example, perhaps we want a "registry" above, but for each type <code>T</code>. One might write that in C++ as:</p><pre><code>template&lt;typename <span class="type">T</span>&gt;
<span class="keyword">class</span> Registry {
public:
  <span class="comment">// Declaration</span>
  <span class="keyword">static</span> <span class="type">Registry</span>&lt;<span class="type">T</span>&gt; *sharedRegistry;
};

<span class="comment">// Definition</span>
template&lt;typename <span class="type">T</span>&gt;
<span class="type">Registry</span>&lt;<span class="type">T</span>&gt; *<span class="type">Registry</span>&lt;<span class="type">T</span>&gt;::sharedRegistry = new <span class="type">Registry</span>&lt;<span class="type">T</span>&gt;();
</code></pre><p>That's fine: we'll get a separate <code>Registry&lt;T&gt;::sharedRegistry</code> for every <code>T</code> The equivalent in Swift produces a compiler error:</p><pre><code><span class="keyword">class</span> Registry&lt;T&gt; {
  <span class="comment">// error: static stored properties not supported in generic types</span>
  <span class="keyword">static let</span> sharedRegistry: <span class="type">Registry</span>&lt;<span class="type">T</span>&gt; = <span class="type">Registry</span>&lt;<span class="type">T</span>&gt;()
}
</code></pre><p>Why does Swift ban this? As I noted back in <a href="../swift-for-cxx-practitioners-generics/index.html">part 4 on generics</a>, Swift's generics are implemented with separate compilation. We do not know at the point where <code>sharedRegistry</code> is defined what types it will be specialized with, and in the general case (say, <code>Registry</code> is in a shared library), it's impossible to know what types it will be specialized with until the program runs. Therefore, we can't allocate space from global memory for every <code>Registry&lt;T&gt;.sharedRegistry</code> that we might come across.</p><p>Yes, we <em>could</em> create a hash table indexed based on the generic argument for <code>T</code>, allocating new <code>sharedRegistry</code> instances on the heap each time there's a new generic argument... but this is <em>really</em> stretching the definition of "global variable", and the performance of such a feature would be surprising (to say the least). Instead, Swift prohibits static stored properties in generic types rather than provide an unsatisfying implementation.</p><p>If you really want that hash table implementation, you can build it by following the examples in <a href="../swift-for-cxx-practitioners-type-erasure/index.html">part 5 on type erasure</a>, and it'll look a little bit like this:</p><pre><code><span class="keyword">fileprivate var</span> untypedSharedRegistry: [<span class="type">ObjectIdentifier</span>: <span class="type">Any</span>] = [:]

<span class="keyword">class</span> Registry&lt;T&gt; {
  <span class="keyword">static var</span> sharedRegistry: <span class="type">Registry</span>&lt;<span class="type">T</span>&gt; {
    untypedSharedRegistry[<span class="type">ObjectIdentifier</span>(<span class="type">T</span>.<span class="keyword">self</span>), default: <span class="type">Registry</span>&lt;<span class="type">T</span>&gt;()] <span class="keyword">as</span>! <span class="type">Registry</span>&lt;<span class="type">T</span>&gt;
  }
}
</code></pre><p>Here, <code>untypedSharedRegistry</code> maps from the metatype for <code>T</code> (represented as an <a href="https://developer.apple.com/documentation/swift/objectidentifier"><code>ObjectIdentifier</code></a>, which is a fancy way of saying "identity for something with a stable address") to a type-erased value of type <code>Any</code>. All of the <code>Any</code> instances in the dictionary are actually <code>Registry&lt;T&gt;</code> instances matching the type <code>T</code> that went into the <code>ObjectIdentifier</code>, so we force-cast (with <code>as!</code>) the element on the way out. So long as nobody fiddles with <code>untypedSharedRegistry</code>, that force-cast will never fail.</p><p>So far, Swift global and static variables are the same as C++ global and static variables, except that Swift static variables can't be generic. Things will start to diverge more when we get to initialization.</p><h2>Static initialization in C++</h2><p>Initialization of C++ globals and statics is <a href="https://www.p65warnings.ca.gov">known by the State of California to cause headaches and lost productivity</a>. Indeed, doing a web search for C++ static initialization order turns up a page titled <a href="https://en.cppreference.com/w/cpp/language/siof">Static Initialization Order Fiasco</a> as its second hit.</p><p>It's useful to understand why static initialization is tricky in C++, so that we can explain the path Swift took. C++ initializes global and static variables on a per-translation-unit basis, starting at the first global or static variable and proceeding to the last. However, it is unspecified in what order the different translation units in a program get to run their initializers. So if you have a global variable in translation unit <code>x.cpp</code> that somehow depends on a global variable in <code>y.cpp</code>, you might be okay (if <code>y.cpp</code> has its initializers run first) or your code might crash (if <code>x.cpp</code> has its initializers run first). I don't want to go into all of the solutions for C++ here(this <a href="https://pabloariasal.github.io/2020/01/02/static-variable-initialization/">blog post on C++ Initialization of Static Variables</a> covers some). However, I will point out that the most general solution is <a href="https://isocpp.org/wiki/faq/ctors#static-init-order-on-first-use">Initialize on First Use</a>, which uses a function-local static instead of a global variable or static class member:</p><pre><code><span class="type">Registry</span>&amp; <span class="call">sharedRegistry</span>() {
  <span class="keyword">static</span> <span class="type">Registry</span>* registry = new <span class="type">Registry</span>();
  <span class="keyword">return</span> *registry;
}
</code></pre><p>C++ function-local statics are interesting because they are guaranteed to be initialized on first use, and for most (all?) C++ implementations that initialization uses something like <a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/pthread_once.html"><code>pthread_once</code></a> to ensure that the initialization is thread-safe. Such a nice model, that...</p><p>While we're here, there's another reason to dislike static initialization in C++: you always pay the runtime cost for running the initializers of global and static variables, even if you never use them. This cost can come at unfortunate times in your program, such as program startup and when loading a shared library. Many code bases prohibit global initializers to prevent this cost, using something like Clang's <code>-Wglobal-constructors</code> warning.</p><h2>Lazy initialization in Swift</h2><p>Initialization of global and static variables in Swift applies the "Initialize on First Use" principle, always. There is no notion of a Swift "global initializer" that is run prior to <code>main</code>, or when a shared library is loaded. Rather, like function-local statics in C++, every global and static variable is protected so that its initializer runs at most once, on the first initialization, using something like <code>pthread_once</code> to make the initialization itself thread-safe.</p><p>This approach has a lot of nice properties: the Static Initialization Order Fiasco just doesn't exist in Swift, so you don't need to introduce tricks to avoid it. You only pay the cost of initializing those global variables that you actually use, and that cost is paid when you use it the first time---not at program startup. An unused global variable (say, in a library) have very little cost at all: just the space it takes up in memory. The overhead of something like <code>pthread_once</code> is fairly low for the thread-safety it brings to the model.</p><p>The only real downside I've seen to this approach is that it can be surprising if you're expecting to use the initialization of a global for its side effects, or have some other reason to expect and want the C++ semantics.</p><h2>Lazy initialization for instance properties</h2><p>The stored instance properties of a struct or class are initialized as part of the initializer, and will remain initialized until the struct or class is destroyed. However, one can get lazy initialization semantics for instance properties by using the <code>lazy</code> keyword. For example, let's imagine that a class has some expensive-to-initialize instance property that isn't used all that often. We could make it lazily created by using an optional as the underlying storage, and using a computed property to access the conceptual value:</p><pre><code><span class="keyword">class</span> C {
  <span class="comment">// Underlying storage</span>
  <span class="keyword">private var</span> expensiveImpl: <span class="type">Expensive</span>? = <span class="keyword">nil</span>
  
  <span class="comment">// The property available everywhere else.</span>
  <span class="keyword">var</span> expensive: <span class="type">Expensive</span> {
    <span class="keyword">mutating get</span> { 
      <span class="comment">// If we already have a value, return it.</span>
      <span class="keyword">if let</span> existing = expensiveImpl {
        <span class="keyword">return</span> existing
      }
      
      <span class="comment">// Create a new value and stash it in the underlying storage for later use.</span>
      <span class="keyword">let</span> value = <span class="type">Expensive</span>()
      expensiveImpl = value
      <span class="keyword">return</span> value
    }
    
    <span class="keyword">set</span> {
      expensiveImpl = newValue
    }
  }
}
</code></pre><p>That's a lot of code, but it's mostly straightforward: <code>expensiveImpl</code> starts out by storing <code>nil</code>, and is replaced by either the default value (if accessed first via the getter) or the value assigned into it (if accessed first via the setter). This lazy initialization is effectively invisible to the user, who accesses the value through the computed property <code>expensive</code>, and is similar to what happens under the hood for global and static variables (minus the thread-safety).</p><p>This kind of construct comes up a lot in certain kinds of programming, and it's a ton of boilerplate to write out each time. Therefore, Swift lets you do the same thing directly with a <code>lazy var</code>:</p><pre><code><span class="keyword">class</span> C {
  <span class="keyword">lazy var</span> expensive: <span class="type">Expensive</span> = <span class="type">Expensive</span>()
}
</code></pre><p>The effect of this code is the same as the prior example, but the Swift compiler is doing the work of introducing the stored property of type <code>Expensive?</code> behind the scenes and making <code>expensive</code> computed. Note that <code>lazy</code> variables do <em>not</em> need to be initialized within an initializer, because they get the default initialization to <code>nil</code>.</p><p>Unlike global and static variables, a <code>lazy var</code> does <em>not</em> provide thread-safe initialization. The reasoning here is that, if multiple threads are accessing a given instance of a struct or class concurrently, <em>you already have a data race</em>. There's no point in having the compiler increase the size of each struct or class instance, and pay the cost of something like <code>pthread_once</code>, to protect against a second-order data race. Rather, Swift's model is moving toward eliminating this class of data races entirely in Swift 6.</p><h2>No guaranteed constant initialization</h2><p>One feature of C++ initialization is that has no analogue yet in Swift is constant initialization. For example, with C++ <a href="https://en.cppreference.com/w/cpp/language/constinit"><code>constinit</code></a> it's possible to guarantee that there is no runtime initialization for a declaration:</p><pre><code>constinit int buckets = <span class="number">17</span>;
</code></pre><p>C++ programmers often depend on constant initialization to avoid the problems of static initialization I've talked about here. It can also be important in low-level systems where you might not even have the ability to perform initialization prior to <code>main</code>.</p><p>Swift has no such feature. I expect that at some point it will get a feature similar to C++20 <code>constinit</code>, which guarantees that a particular initialization produces a constant value that requires no run-time code execution. However, Swift still needs a model of constant evaluation for that to happen, and as of this writing there isn't yet a complete design to point to.</p><h2>Wrap-up</h2><p>Global and static variables in Swift are conceptually similar to those in C++, and used for much the same purpose. However, Swift takes the "Initialize on First Use" principle all the way, with all global and static variables being initialized on first use. Function-local statics in Swift work identically to those in C++, based on the same "Initialize on First Use" principle.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>