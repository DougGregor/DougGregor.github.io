<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-dsls"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-dsls"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-dsls"/><title>Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages with Result Builders | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages with Result Builders | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages with Result Builders | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages"/><meta property="og:description" content="Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-11-23 14:30:00 +0000</p><p>Last updated on 2024-11-24 06:47:15 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 11: Domain-Specific (Embedded) Languages with Result Builders</h1><p>The <a href="../swift-for-cxx-practitioners-operators">prior installment</a> of this series covered operator overloading in Swift in great detail. As in C++, operator overloading can be used to great effect to build Domain-Specific Languages embedded within normal source code. When used well, these Domain-Specific Embedded Languages (DSELs) can make it easy to express your ideas in a specific domain while still leveraging all of the tools of the general-purpose programming language in which they are embedded. (Used poorly, it can be make a mess... so let's not do that.)</p><p>Swift provides some additional features specifically to help with the construction of DSELs. All of these are syntactic sugar: you can express what they do in Swift code without them, but doing so often requires a lot of boilerplate that can leave a bitter taste in your mouth. (Boiled plates, yuck!)</p><h2>Result builders</h2><p>There is a large class of DSLs that are <em>declarative</em> in nature, meaning that you state (declare) what you want but not how it should be accomplished. Then, the library or tool that processes the declarative DSL will turn that into a computation that produces the desired result. While there are some programming languages that are declarative (such as <a href="https://en.wikipedia.org/wiki/Prolog">Prolog</a>), neither Swift nor C++ are declarative languages: they're both imperative with some functional elements, but however you spin it, in Swift and C++ it's up to you to describe how to compute the answer you want.</p><p>Within imperative and functional languages, there are often libraries that provide a declarative API. For example, a regular expression library like <code>std::regex</code> has an interface to describe the shape of strings you want to match, and the library "compiles" that into an efficient state machine to use when matching the regular expression against input strings. To achieve this, the input language (regular expressions) is constrained to something that admits an efficient implementation. This is an important aspect of declarative DSLs: constraints are key to keeping code using the DSL easy to reason about and ensure that efficient implementation is possible. Other common kinds of DSLs include structured output (e.g., to HTML) and declarative UI libraries.</p><p>Swift's <em>result builders</em> provide a way to embed a declarative DSL directly in Swift. The inputs to result builders are blocks of code---closures---with a restricted form that gets translated into a structured form that the library can compute. Each kind of entity allowed within the closures, such as expressions and <code>if</code> statements, can be mapped by the result builder into another value, with the results being combined at the end of each block. That's all very abstract, so let's get to the CODE!</p><h2>A small HTML DSL</h2><p>Emitting HTML from a program is a simple but tedious exercise: tags need to be typed correctly and matched, and the moment you have any logic in there, you're concatenating strings together everywhere. Multi-line strings and interpolation can reduce the boilerplate a bit, but it can still be messy even for simple things:</p><pre><code><span class="keyword">let</span> output = <span class="string">"""
  &lt;html&gt;
    &lt;body&gt;
      &lt;div&gt;</span>
        \(chapterTitle <span class="string">!= nil ? "&lt;h1&gt;</span>\(chapterTitle!)<span class="string">&lt;/h1&gt;\n" : "")
        &lt;para&gt;Call me Ishmael. Some years ago...&lt;/para&gt;
				&lt;para&gt;There is now your insular city...&lt;/para&gt;
      &lt;/div&gt;
    &lt;/body&gt;
  &lt;/html&gt;
  """</span>
</code></pre><p>With result builders, we can write the above in a more declarative manner that leverages Swift's syntax and control structures to eliminate the error-prone matching of syntax and nesting of string interpolations. Let's start with the result and work back from there. We can produce something like this:</p><pre><code><span class="keyword">let</span> output = <span class="call">html</span> {
  <span class="call">body</span> {
    <span class="call">div</span> {
      <span class="keyword">if let</span> chapterTitle {
        <span class="call">h1</span> { chapterTitle }
      }
      <span class="call">para</span> { <span class="string">"Call me Ishmael. Some years ago..."</span> }
      <span class="call">para</span> { <span class="string">"There is now your insular city..."</span> }
    }
  }
}
</code></pre><p>The structure is the same, but we've taken all of the manual strings and nested string interpolations out of it: the nesting structure of the HTML is expressed in the braces structure of the Swift, the actual strings we're placing into the HTML are either string literals or string variables, without nesting, and we get to use control-flow affordances like <code>if let</code> to deal with optionals cleanly, so we don't need to do the <code>!= nil</code> and <code>!</code> dance we did before.</p><p>From the Swift language perspective, this looks like a bunch of calls to functions <code>html</code>, <code>body</code>, <code>div</code>, <code>h1</code>, and <code>para</code>, where each of these calls takes a trailing closure. That is the entry point for result builders: the closures here have the <em>result builder transformation</em> applied to them, which turns this declarative code into values at runtime, which are then rendered into HTML. The core of my implementation is a simple protocol for a value that can be rendered into HTML:</p><pre><code><span class="keyword">protocol</span> HTMLElement {
  <span class="comment">/// Render this HTML element into a string using the given indentation level.</span>
  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span>
}
</code></pre><p>Strings can be rendered into HTML trivially, although a real implementation would properly escape HTML control characters like <code>&lt;</code> and <code>&gt;</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">String</span>: <span class="type">HTMLElement</span> {
	<span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> { <span class="keyword">self</span> }
}
</code></pre><p>More importantly, we can define a new HTML "tag" type that expresses the notion of wrapping an HTML element in a tag. The code itself is some straightforward string concatenations:</p><pre><code><span class="keyword">struct</span> HTMLTag: <span class="type">HTMLElement</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
  <span class="keyword">let</span> requiresNewline: <span class="type">Bool</span>
  <span class="keyword">let</span> element: any <span class="type">HTMLElement</span>

  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">let</span> indentString: <span class="type">String</span>
    <span class="keyword">if</span> requiresNewline {
      indentString = <span class="string">"\n"</span> + <span class="type">String</span>(repeating: <span class="string">" "</span>, count: indentation)
    } <span class="keyword">else</span> {
      indentString = <span class="string">""</span>
    }

    <span class="keyword">var</span> rendered = indentString
    rendered += <span class="string">"&lt;</span>\(name)<span class="string">&gt;"</span>
    rendered += element.<span class="call">renderHTML</span>(indentation: indentation + <span class="number">2</span>)
    rendered += indentString
    rendered += <span class="string">"&lt;/</span>\(name)<span class="string">&gt;"</span>
    <span class="keyword">return</span> rendered
  }
}
</code></pre><p>Note that the element can be <code>any HTMLElement</code>, so we can nest HTML tags within other tags. A <code>div</code> tag containing a <code>para</code> tag with some text in it can be represented as, e.g.,</p><pre><code><span class="type">HTMLTag</span>(
  name: <span class="string">"div"</span>, 
  requiresNewline: <span class="keyword">true</span>, 
  element: <span class="type">HTMLTag</span>(
    name: <span class="string">"para"</span>,
    requiresNewline: <span class="keyword">false</span>,
    element: <span class="string">""Call me Ishmael. Some years ago...""</span>
  )
)
</code></pre><p>We also need to be able to produce a sequence of HTML elements. The simplest way to do this is by making heterogeneous arrays of <code>HTMLElement</code> values into an <code>HTMLElement</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span>&lt;any <span class="type">HTMLElement</span>&gt;: <span class="type">HTMLElement</span> {
  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">switch</span> count {
    <span class="keyword">case</span> <span class="number">0</span>:
      <span class="keyword">return</span> <span class="string">""</span>

    <span class="keyword">case</span> <span class="number">1</span>:
      <span class="keyword">return self</span>[<span class="number">0</span>].<span class="call">renderHTML</span>(indentation: indentation)

    <span class="keyword">default</span>:
      <span class="keyword">let</span> indentString = <span class="string">"\n"</span> + <span class="type">String</span>(repeating: <span class="string">" "</span>, count: indentation)
      <span class="keyword">return</span> <span class="type">String</span>(<span class="call">flatMap</span> { element <span class="keyword">in</span>
          indentString + element.<span class="call">renderHTML</span>(indentation: indentation + <span class="number">1</span>)
        }
      )
    }
  }
}

</code></pre><p>We now have enough to be able to express a structured HTML document as an <code>any HTMLElement</code>, composing it from strings (the text), HTML tags wrapping other HTML elements, and arrays of HTML elements. But the syntax for building an HTML document this way tastes a bit like boiled plates. That's where result builders come in.</p><h3>Result builders for the HTML DSL</h3><p>Result builders take a closure and apply a syntactic transformation to each of the values in that closure, mapping syntax like <code>if/else</code> over to functions that capturing the resulting values. Let's step back to our goal for the DSL:</p><pre><code><span class="keyword">let</span> output = <span class="call">html</span> {
  <span class="call">body</span> {
    <span class="call">div</span> {
      <span class="keyword">if let</span> chapterTitle {
        <span class="call">h1</span> { chapterTitle }
      }
      <span class="call">para</span> { <span class="string">"Call me Ishmael. Some years ago..."</span> }
      <span class="call">para</span> { <span class="string">"There is now your insular city..."</span> }
    }
  }
}
</code></pre><p>Each of the tag names here---<code>html</code>, <code>body</code>, <code>div</code>, <code>h1</code>, and <code>para</code>---will be implemented by a function that takes a closure. The values produced by each closure form the HTML elements, that are aggregated together. That aggregation is performed by the static methods on a <em>result builder type</em>, which we are going to call <code>HTMLBuilder</code>. It looks like this:</p><pre><code><span class="keyword">@resultBuilder
struct</span> HTMLBuilder {
  <span class="keyword">static func</span> buildExpression(<span class="keyword">_</span> element: <span class="keyword">some</span> <span class="type">HTMLElement</span>) -&gt; any <span class="type">HTMLElement</span> {
    element
  }

  <span class="keyword">static func</span> buildBlock(<span class="keyword">_</span> elements: any <span class="type">HTMLElement</span>...) -&gt; any <span class="type">HTMLElement</span> {
    elements
  }

  <span class="keyword">static func</span> buildOptional(<span class="keyword">_</span> element: (any <span class="type">HTMLElement</span>)?) -&gt; any <span class="type">HTMLElement</span> {
    <span class="keyword">if let</span> element { [element] }
    <span class="keyword">else</span> { [] }
  }

  <span class="keyword">static func</span> buildEither(first: any <span class="type">HTMLElement</span>) -&gt; any <span class="type">HTMLElement</span> {
    first
  }

  <span class="keyword">static func</span> buildEither(second: any <span class="type">HTMLElement</span>) -&gt; any <span class="type">HTMLElement</span> {
    second
  }

  <span class="keyword">static func</span> buildArray(<span class="keyword">_</span> components: [any <span class="type">HTMLElement</span>]) -&gt; any <span class="type">HTMLElement</span> {
    components
  }
}
</code></pre><p>Note that each of the functions here takes in some <code>any HTMLElement</code> instances and produces an <code>any HTMLElement</code>. The so-called <em>result builder transform</em> produces calls to these static methods based on language syntax. If you read the earlier post in this series about <a href="../swift-for-cxx-practitioners-literals"><code>ExpressibleByStringInterpolation</code></a>, this approach of calling functions on a builder might look familiar. Here are how some of the calls get formed in the result builder transform:</p><ul><li><code>buildExpression</code> is called to transform a single value in a closure into something that can be combined into a block. For example, the string value <code>"Call me Ishmael. Some years ago..."</code> will be passed into it via</li></ul><pre><code>   <span class="type">HTMLBuilder</span>.<span class="call">buildExpression</span>(`<span class="string">"Call me Ishmael. Some years ago..."</span>`)
</code></pre><p>If <code>buildExpression</code> is not provided, Swift applies the identity function. Our <code>HTMLBuilder</code> example doesn't actually need it at all, because it's effectively just the identity function, but it's possible to do some translation of values here to get them into a common type.</p><ul><li><code>buildBlock</code> is called to gather all of the results together from a single statement block in the closure. For example, if a closure had two strings in it, e.g.,</li></ul><pre><code>   {
    <span class="string">"hello"
    "world"</span>
  }
</code></pre><p>Then <code>buildBlock</code> would be called as <code>HTMLBuilder.buildBlock("hello", "world")</code>.</p><ul><li><code>buildOptional</code> is called when there is an <code>if</code> statement that may or may not produce a value. For example, consider the chapter title:</li></ul><pre><code>   <span class="keyword">if let</span> chapterTitle {
    <span class="call">h1</span> { chapterTitle }
  }
</code></pre><p>Here, if <code>chapterTitle</code> was non-<code>nil</code>, we'll have an <code>h1</code> tag with the chapter title in it. Otherwise, nothing! The result builder transform maps this as a call to <code>buildOptional</code> with either the result of the <code>if</code> block, or a <code>nil</code>. Our <code>HTMLBuilder</code> chooses to handle this via an array containing either zero or one element.</p><ul><li><code>buildEither(first:)</code> and <code>buildEither(second:)</code> are used for <code>if</code> statements that also have an <code>else</code>. If the <code>if</code> evaluates true, <code>buildEither(first:)</code> ends up getting called with the value produced by the <code>if</code> block. If the <code>if</code> evaluates false, <code>buildEither(second:)</code> gets called with the value produced by the <code>else</code> block. Here's another made-up example:</li></ul><pre><code>   <span class="keyword">if let</span> dedication {
    <span class="call">para</span> { dedication }
  } <span class="keyword">else</span> {
    <span class="call">para</span> { <span class="string">"To all the world's children."</span> }
  }
</code></pre><p>This translates into, roughly,</p><pre><code>   dedication != <span class="keyword">nil</span> ? <span class="type">HTMLBuilder</span>.<span class="call">buildEither</span>(first: <span class="call">para</span> { dedication! })
                    : <span class="type">HTMLBuilder</span>.<span class="call">buildEither</span>(second: <span class="call">para</span> { <span class="string">"To all the world's children."</span> })
</code></pre><p>The actual implementation generalizes to arbitrary <code>if</code>-<code>else</code> chains (sometimes with a <code>buildOptional</code> at the end) and even arbitrary <code>switch</code> statements, which are themselves essentially just syntactic sugar for an <code>if</code>-<code>else</code> chain. <code>buildEither(first:)</code>, <code>buildEither(second:)</code>, and <code>buildOptional</code> are all optional: if a result builder omits them, it cannot be applied to closures that include <code>if</code> or <code>switch</code> statements.</p><ul><li><code>buildArray</code> is used to capture the results of a <code>for</code> loop, which are passed into <code>buildArray</code> as an array of captured values. Our original example is a bit too pre-baked, but we could imagine generating the chapters and their paragraphs in nested <code>for</code> loops:</li></ul><pre><code>   <span class="keyword">for</span> chapter <span class="keyword">in</span> chapters {
    <span class="call">div</span> {
      <span class="keyword">if let</span> chapterTitle = chapter.<span class="property">title</span> {
        <span class="call">h1</span> { chapterTitle }
      }
      
      <span class="keyword">for</span> paragraphText <span class="keyword">in</span> chapter.<span class="property">paragraphs</span> {
        <span class="call">para</span> { paragraphText }
      }
    }
  }
</code></pre><p>The inner <code>for</code> loop executes, collecting new <code>any HTMLElement</code> values for each iteration. Then, the resulting array is passed to <code>HTMLBuilder.buildArray</code>. That result becomes part of the <code>buildBlock</code> for the enclosing <code>for</code> loop's body, and each of those values gets collected into an array for the outermost call to <code>HTMLBuilder.buildArray</code>. Like with the previous operations, <code>buildArray</code> is optional: if not provided, the result builder cannot be applied to a closure containing <code>for</code> loops.</p><p>Going back to our original example, here is the "desugared" version after the result builder transform has been applied to each of the closures:</p><pre><code><span class="keyword">let</span> output = <span class="call">html</span> {
  <span class="keyword">let</span> a1 = <span class="call">body</span> {
    <span class="keyword">let</span> b1 = <span class="call">div</span> {
      <span class="keyword">let</span> c1_opt: (any <span class="type">HTMLElement</span>)?
      <span class="keyword">if let</span> chapterTitle {
        <span class="keyword">let</span> d1 = <span class="call">h1</span> { 
          <span class="keyword">let</span> e1 = <span class="type">HTMLBuilder</span>.<span class="call">buildExpression</span>(chapterTitle)
          <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(e1)
        }
        
        c1 = <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(d1)
      } <span class="keyword">else</span> {
        c1 = <span class="keyword">nil</span>
      }
      <span class="keyword">let</span> c1 = <span class="type">HTMLBuilder</span>.<span class="call">buildOptional</span>(c1_opt)
      
      <span class="keyword">let</span> c2 = <span class="call">para</span> { 
        <span class="keyword">let</span> f1 = <span class="type">HTMLBuilder</span>.<span class="call">buildExpression</span>(<span class="string">"Call me Ishmael. Some years ago..."</span>)
        <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(f1)
      }
      
      <span class="keyword">let</span> c3 = <span class="call">para</span> { 
        <span class="keyword">let</span> g1 = <span class="type">HTMLBuilder</span>.<span class="call">buildExpression</span>(<span class="string">"There is now your insular city..."</span>)
        <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(g1)
      }
      
      <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(c1, c2, c3)
    }
    <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(b1)
  }
  <span class="keyword">return</span> <span class="type">HTMLBuilder</span>.<span class="call">buildBlock</span>(a1)
}
</code></pre><p>We are <em>almost</em> done, but we still don't know what the tag functions look like, or how it is that Swift decides to apply the result builder transform. Here is the <code>body</code> function:</p><pre><code><span class="keyword">func</span> body(<span class="keyword">@HTMLBuilder</span> body: () -&gt; any <span class="type">HTMLElement</span>) -&gt; <span class="type">HTMLTag</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"body"</span>, requiresNewline: <span class="keyword">true</span>, body: body)
}
</code></pre><p>The <code>body</code> function takes a closure that has <code>@HTMLBuilder</code> attribute on it, meaning that the <code>HTMLBuilder</code> transform will be applied to a closure passed into <code>body</code>. Once <code>HTMLBuilder</code> has been applied, that closure will return <code>any HTMLElement</code>, and we wrap that resulting value in the <code>HTMLTag</code> structure. We're done! The other HTML elements look basically the same:</p><pre><code><span class="keyword">func</span> h1(<span class="keyword">@HTMLBuilder</span> body: () -&gt; any <span class="type">HTMLElement</span>) -&gt; <span class="type">HTMLTag</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"h1"</span>, requiresNewline: <span class="keyword">false</span>, body: body)
}

<span class="keyword">func</span> div(<span class="keyword">@HTMLBuilder</span> body: () -&gt; any <span class="type">HTMLElement</span>) -&gt; <span class="type">HTMLTag</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"div"</span>, requiresNewline: <span class="keyword">true</span>, body: body)
}

<span class="keyword">func</span> para(<span class="keyword">@HTMLBuilder</span> body: () -&gt; any <span class="type">HTMLElement</span>) -&gt; <span class="type">HTMLTag</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"para"</span>, requiresNewline: <span class="keyword">false</span>, body: body)
}
</code></pre><p>Only on the top-level <code>html</code> function do we do anything different, because here we render the produced <code>HTMLTag</code> to a string directly:</p><pre><code><span class="keyword">func</span> html(<span class="keyword">@HTMLBuilder</span> body: () -&gt; any <span class="type">HTMLElement</span>) -&gt; <span class="type">String</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"html"</span>, requiresNewline: <span class="keyword">true</span>, body: body).<span class="call">renderHTML</span>(indentation: <span class="number">0</span>)
}
</code></pre><h3>Strong typing for result builders</h3><p>If you read my <a href="../swift-for-cxx-practitioners-type-erasure/">earlier post on type erasure</a>, you might be a little bit worried about the number of <code>any HTMLElement</code> instances running around: it's all very dynamic, but does it have to be?</p><p>Short answer: <strong>no</strong>.</p><p>Long answer: the result builder transform is designed such that it's possible to retain the types of all of the elements, and even some of the control structures, within the type system. If you're thinking "expression templates", you're right! We're going to systematically remove the <code>any</code> types from our example above to produce a result builder that maintains the structure of the document in the static type system. Let's do this!</p><p>Let's start out easy: the <code>HTMLTag</code> type currently stores an <code>any HTMLElement</code>, but we can lift that into a generic parameter without changing much code at all:</p><pre><code><span class="keyword">struct</span> HTMLTag&lt;Element: <span class="type">HTMLElement</span>&gt;: <span class="type">HTMLElement</span> {
  <span class="keyword">let</span> name: <span class="type">String</span>
  <span class="keyword">let</span> requiresNewline: <span class="type">Bool</span>
  <span class="keyword">let</span> element: <span class="type">Element</span>

  <span class="keyword">init</span>(
    name: <span class="type">String</span>,
    requiresNewline: <span class="type">Bool</span>,
    <span class="keyword">@HTMLBuilder</span> body: () -&gt; <span class="type">Element</span>
  ) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
    <span class="keyword">self</span>.<span class="property">requiresNewline</span> = requiresNewline
    <span class="keyword">self</span>.<span class="property">element</span> = <span class="call">body</span>()
  }

  <span class="comment">// .. renderHTML(indentation:) stays the same</span>
}
</code></pre><p>Now that <code>HTMLTag</code> is generic, we can make those top-level functions like <code>body</code> and <code>div</code> generic. For example, <code>body</code> could look like this:</p><pre><code><span class="keyword">func</span> body&lt;Element: <span class="type">HTMLElement</span>&gt;(<span class="keyword">@HTMLBuilder</span> body: () -&gt; <span class="type">Element</span>) -&gt; <span class="type">HTMLTag</span>&lt;<span class="type">Element</span>&gt; {
  <span class="type">HTMLTag</span>(name: <span class="string">"body"</span>, requiresNewline: <span class="keyword">true</span>, body: body)
}

</code></pre><p>The real action is <code>HTMLBuilder</code>, where we have a lot of functions that return <code>any HTMLElement</code>. We'll take them one-by-one, starting with the easiest: <code>buildExpression</code> just returns what it got, so we can make it generic directly:</p><pre><code>   <span class="keyword">static func</span> buildExpression&lt;Element: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="type">Element</span>) -&gt; <span class="type">Element</span> {
    element
  }
</code></pre><p>Next, we'll tackle <code>buildOptional</code>, which is used for (e.g.) an <code>if</code> without an <code>else</code>. The type-erasing implementation from above turns an optional into an array of zero or one elements, which is <em>very</em> dynamic. We need something that takes an optional of some <code>HTMLElement</code> type, like this...</p><pre><code>   <span class="keyword">static func</span> buildOptional&lt;Element: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="type">Element</span>?) -&gt; ??? {
    ???
  }
</code></pre><p>But how can we fill in the result type and body? We need an <code>HTMLElement</code> that is optional (0 or 1) value, so why not use... <code>Optional</code> itself?</p><pre><code><span class="keyword">extension</span> <span class="type">Optional</span>: <span class="type">HTMLElement</span> <span class="keyword">where</span> <span class="type">Wrapped</span>: <span class="type">HTMLElement</span> {
  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">self</span>?.<span class="call">renderHTML</span>(indentation: indentation) ?? <span class="string">""</span>
  }
}
</code></pre><p>Now, an optional of some <code>HTMLElement</code>-conforming type is itself an <code>HTMLElement</code>, so our <code>buildOptional</code> can just be the identity function:</p><pre><code>    <span class="keyword">static func</span> buildOptional&lt;Element: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="type">Element</span>?) -&gt; <span class="type">Element</span>? {
     element
   }
</code></pre><p>As mentioned above, <code>buildEither</code> handles <code>if..else</code> statements, but is interesting because it comes as a pair of functions <code>buildEither(first:)</code> and <code>buildEither(second:)</code> that are called for the "if" value and "else" values, respectively. To capture both sides of the branch, we'll need some type that can represent either of two options. Alas, Swift's standard library doesn't have one just, so we'll define one ourselves as a generic enum <code>Either</code>:</p><pre><code><span class="keyword">enum</span> Either&lt;First, Second&gt; {
  <span class="keyword">case</span> first(<span class="type">First</span>)
  <span class="keyword">case</span> second(<span class="type">Second</span>)
}
</code></pre><p>and make it an <code>HTMLElement</code> when both sides are <code>HTMLElement</code>s:</p><pre><code><span class="keyword">extension</span> <span class="type">Either</span>: <span class="type">HTMLElement</span> <span class="keyword">where</span> <span class="type">First</span>: <span class="type">HTMLElement</span>, <span class="type">Second</span>: <span class="type">HTMLElement</span> {
  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="keyword">switch self</span> {
    <span class="keyword">case</span> .<span class="dotAccess">first</span>(<span class="keyword">let</span> element):
      element.<span class="call">renderHTML</span>(indentation: indentation)
    <span class="keyword">case</span> .<span class="dotAccess">second</span>(<span class="keyword">let</span> element):
      element.<span class="call">renderHTML</span>(indentation: indentation)
    }
  }  
}
</code></pre><p>With this, we can define the pair of <code>buildEither</code> overloads to return <code>Either</code>, like this:</p><pre><code>   <span class="keyword">static func</span> buildEither&lt;First: <span class="type">HTMLElement</span>, Second: <span class="type">HTMLElement</span>&gt;(first element: <span class="type">First</span>) -&gt; <span class="type">Either</span>&lt;<span class="type">First</span>, <span class="type">Second</span>&gt; {
    .<span class="call">first</span>(element)
  }

  <span class="keyword">static func</span> buildEither&lt;First: <span class="type">HTMLElement</span>, Second: <span class="type">HTMLElement</span>&gt;(second element: <span class="type">Second</span>) -&gt; <span class="type">Either</span>&lt;<span class="type">First</span>, <span class="type">Second</span>&gt; {
    .<span class="call">second</span>(element)
  }
</code></pre><p>Look at those functions individually, and they are kind of weird: both have <code>First</code> and <code>Second</code> types, yet only one of those types is mentioned as a type of a parameter. However, taken as a pair of calls, we can form a meaningful type. Imagine the following expression:</p><pre><code>condition ? <span class="call">buildEither</span>(first: x) : <span class="call">buildEither</span>(second: y)
</code></pre><p>That whole expression needs to have a single type, and a value of that type can be formed by either the <code>buildEither(first: x)</code> call or the <code>buildEither(second: x)</code> call. Therefore, the branch that calls <code>buildEither(first:)</code> will determine the <code>First</code> type from <code>x</code> (let's call it <code>X</code>) and the branch that calls <code>buildEither(second:)</code> will determine the <code>Second</code> type from <code>y</code> (let's call it <code>Y</code>), resulting in a result type <code>Either&lt;X, Y&gt;</code>.</p><p>On to <code>buildArray</code>, which currently takes an array of <code>any HTMLElement</code>, but that won't do: we want to have a concrete element type for the array. Fortunately, we can lift this to take an array of some <code>HTMLElement</code>-conforming type, making it the identity function just like <code>buildOptional</code>:</p><pre><code>   <span class="keyword">static func</span> buildArray&lt;Element: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> components: [<span class="type">Element</span>]) -&gt; [<span class="type">Element</span>] {
    components
  }

</code></pre><p>We do have to generalize the conformance of <code>Array</code> to <code>HTMLElement</code> by making it work for any <code>HTMLElement</code>-conforming <code>Element</code> type, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span>: <span class="type">HTMLElement</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">HTMLElement</span> {
  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="comment">// same as above</span>
  }
}
</code></pre><p>Only one function remains, <code>buildBlock</code>, but this one is tricky. Right now, it accepts any number of <code>any HTMLElement</code> arguments, which it treats as an array. Unlike with the <code>buildArray</code> function, each of the arguments can have a completely different type because it comes from a different statement in the transformed closure. In the post on <a href="../swift-for-cxx-practitioners-generics">generics</a>, I talked about parameter packs, which are a good match for this function:</p><pre><code><span class="keyword">static func</span> buildBlock&lt;each <span class="type">Element</span>: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="keyword">repeat</span> each <span class="type">Element</span>) -&gt; ??? {
    ???
 }
</code></pre><p>Now, <code>buildBlock</code> can accept any number of arguments, of different types, so long as every type conforms to <code>HTMLElement</code>. How do we turn that into a single instance that conforms to <code>HTMLElement</code>? Here's the best I came up with:</p><pre><code><span class="keyword">struct</span> ElementSequence&lt;each <span class="type">Element</span>: <span class="type">HTMLElement</span>&gt;: <span class="type">HTMLElement</span> {
  <span class="keyword">var</span> renderer: (<span class="type">Int</span>) -&gt; <span class="type">String</span>

  <span class="keyword">init</span>(<span class="keyword">_</span> element: <span class="keyword">repeat</span> each <span class="type">Element</span>) {
    <span class="keyword">switch</span> <span class="type">Self</span>.<span class="property">elementCount</span> {
    <span class="keyword">case</span> <span class="number">0</span>:
      renderer = { <span class="keyword">_ in</span> <span class="string">""</span> }

    <span class="keyword">case</span> <span class="number">1</span>:
      renderer = { indentation <span class="keyword">in
        for</span> element <span class="keyword">in repeat</span> each element {
          <span class="keyword">return</span> element.<span class="call">renderHTML</span>(indentation: indentation)
        }
        <span class="call">fatalError</span>(<span class="string">"must have returned from the loop"</span>)
      }
 
    <span class="keyword">default</span>:
      renderer = { indentation <span class="keyword">in
        var</span> finalString = <span class="string">""</span>
        <span class="keyword">let</span> indentString = <span class="string">"\n"</span> + <span class="type">String</span>(repeating: <span class="string">" "</span>, count: indentation)
        <span class="keyword">for</span> element <span class="keyword">in repeat</span> each element {
          finalString += indentString
          finalString += element.<span class="call">renderHTML</span>(indentation: indentation + <span class="number">1</span>)
        }
        <span class="keyword">return</span> finalString
      }
    }
  }

  <span class="keyword">func</span> renderHTML(indentation: <span class="type">Int</span>) -&gt; <span class="type">String</span> {
    <span class="call">renderer</span>(indentation)
  }

  <span class="keyword">private static var</span> elementCount: <span class="type">Int</span> {
    <span class="keyword">var</span> count = <span class="number">0</span>
    <span class="keyword">for _ in repeat</span> (each <span class="type">Element</span>).<span class="keyword">self</span> {
      count += <span class="number">1</span>
    }
    <span class="keyword">return</span> count
  }
}
</code></pre><p>Here, the <code>ElementSequence</code> struct takes any number of type arguments. There's a helper property <code>elementCount</code> that walks through all of the element types to count how many there are, so we can use it in the switch. The interesting bit is in the initializer: it takes all of the actual elements, but rather than store them directly, it stores a function that handles the rendering. The <code>default</code> case is the one that does most of the work: it iterates over each of the elements, rendering them into the resulting string in the same way that we did for arrays. The 0 and 1 cases are there to match what we did for arrays earlier, but are otherwise uninteresting.</p><p>The solution above works, and gives us our implementation of <code>buildBlock</code>:</p><pre><code>   <span class="keyword">static func</span> buildBlock&lt;each <span class="type">Element</span>: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="keyword">repeat</span> each <span class="type">Element</span>) -&gt; <span class="type">ElementSequence</span>&lt;<span class="keyword">repeat</span> each <span class="type">Element</span>&gt; {
    <span class="type">ElementSequence</span>(repeat each element)
  }
</code></pre><p>I suspect there's a better implementation of <code>ElementSequence</code>. If you find one, please tell me! For now, let's step back to what we've done here: we've eliminated every use of <code>any</code> types, so we have complete static type information. We can see this if we intentionally trigger a compile-time error that will print the type, e.g.,:</p><pre><code><span class="keyword">let _</span>: <span class="type">Int</span> = <span class="call">body</span> {
    <span class="keyword">if let</span> chapterTitle {
      <span class="call">h1</span> {
        chapterTitle
      }
    }

    <span class="call">para</span> {
      <span class="string">"Call me Ishmael. Some years ago..."</span>
    }

    <span class="call">para</span> {
      <span class="string">"There is now your insular city"</span>
    }
  }
</code></pre><p>The resulting error message contains the full type in all of its static, expression-template-y glory:</p><pre><code><span class="type">HTMLTag</span>&lt;
  <span class="type">ElementSequence</span>&lt;
    <span class="type">ElementSequence</span>&lt;
      <span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">String</span>&gt;&gt;
    &gt;?, 
    <span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">String</span>&gt;&gt;, 
    <span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">String</span>&gt;&gt;
  &gt;
&gt;
</code></pre><h2>Hiding the types</h2><p>Now that we've proven to ourselves that we can maintain complete static type information throughout the entirety of the result-builder transform, we can have to ask ourselves: is it everything we ever wanted? On the one hand, this approach is a whole lot more optimizable than the one using <code>any</code> types, because enough generic specialization and inlining can completely eliminate all of the abstractions here. On the other hand, that is quite the monster of a type for such a simple example DSL: is it worth inflicing such types on the users of our DSL and leaking them out of the implementation?</p><p>This is where <code>some</code> types come in: technically called opaque types, and covered in the earlier post on <a href="../swift-for-cxx-practitioners-type-erasure">type erasure</a>, opaque types let you hide the actual types you are returning from a generic function without losing identity. The idea is that the types still exist, but they aren't exposed directly to the user. We can replace the result types of some of our functions with <code>some HTMLElement</code>, meaning "some specific type that conforms to <code>HTMLElement</code>", without changing much other code. For example, <code>buildBlock</code> can be written as follows:</p><pre><code>   <span class="keyword">static func</span> buildBlock&lt;each <span class="type">Element</span>: <span class="type">HTMLElement</span>&gt;(<span class="keyword">_</span> element: <span class="keyword">repeat</span> each <span class="type">Element</span>) -&gt; <span class="keyword">some</span> <span class="type">HTMLElement</span> {
    <span class="keyword">return</span> <span class="type">ElementSequence</span>(repeat each element)
  }
</code></pre><p>This lets us hide the <code>ElementSequence</code> type entirely: it could be <code>private</code> to this file, and therefore not visible to clients. The same could be done for all of the top-level functions like <code>body</code> and <code>h1</code>, which can return <code>some HTMLElement</code> rather than exposing their full return type:</p><pre><code><span class="keyword">func</span> body(<span class="keyword">@HTMLBuilder</span> body: () -&gt; <span class="keyword">some</span> <span class="type">HTMLElement</span>) -&gt; <span class="keyword">some</span> <span class="type">HTMLElement</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"body"</span>, requiresNewline: <span class="keyword">true</span>, body: body)
}

<span class="keyword">func</span> h1(<span class="keyword">@HTMLBuilder</span> body: () -&gt; <span class="keyword">some</span> <span class="type">HTMLElement</span>) -&gt; <span class="keyword">some</span> <span class="type">HTMLElement</span> {
  <span class="type">HTMLTag</span>(name: <span class="string">"h1"</span>, requiresNewline: <span class="keyword">false</span>, body: body)
}
</code></pre><p>Now, the <code>HTMLTag</code> type has become an implementation detail, and need not be exposed to users. Later versions of the library could choose to express it in some different way without breaking clients, because clients just see <code>some HTMLElement</code> for the types of these calls.</p><p>Note that the types still <em>exist</em>, and can be queried at runtime if they are needed. For example, we can capture the call to <code>body</code> in a variable and print its type with <code>type(of:)</code>, like this:</p><pre><code><span class="keyword">let</span> b = <span class="call">body</span> {
    <span class="keyword">if let</span> chapterTitle {
      <span class="call">h1</span> {
        chapterTitle
      }
    }

    <span class="call">para</span> {
      <span class="string">"Call me Ishmael. Some years ago..."</span>
    }

    <span class="call">para</span> {
      <span class="string">"There is now your insular city"</span>
    }
  }
<span class="call">print</span>(<span class="call">type</span>(of: b))
</code></pre><p>and we'll get a printed representation of the full structure of the type like this:</p><pre><code><span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">Pack</span>{<span class="type">Optional</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">Pack</span>{<span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">Pack</span>{<span class="type">String</span>}&gt;&gt;}&gt;&gt;, <span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">Pack</span>{<span class="type">String</span>}&gt;&gt;, <span class="type">HTMLTag</span>&lt;<span class="type">ElementSequence</span>&lt;<span class="type">Pack</span>{<span class="type">String</span>}&gt;&gt;}&gt;&gt;
</code></pre><p>Opaque types provide a balance between the benefits of maintaining DSL structure in the type system (more type checking, better specialization) and putting structure behind an abstraction barrier (for conciseness and implementation-hiding).</p><h2>Other uses of result builders</h2><p>We've gone really deep on rendering HTML, something that could perhaps be considered a trivial example. However, it turns out to be really nice in practice, as you can see from Paul Hudson's static site generator <a href="https://github.com/twostraws/Ignite">Ignite</a>. Result builders are also in use in a number of other DSLs. Here are some examples:</p><ul><li><strong>Regular expressions</strong>: Swift supports regular expressions with a syntax that uses surrounding slashes, e.g., <code>/[$£]\d+\.\d{2}/</code>. However, for more complicated regular expressions, there is also a <code>RegexBuilder</code> DSL that uses result builders. Here is the equivalent in that DSL:</li></ul><pre><code>   <span class="type">Regex</span> {
    <span class="type">One</span>(<span class="type">CharacterClass</span>.<span class="call">anyOf</span>(<span class="string">"$£"</span>))
    <span class="type">OneOrMore</span>(.<span class="dotAccess">digit</span>)
    <span class="string">"."</span>
    <span class="type">Repeat</span>(count: <span class="number">2</span>) {
      <span class="type">One</span>(.<span class="dotAccess">digit</span>)
    }
  }
</code></pre><ul><li><strong>Declarative UI</strong>: Perhaps the most well-known use of result builders is the SwiftUI library for declarative UI, which uses result builders. For example:</li></ul><pre><code>   <span class="type">List</span>(album.<span class="property">songs</span>) { song <span class="keyword">in</span> 
    <span class="type">HStack</span> {
      <span class="type">Image</span>(album.<span class="property">cover</span>)
      <span class="type">VStack</span>(alignment: .<span class="dotAccess">leading</span>) {
        <span class="type">Text</span>(song.<span class="property">title</span>)
        <span class="type">Text</span>(song.<span class="property">artist</span>.<span class="property">name</span>)
          .<span class="call">foregroundStyle</span>(.<span class="dotAccess">secondary</span>)
      }
    }
  }
</code></pre><ul><li><strong>Routing</strong>: the <a href="https://swiftpackageindex.com/hummingbird-project/hummingbird">Hummingbird</a> package uses result builders to express routing for services:</li></ul><pre><code>   <span class="keyword">let</span> router = <span class="type">RouterBuilder</span>(context: <span class="type">BasicRouterRequestContext</span>.<span class="keyword">self</span>) {
      <span class="type">TracingMiddleware</span>()
      <span class="type">Get</span>(<span class="string">"test"</span>) { <span class="keyword">_</span>, context <span class="keyword">in
          return</span> context.<span class="property">endpointPath</span>
      }
      <span class="type">Get</span> { <span class="keyword">_</span>, context <span class="keyword">in
          return</span> context.<span class="property">endpointPath</span>
      }
      <span class="type">Post</span>(<span class="string">"/test2"</span>) { <span class="keyword">_</span>, context <span class="keyword">in
          return</span> context.<span class="property">endpointPath</span>
      }
  }
</code></pre><h2>Wrap-up and what's next?</h2><p>Result builders are a big heap of syntactic sugar designed specifically to make it possible to build elegant, type-safe Domain Specific Languages embedded in Swift. They provide a declarative syntax that can be transformed in a manner that can describe the structure of the input in the type system, or collapse it down when that's not necessary, giving expressive power to the author of the result builder.</p><p>This post has drifted somewhat from the focus on teaching Swift to C++ programmers, so next I'll bring it back and we'll talk about C++ move semantics and the Swift analogue: noncopyable types.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>