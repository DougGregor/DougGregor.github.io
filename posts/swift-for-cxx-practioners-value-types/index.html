<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug Gregor's Personal Site"/><link rel="canonical" href="https://douggregor.net/posts/swift-for-cxx-practioners-value-types"/><meta name="twitter:url" content="https://douggregor.net/posts/swift-for-cxx-practioners-value-types"/><meta property="og:url" content="https://douggregor.net/posts/swift-for-cxx-practioners-value-types"/><title>Swift for C++ Practitioners, Part 1: Value Types | Doug Gregor's Personal Site</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 1: Value Types | Doug Gregor's Personal Site"/><meta property="og:title" content="Swift for C++ Practitioners, Part 1: Value Types | Doug Gregor's Personal Site"/><meta name="description" content="Swift for C++ Practitioners, Part 1: Value Types"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 1: Value Types"/><meta property="og:description" content="Swift for C++ Practitioners, Part 1: Value Types"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug Gregor's Personal Site"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug Gregor's Personal Site</a></div></header><div class="wrapper"><article><div class="content"><h1>Swift for C++ Practitioners, Part 1: Value Types</h1><p>There is a <a href="https://www.swift.org/getting-started/">Getting Started</a> guide for Swift that's meant for a general audience. However, I've noticed that folks coming to Swift from C++ tend to be surprised at certain aspects of Swift. I want to take a different approach aimed at C++ practitioners who write C++ day-to-day and have an understanding of not only the C++ language, but it's standard library and best practices. For you, dear C++ practitioner, I want to teach Swift by mapping from the ideas and mental model of C++ into the nearest equivalent constructs in Swift.</p><p>As a C++ programmer, some parts of Swift will be obviously awesome, like separately type-checked generics and value types that compose beautifully, and we'll revel in those. We'll show how some of the aspects of C++ that we've come to view as problematic, such as wrong defaults or avoidable foot guns, are addressed by Swift's design. Other parts of Swift will grate against the sensibilities of a C++ practitioner, and we won't shy away from those, either. Instead, we'll explain what is different, why Swift is designed that way, and how to cope.</p><blockquote><p><em>Note:</em> You may have heard about <a href="https://www.swift.org/documentation/cxx-interop/">Swift's interoperability with C++</a>. It's a fantastic tool for incrementally moving a C++ code base toward Swift or wrapping up a C++ library in a nicer Swift interface. However, it's the wrong place to start if you know C++ already and want to learn Swift. Instead, I recommend building something purely in Swift first, to get the feel for Swift without the "pull" of existing C++ code toward more C++-centric patterns. You'll be able to integrate Swift better into your existing code bases once you have a solid understanding of both languages.</p></blockquote><p>This is a multi-part series that will walk through the various features of Swift. We'll start with "Hello, world" and then dive straight into <em>value types</em>.</p><h3>Hello, World!</h3><p>Okay, let's get this over with: this is "Hello, World" in Swift:</p><pre><code><span class="call">print</span>(<span class="string">"Hello, world!"</span>)
</code></pre><p>But it's more important to greet you, dear C++ practictioner, so let's customize it a little bit:</p><pre><code><span class="keyword">let</span> reader = <span class="string">"dear C++ practitioner"</span>
<span class="call">print</span>(<span class="string">"""
      Hello,</span> \(reader)<span class="string">!
      
      Today, we shall embark on learning a new programming language, Swift.
      """</span>)
</code></pre><p>The <code>let</code> is how we declare an immutable variable, like <code>const</code> in C++, but with stronger guarantees: we'll get to that later. We've omitted the type because Swift does type inference in a manner that's similar to <code>auto</code> in C++, but we could have written the type explicitly with <code>let reader: String</code>. The triple-quotes describe a <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals">multi-line string literal</a>, and the <code>\(...)</code> syntax within it is <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation">string interpolation</a>, a feature common in scripting languages that makes it easy to plug values into the middle of a string.</p><h2>Value types</h2><p>C++ provides rich support for <em>value types</em>, i.e., types for which each copy is completely independent of the original. Let's take a simple example with C++ vectors:</p><pre><code>std::vector&lt;std::string&gt; v1 = { <span class="string">"Hello"</span>, <span class="string">"original"</span> };
std::vector&lt;std::string&gt; v2 = v1;
v2[<span class="number">1</span>] = <span class="string">"copy"</span>;
</code></pre><p>Here, <code>v1</code> is a vector containing <code>"Hello"</code> and <code>"original"</code>. When we make a copy <code>v2</code>, that copy is completely independent of the original: the change to <code>v2</code> on the last line, so that it contains <code>"Hello"</code> and <code>"copy"</code> , doesn't modify the original <code>v1</code>.</p><p>Many C++ types are value types, from builtin types like integers and floating-point types to standard library containers like <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>. C++ lets you build your own value types by letting you control how a class type is created, copied, and destroyed, so long as you follow the <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">Rule of Three/Five/Zero</a>.</p><p>Swift also emphasizes value types because they aid <em>local reasoning</em>, which is the ability to look at code in isolation and reason about what it does, and whether it does so correctly. When you make copy a instance of a value type, you don't need to worry that something you do will affect the original. As in C++, many Swift types are value types, including <code>String</code>, <code>Array</code>, and <code>Dictionary</code>, which are analogous to <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>:</p><pre><code><span class="keyword">let</span> v1: [<span class="type">String</span>] = [<span class="string">"Hello"</span>, <span class="string">"original"</span>] <span class="comment">// [String] is an array type, can also be spelled Array&lt;String&gt;</span>
<span class="keyword">var</span> v2 = v1 <span class="comment">// inferred to also have type [String]</span>
v2[<span class="number">1</span>] = <span class="string">"copy"</span>
<span class="call">print</span>(v1) <span class="comment">// prints ["Hello", "original"]</span>
<span class="call">print</span>(v2) <span class="comment">// prints ["Hello", "copy"]</span>
</code></pre><p>Here we've introduced the <code>var</code> keyword: <code>var</code> introduces variables that can be modified (i.e., they are mutable), whereas <code>let</code> introduces variables that cannot be modified (they are immutable). In Swift, we prefer that you use <code>let</code> wherever you can, because immutability aids local reasoning: it's easier to reason about something if it isn't changing.</p><h3>Aggregating values in structs</h3><p>As in C++, Swift has structs to aggregate data together. While in C++ the difference between <code>struct</code> and <code>class</code> is almost cosmetic (it onlly impacts whether the defaults are <code>public</code> vs. <code>private</code>), in Swift they are completely different animals. A Swift <code>struct</code> is generally a value type, whereas a Swift <code>class</code> is an class in the Object-Oriented sense of the word, and has <em>reference semantics</em>: copies still refer to the same underlying instance. We'll get back to classes later, because <code>struct</code>s are one way we build value types out of other value types:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
}
</code></pre><p>Structs containing other value types are themselves value types. For example, let's use that labeled point:</p><pre><code><span class="keyword">let</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
<span class="keyword">var</span> p2 = p1
p2.<span class="property">label</span> = <span class="string">"center"</span>

<span class="call">print</span>(p1) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "origin")</span>
<span class="call">print</span>(p2) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "center")</span>
</code></pre><p>That first line is creating a new instance of a <code>LabeledPoint</code>, calling an <em>initializer</em> (that's what Swift calls constructors) to produce the new value from the component parts. The result is on the stack, not the heap, just like you'd expect in C++. Copying the <code>p1</code> value into <code>p2</code> produces a completely separate value, just as you'd expect from the corresponding C++ code.</p><blockquote><p><strong>Labeled arguments</strong>: When creating the new <code>LabeledPoint</code> instance, notice that each of the arguments requires a label, e.g., <code>x:</code>, <code>y:</code>, and <code>label:</code>. By default, all function arguments must be labeled at the call site, which communicates information about what the function will be doing with the corresponding argument, aiding readability. This is particularly useful when combined with default arguments. The function can opt out of having a particular argument labeled, of course, and we'll get back to that later.</p></blockquote><h3>Initialization always goes through initializers</h3><p>C++ has a couple of different ways to initialize an instance of a <code>struct</code>, including constructor calls, initializer lists, default initialization, and copy initialization. Swift settles on one: calling an initializer. Initializers are responsible for initializing all of the fields of the struct before they return (no excuses). The creation of the <code>LabeledPoint</code> in the previous section is using the <em>memberwise</em> initializer that Swift provides automatically for structs, which initializes the fields in order from the corresponding parameters. We could go ahead and write out this initializer directly if we wanted to, like this:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
  
  <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">x</span> = x
    <span class="keyword">self</span>.<span class="property">y</span> = y
    <span class="keyword">self</span>.<span class="property">label</span> = label
  }
}
</code></pre><p>The <code>init</code> keyword is what defines an initializer, and is the equivalent of the repeating the class name in C++ to define a constructor, but usually less verbose. <code>self</code> is the Swift equivalent to <code>this</code>, but think of it as being a like a C++ reference (<code>ClassName&amp;</code>) rather than a pointer like it would be in C++ (<code>ClassName*</code>).</p><p>There is no special syntax for initializing the fields in a <code>struct</code>, like there is in C++. Instead, it's just normal assignments to the fields, and the compiler checks that (1) you don't read a field before it's been assigned, and (2) all fields have been assigned before <code>self</code> is referenced as a whole object, including the function return. So let's try out a semantic disaster of an initializer that breaks both rules:</p><pre><code><span class="comment">// in LabeledPoint ...</span>
<span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
  <span class="keyword">self</span>.<span class="property">y</span> = <span class="keyword">self</span>.<span class="property">x</span>   <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  <span class="keyword">self</span>.<span class="property">x</span> = x
  <span class="keyword">if</span> <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>..&lt;<span class="number">2</span>) == <span class="number">1</span> {
    <span class="call">print</span>(<span class="keyword">self</span>) <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  }
} <span class="comment">//  error: return from initializer without initializing all stored properties</span>
</code></pre><p>Uses of uninitialized variables don't happen in Swift, because of a property called <em>definite initialization</em>: the compiler checks that every variable is initialized before it is used, in all execution paths. This applies equally to all code, and it helps define away a class of bugs that bite us in C++:</p><pre><code><span class="keyword">let</span> p: <span class="type">LabeledPoint</span>
<span class="keyword">if</span> y &gt; <span class="number">0</span> {
  p = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
<span class="call">print</span>(p) <span class="comment">// error: constant 'p' used before being initialized</span>
</code></pre><p>Because of definite initialization, Swift has no notion of a default constructor the way C++ does. The variable <code>p</code> <em>is not initialized</em> on the line where it is defined, the way a C++ class with a non-trivial default constructor would be. Rather, you assign to it, and the first assignment is an initialization.</p><p>You could write an initializer that takes no arguments, and perhaps that makes sense for points to (say) create the origin point, but Swift will never automatically call it: you'll always call it explicitly. Let's write that out so we can demonstrate the Swift equivalent to C++ <a href="https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170">delegating constructors</a>:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>() {
  <span class="keyword">self</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
</code></pre><p>The call to <code>self.init</code> delegates the responsibility for initializing all of the fields of <code>self</code> to another initializer. The rules of definite initialization kick in here, too: you can't use (or initialize) any of the fields of <code>self</code> before the <code>self.init</code> call, and after that call <code>self</code> is fully initialized.</p><h3>Where's my copy constructor?</h3><p>By now, you've probably noted that we could write an initializer that looks very much like a copy constructor:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">self</span>.<span class="property">x</span> = other.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">y</span> = other.<span class="property">y</span>
  <span class="keyword">self</span>.<span class="property">label</span> = other.<span class="property">label</span>
}
</code></pre><p>The <code>_</code> in the declaration of <code>other</code> is a placeholder for "not named", and here it means that the argument to this initializer is not named. Therefore, we can call this initializer with the syntax <code>LabeledPoint(other)</code>, just like one would in C++. However, Swift will never <em>implicitly</em> call an initializer like this, because it's not special in any way.</p><p>Swift will copy, move, and destroy instances of structs by performing those operations directly on each instance property of the <code>struct</code>. In essence, a Swift <code>struct</code> always follows the C++ <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">rule of zero</a>, where one relies on the default implementations of all of the special constructors, assignment operators, and destructor. In practice, this means that it's not possible to observe when Swift is making copies of value types, so the compiler is free to make copies that are necessary for implementing the semantics of the program, and optimize away copies (or turn them into implicit moves) when they are no longer needed.</p><p>For a type that needs hold on to resources, Swift has classes, which are a subject of a later section, as well as newer "noncopyable" types. For now, let's dive deeper into value types.</p><h3>Immutability runs deep with value types</h3><p>Earlier, we introduced <code>let</code> as a way to create immutable local variables. With value types, immutability is the default. Parameters are immutable unless otherwise specified, which also includes <code>self</code>:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">func</span> badSwapX(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>  <span class="comment">// error: 'other' parameter is immutable</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX     <span class="comment">// error: 'self' parameter is immutable</span>
}
</code></pre><p>One can create methods that mutate <code>self</code> by putting the <code>mutating</code> modifier before the <code>func</code> keyword. Let's start with a sensible example:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> reflectOverXAxis() {
  y = -y
}
</code></pre><p>For other parameters, one can place <code>inout</code> on the parameter to indicate that it is meant to be modified by the function. Formally, <code>mutating</code> on the function is equivalant to <code>inout</code> on the <code>self</code> parameter, but Swift uses <code>mutating</code> because it reads better. With <code>inout</code> parameters and <code>mutating</code> methods, we can write a working version of the <code>badSwapX</code> method:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> swapX(<span class="keyword">_</span> other: <span class="keyword">inout</span> <span class="type">LabeledPoint</span>) {
   <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX
}
</code></pre><p>When calling a function with an <code>inout</code> argument, the argument must be prefixed with <code>&amp;</code> to indicate that we're passing it's (logical) address to the function. For example, here's a call to <code>swapX</code>:</p><pre><code><span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
p1.<span class="call">swapX</span>(&amp;p2)
</code></pre><p>If the value we are trying to apply <code>&amp;</code> to is immutable, the Swift compiler would produce an error. Note that there is no prefix <code>&amp;</code> on <code>p1</code>, even though it's calling a <code>mutable</code> method: it's not needed because the name of the method should <a href="https://www.swift.org/documentation/api-design-guidelines/">clearly imply the mutation</a>. Of course, if <code>p1</code> were immutable, it would still be an error.</p><p>There are two more important things to say about immutability before we move on to our next kind of value type, <code>enum</code>.</p><p>First, you <em>cannot cheat immutability</em> any more than you can cheat Death. There is no equivalent to the C++ <code>const_cast</code> in Swift. There are no <code>mutable</code> members in Swift; even a <code>var</code> member of a struct can only be modified on a <code>var</code> instance of that struct. There are no <code>const T&amp;</code> parameters whose values can change out from underneath you: an immutable value is truly immutable, and the compiler makes sure that no matter how an immutable parameter is actually passed (by-value or by-reference), the underlying value won't change. This can be frustrating, because you've given up control about when to pass by-value, pass by <code>const</code> reference, or pass by rvalue reference to do a move. On the other hand, it is liberating: there's no spooky-action-at-a-distance when that <code>const&amp;</code> actually <em>does</em> change underneath you, and you can lean on immutability to make it easier to reason about your code.</p><p>That brings us to the second point: <em>there is no aliasing of inout parameters</em>. Aliasing, as I mean it here, is when two different pass-by-reference parameters actually refer to the same underlying instance. If you've ever had to go add an <code>if (this == &amp;other) { ... }</code> check into your copy or move assignment operator in C++, you know just how vicious unexpected aliasing of parameters can be for program semantics. In Swift, we have the <a href="https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity">law of exclusivity</a>, which prevents any such aliasing.</p><h3>Memory safety and the law of exclusivity</h3><h3>Enums: the <code>std::variant</code> you've always wanted</h3></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>