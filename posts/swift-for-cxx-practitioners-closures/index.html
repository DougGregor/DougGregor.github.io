<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><title>Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta property="og:description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-04-27 18:09:00 +0000</p><p>Last updated on 2024-06-15 05:10:50 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 7: Closures</h1><p>Throughout this series, I've been using closures in examples without really defining them. Swift closures are a whole lot like C++ lambdas, with a similar design and syntax, and generally the same use cases. This post is going to dig a little deeper into Swift closures to give a better feel for how they work and how to make the best use of them.</p><h2>The syntax</h2><p>A Swift closure is an expression delimited by curly braces, <code>{ ... }</code> that represents an anonymous function. For example, this</p><pre><code><span class="keyword">let</span> hello = { <span class="string">"Hello"</span> }
</code></pre><p>defines a local variable <code>hello</code> that stores the closure. The type of <code>hello</code> is <code>() -&gt; String</code>, i.e., a function that takes no parameters.</p><p>Swift closures can be provided with parameters in one of two ways: anonymous parameters <code>$0</code>, <code>$1</code>, <code>$2</code>, and so on let you write very short closures for quick one-off operations. For example:</p><pre><code><span class="keyword">let</span> arithmeticOp: (<span class="type">Double</span>, <span class="type">Double</span>) -&gt; <span class="type">Double</span>
<span class="keyword">switch</span> opCode {
<span class="keyword">case</span> <span class="string">"+"</span>: arithmeticOp = { $0 + $1 }
<span class="keyword">case</span> <span class="string">"-"</span>: arithmeticOp = { $0 - $1 }
<span class="keyword">case</span> <span class="string">"*"</span>: arithmeticOp = { $0 * $1 }
<span class="keyword">case</span> <span class="string">"/"</span>: arithmeticOp = { $0 / $1 }
<span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">InterpreterError</span>.<span class="call">invalidOpcode</span>(opCode)
}
</code></pre><p><em>Please</em> only use this shorthand for the smallest closures. Once you get behind a single short expression, it's much better to name your parameters. To do so, list them prior to <code>in</code> within the curly braces. The <code>in</code> separates the declaration part of the closure from its statements. For example, the first case above could instead by written like this:</p><pre><code>{ x, y <span class="keyword">in</span> x + y }
</code></pre><p>In fact, prior to the <code>in</code>, you can write a full-fledged parameter list with type annotations, result type, and effect specifiers, if you don't want to leave them up to inference:</p><pre><code>{ (x: <span class="type">Double</span>, y: <span class="type">Double</span>) <span class="keyword">throws</span> -&gt; <span class="type">Double</span> <span class="keyword">in 
     let</span> result = <span class="keyword">try</span> <span class="call">addSafely</span>(x, y) }
     <span class="keyword">return</span> result
}
</code></pre><p>It's fairly uncommon to see such closures with all of the types written out like this, because the parameter types are generally inferred by context and the result type can be inferred from the closure body. Indeed, if you end up finding yourself writing a long closure that needs the full type annotations, it's likely that you should write a local function. I'll come back to local functions later. For now, I want to talk about captures.</p><h2>Captures</h2><p>A <em>capture</em> is when a closure refers to a local variable (or parameter) from its enclosing scope. In such cases, the closure needs to a way to reference that variable---or it's value---when it executes. A simple example would be a closure that inserts elements into a set to remove duplicates from a collection, returning a new array with the elements uniqued:</p><pre><code><span class="keyword">func</span> uniquing&lt;C: <span class="type">Collection</span>&gt;(from collection: <span class="type">C</span>) -&gt; [<span class="type">C</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span>: <span class="type">Hashable</span> {
  <span class="keyword">var</span> known: <span class="type">Set</span>&lt;<span class="type">C</span>.<span class="type">Element</span>&gt; = []
  <span class="keyword">return</span> collection.<span class="call">filter</span>({
    known.<span class="call">insert</span>($0).<span class="property">inserted</span>
  })
}
</code></pre><p>The closure passed to <code>filter</code> captures the local variable <code>known</code>. Each time it is called, it tries inserting the element it was given into the known set. If successful (i.e., the element wasn't there), the <code>inserted</code> field in the result is <code>true</code>, so the element is kept in the filtered sequence. If the element wasn't there, the <code>inserted</code> field in the result is <code>false</code>, so it's dropped.</p><p>Swift's captures default to by-reference. If you want a by-value capture rather than a by-reference capture, you can provide a capture list using the familiar square bracket syntax from C++ lambdas. However, in Swift the capture list goes <em>within</em> the curly braces and before the (optional) parameter list. The <code>filter</code> call could capture <code>known</code> by-value like this:</p><pre><code>   <span class="keyword">return</span> collection.<span class="call">filter</span>({ [known] <span class="keyword">in</span>
    known.<span class="call">insert</span>($0).<span class="property">inserted</span>        <span class="comment">// error: known is immutable</span>
  })
</code></pre><p>However, note the error: by-value captures are immutable, so the above code would actually fail with an error <code>cannot assign to value: 'count' is an immutable capture</code>.</p><p>Also similar to C++ captures, a Swift capture list can define a new captured values at the point the closures is created. For example, here we create a bunch of closures that produce string values of the index in the loop where they were created:</p><pre><code><span class="keyword">var</span> closures: [() -&gt; <span class="type">String</span>] = []
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100</span> {
  closures.<span class="call">append</span>({ [string = <span class="type">String</span>(i)] <span class="keyword">in</span> string })
}
</code></pre><p>I wouldn't expect most of the above to be surprising to a C++ practitioner, because it's mostly the same as lambdas. But the "captures are by reference" statement might be a little nerve-wracking, because what happens if you return a closure that captures by reference?</p><pre><code><span class="comment">// Produce a function that adds `x` to whatever integer value it is given.</span>
<span class="keyword">func</span> adding(x: <span class="type">Int</span>) -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) {
  <span class="keyword">return</span> { x + $0 }
}
</code></pre><p>Bad news, right? Not in Swift... let's look into the implementation model a bit.</p><h3>Implementation model for captures</h3><p>The implementation of C++ lambdas is fairly straightforward: for each lambda, the compiler synthesizes a class. The code of the lambda goes into its <code>operator()</code>, and for each capture the compiler will create a non-static data member. For example, let's consider this C++ lambda expression:</p><pre><code>std::vector&lt;int&gt; values;
int target;

auto fn = [&amp;values,target]() {
  values[<span class="number">0</span>] = target;
};
</code></pre><p>The corresponding synthesized class will look something like this:</p><pre><code><span class="keyword">class</span> Synthesized {
  std::vector&lt;int&gt; &amp;values;
  int target;
  
public:
  <span class="type">Synthesized</span>(std::vector&lt;int&gt; &amp;values, int target) : <span class="call">values</span>(values), <span class="call">target</span>(target) { }

  void <span class="call">operator</span>()() <span class="call">const</span> {
    values[<span class="number">0</span>] = target;
  }
};
</code></pre><p>By-reference captures produce a non-static member of reference type, while by-value captures are of non-reference type (so you get a copy).</p><p>Swift's translation of closures is conceptually similar, but the main difference is in the handling of by-reference captures. Semantically, a by-reference capture in Swift promotes the captured local to the heap, and uses a reference type to box it up. For example, imagine we have this <code>Box</code> type:</p><pre><code><span class="keyword">class</span> Box&lt;T&gt; {
  <span class="keyword">var</span> value: <span class="type">T</span>
  
  <span class="keyword">init</span>(value: <span class="type">T</span>) {
    <span class="keyword">self</span>.<span class="property">value</span> = value
  }
}
</code></pre><p>When a local variable like</p><pre><code><span class="keyword">var</span> numbers: [<span class="type">Int</span>]
</code></pre><p>is captured by-reference in a closure, it is <em>as if</em> the local variable were rewritten to</p><pre><code><span class="keyword">var</span> numbers: <span class="type">Box</span>&lt;[<span class="type">Int</span>]&gt;
</code></pre><p>and every initialization of <code>numbers</code> creates a box instance, and every subsequent access to <code>numbers</code>, whether it's in the function or a closure that captures it by reference, is rewritten to <code>numbers.value</code>.</p><p>This model makes it safe to return a closure from a function, even when that closure captures a local in the function by reference:</p><pre><code><span class="keyword">func</span> numberAccessor() -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) {
  <span class="keyword">var</span> numbers: [<span class="type">Int</span>] = ...
  <span class="keyword">return</span> { x <span class="keyword">in</span> numbers[x] }
}
</code></pre><p>Since <code>numbers</code> is promoted to a <code>Box&lt;[Int]&gt;</code>, the returned closure itself keeps the "local" variable alive on the heap until the closure is no longer used. It's a simple model, and a safe one.</p><p>But if you actually did this for every local variable captured everywhere, it would be a very, very slow model. Let's talk about optimizations.</p><h3>Optimizations for captures</h3><p>There are two main optimizations for by-reference captures in Swift. The first is to realize when the capture doesn't need to be by-reference at all: if we're capturing a <code>let</code>, its value can't change anyway, so we can capture by value to avoid the boxing overhead without changing the semantics. There are more complicated analyses one can do when capturing a <code>var</code>: if the <code>var</code> isn't modified after the point of capture (either in the closure or outside of it), then we can capture by value because the value isn't going to change.</p><p>The second optimization is when you can be sure that the closure itself won't live longer than the variables it is capturing. In these cases, it is safe to do a by-reference capture of the stack variable, without moving it to the heap. As C++ programmers, we make this kind of decision all the time based on knowledge of the functions we are calling: it's perfectly reasonable to use by-reference captures when passing a lambda into <code>std::transform</code>, because the algorithm isn't going to escape the closure.</p><p>The problem in C++, of course, is that we could be wrong: if the lambda does use by-reference captures and escapes, we have a stack use-after-free. If the lambda uses expensive by-copy captures and it never escapes, we've wasted some processor cycles and some memory.</p><p>Shouldn't the optimizer just figure out for us? Ideally, when the closure doesn't escape, we'd use by-reference captures that refer to the local variable on the stack, with no overhead. And when the closure does escape, we'd promote the captured local variables to the heap to maintain memory safety. Easy, right?</p><p>The problem is that you can't always see the code you're calling to determine whether it stashes a copy of the closure somewhere. If I call some C++ function:</p><pre><code>void <span class="call">doSomething</span>(std::function&lt;<span class="call">int</span>(int)&gt; f);
</code></pre><p>with a lambda, I have <em>no idea</em> what it is going to do with <code>f</code>. Even if it's a C++ template like this:</p><pre><code>template&lt;typename <span class="type">F</span>&gt;
void <span class="call">doSomething</span>(<span class="type">F</span> f);
</code></pre><p>the code might be hidden behind an explicit instantiation, or do something tricky with <code>f</code> that obscures the fact that it's storing a copy of it to execute later. So either the optimizer has to go through heroics to prove that <code>doSomething</code> doesn't stash a copy of <code>f</code> somewhere on the side, or it has to conservatively assume that the lambda could escape. The end result is that escape analysis like the one we would need to have both safe and efficient by-reference closures isn't actually very effective in C++.</p><p>To address this issue in Swift, we decided to change the language to make this optimization more reliable. The idea is simple:</p><h3>Parameters of function type are non-escaping by default</h3><p>In Swift, a parameter of function type is (by default) not allowed to escape the function's stack frame. Let's see an example:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>

  <span class="keyword">mutating func</span> doSomething(f: () -&gt; <span class="type">Int</span>) {
    fn = f  <span class="comment">// error: assigning non-escaping parameter 'f' to an @escaping closure</span>
  }
}
</code></pre><p>The function <code>doSomething</code> is trying to escape the value of <code>f</code> out of its stack frame by writing into the instance property <code>fn</code>. The compiler prevents such escapes systematically, and only allows the code to use <code>f</code> in a manner that either calls it (which is fine) or passes it down the stack to other functions that won't escape it.</p><p>Because the non-escaping behavior is part of the interface contract, the optimizer can safely assume that a closure passed to <code>doSomething</code> won't outlive its own stack frame. So this kind of code:</p><pre><code><span class="keyword">var</span> numbers: [<span class="type">Int</span>] = ...
s.<span class="call">doSomething</span> { 
  <span class="keyword">if let</span> value = numbers.<span class="property">last</span> {
    numbers.<span class="call">removeLast</span>()
    <span class="keyword">return</span> value
  }
 
  <span class="keyword">return</span> <span class="number">0</span>
}
</code></pre><p>we get by-reference captures without the overhead of promoting the local variables to the heap. By making non-escaping the default, we get better performance for the common cases that use closures for (e.g.) algorithms and callbacks while maintaining the safe model.</p><h3>Escaping function types</h3><p>You might have noticed that my struct <code>S</code> had an instance property of function type:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>
}
</code></pre><p>Outside of function parameters, values of function type are assumed to be escaping. If I were to assign directly into <code>S.fn</code>, the closure provided would be assumed to be escaping, so it would promote mutable captures to the heap:</p><pre><code>s.<span class="property">fn</span> = {      <span class="comment">// promotes numbers to the heap</span>
  <span class="keyword">if let</span> value = numbers.<span class="property">last</span> {
    numbers.<span class="call">removeLast</span>()
    <span class="keyword">return</span> value
  }
 
  <span class="keyword">return</span> <span class="number">0</span>
}
</code></pre><p>A function parameter can be explicitly marked with <code>@escaping</code> to allow its value to escape the function's stack frame. This is part of the type of the function, so callers know that they need to promote captures to the heap. For our <code>doSomething</code> function, it would look like this:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>

  <span class="keyword">mutating func</span> doSomething(f: <span class="keyword">@escaping</span> () -&gt; <span class="type">Int</span>) {
    fn = f  <span class="comment">// ok, f is marked @escaping</span>
  }
}
</code></pre><h3>Getting around the escaping restrictions</h3><p>The restriction on non-escaping functions can feel pretty harsh some times: you can't, for example, put the non-escaping value into another local variable or inside a local struct, because the Swift compiler will flag it as a local escape. For example, even this is disallowed:</p><pre><code><span class="keyword">func</span> haveFun(f: () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="keyword">var</span> s = <span class="type">S</span>(fn: f)  <span class="comment">// error: passing non-escaping parameter 'f' to function expecting an @escaping closure</span>
  <span class="keyword">return</span> s.<span class="call">fn</span>()
}
</code></pre><p>Swift does have a mechanism to deal with such cases, using the standard library function <a href="https://developer.apple.com/documentation/swift/withoutactuallyescaping(_:do:)"><code>withoutActuallyEscaping</code></a>: the basic idea is that <code>withoutActuallyEscaping</code> lets you temporarily convert a non-escaping closure into an escaping one. The escaping one is passed into a second closure that is immediately evaluated and its result returned. So <code>haveFun</code> can be implemented as follows:</p><pre><code><span class="keyword">func</span> haveFun(f: () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="call">withoutActuallyEscaping</span>(f, body: { escapingF <span class="keyword">in 
    var</span> s = <span class="type">S</span>(fn: escapingF)
    <span class="keyword">return</span> s.<span class="call">fn</span>()
  })
}
</code></pre><p>The first parameter to <code>withoutActuallyEscaping</code> is the non-escaping function <code>f</code>. The second parameter, <code>body</code>, is a closure that takes the escaping form of <code>f</code> and is executed immediately.</p><p>I know what you're thinking: after all that talk about safety with non-escaping parameters, how can there possibly be a standard library function that just throws all of it away? Madness!</p><p>What <code>withoutActuallyEscaping</code> is actually doing is deferring the correctness check for a non-escaping closure into a runtime check. If you try any funny business that actually escapes <code>escapingF</code> out of the <code>body</code> closure, the program will trap at runtime:</p><pre><code><span class="number">0</span>    escape                             0x000000010423750c <span class="call">haveFun</span>(f:) + <span class="number">144
1</span>    escape                             0x00000001042374dc main + <span class="number">24
2</span>    dyld                               0x0000000187fa87a8 start + <span class="number">2360</span>
closure argument was escaped <span class="keyword">in</span> withoutActuallyEscaping block: file escape.<span class="property">swift</span>, line <span class="number">9</span>, column <span class="number">3</span> 
</code></pre><p>I triggered this by writing <code>escapingF</code> into a global. The implementation of <code>withoutActuallyEscaping</code> is actually pretty neat: since escaping closures are reference counted (like other reference types in Swift), <code>withoutActuallyEscaping</code> records the reference count of the function <code>escapingF</code> when it's passed into the body closure. Then, it checks whether the reference count is the same on the way out of the body closure---if it is, all is well. If the reference count on the way out is <em>different</em>, it means that <code>escapingF</code> has escaped out of <code>body</code>, and we need to halt lest we cause undefined behavior.</p><p>You probably won't need <code>withoutActuallyEscaping</code> often, but when you need it, you <em>really</em> need it. It also illustrates an important principle: static safety is great, but sometimes you need to step outside of the bounds of what a compiler can statically prove is safe. When that happens, Swift takes the view that it's better to roll into dynamic checking to maintain the safety model rather than ban the code entirely or throw away safety. We saw this in our discussions of the law of exclusivity in part 1 of this series, and it comes up again as part of Swift's concurrency model.</p><h2>Local functions</h2><p>C++ function definitions can only be defined in class or namespace scope, and there is no notion of a "local" function that's defined within another function. The introduction of lambdas into C++ gave us an approximation of the feature. For example, here's a rough C++ equivalent to the <code>uniquing</code> function in Swift from earlier:</p><pre><code>template&lt;typename <span class="type">R</span>&gt;
std::vector&lt;iter_value_t&lt;iterator_t&lt;<span class="type">R</span>&gt;&gt;&gt; <span class="call">uniquing</span>(<span class="type">R</span> &amp;&amp;range) {
  using value_type = iter_value_t&lt;iterator_t&lt;<span class="type">R</span>&gt;&gt;;
  std::unordered_set&lt;value_type&gt; known;

  <span class="comment">// Local function to insert an item into "known" and report whether it was added.</span>
  auto tryInsertKnown = [&amp;](const value_type &amp;item) {
    <span class="keyword">return</span> known.<span class="call">insert</span>(item).<span class="property">second</span>;
  };
  
  <span class="comment">// Copy the items from the range that match the tryInsertKnown predicate.</span>
  std::vector&lt;value_type&gt; result;
  std::ranges::<span class="call">copy_if_result</span>(range, tryInsertKnown, std::<span class="call">back_inserter</span>(result));
  <span class="keyword">return</span> result;
}
</code></pre><p>The lambda we create and store in <code>tryInsertKnown</code> is effectively a local function: it's a function defined within another function, and captures some state from that outer function. It's a useful tool for breaking out local reusable parts of your function while still sharing state.</p><p>But doing this in C++ has some warts and limitations. First of all, it may act like a function, but it doesn't <em>look</em> like a function until you learn to squint at the pattern the right way, and not all IDEs know to treat it like a function for (e.g.) code completion. Second, because writing the type of a lambda explicitly isn't possible, we have to use <code>auto</code>, and that prevents us from directly writing a recursive local function in this style:</p><pre><code>auto localFib = [&amp;](int i) {
  <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="keyword">return</span> i;
  <span class="keyword">return</span> <span class="call">localFib</span>(i-<span class="number">1</span>) + <span class="call">localFib</span>(i-<span class="number">2</span>);  <span class="comment">// error: variable 'localFib' declared with deduced type 'auto' cannot appear in its own initializer</span>
};
</code></pre><p>Now, we can get around this by using <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>:</p><pre><code>   std::function&lt;<span class="call">int</span>(int)&gt; localFib;
  localFib = [&amp;](int i) {
    <span class="keyword">if</span> (i &lt; <span class="number">2</span>) <span class="keyword">return</span> i;
    <span class="keyword">return</span> <span class="call">localFib</span>(i-<span class="number">1</span>) + <span class="call">localFib</span>(i-<span class="number">2</span>);  <span class="comment">// okay!</span>
  };
</code></pre><p>This works because we've separated out the declaration of <code>localFib</code> and given it a type, so it can be captured in the lambda that's eventually assigned into it. It's uglier, but it works. And it's most likely going to cause a heap allocation in <code>std::function</code> unless your C++ library implements the <a href="https://devblogs.microsoft.com/oldnewthing/20200514-00/?p=103749">small object optimization for <code>std::function</code></a> and your lambda fits into it.</p><p>In Swift, local functions are just like functions at module scope. Here's a more explicit Swift <code>uniquing</code> that uses the local function:</p><pre><code><span class="keyword">func</span> uniquing&lt;C: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> collection: <span class="type">C</span>) -&gt; [<span class="type">C</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span>: <span class="type">Hashable</span> {
  <span class="keyword">var</span> known: <span class="type">Set</span>&lt;<span class="type">C</span>.<span class="type">Element</span>&gt; = []
  
  <span class="keyword">func</span> tryInsertKnown(<span class="keyword">_</span> item: <span class="type">C</span>.<span class="type">Element</span>) -&gt; <span class="type">Bool</span> {
    known.<span class="call">insert</span>(item).<span class="property">inserted</span>
  }
  
  <span class="keyword">return</span> collection.<span class="call">filter</span>(tryInsertKnown)
}
</code></pre><p>Like closures, local functions can capture local variables (such as <code>x</code> in the example above). Like global functions, local functions have a name with argument labels of your choosing, can be generic, and can be recursive. In other words---they're just like functions, and you don't need to think about them differently.</p><p>In an earlier revision of this post, I actually skipped this section on local functions, because they "just work" as they obviously should. Reader Pierre Lebeaupin pointed out that I need to explain them, because if you're coming from C++, you wouldn't expect them to work and therefore miss this feature entirely. Worse, you might be inclined to try to replicate the C++ pattern in Swift. If you try, it's going to be <em>hideous</em>:</p><pre><code><span class="keyword">var</span> localFibRec: ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>)! = <span class="keyword">nil</span>
localFibRec = { i <span class="keyword">in 
  if</span> i &lt; <span class="number">2</span> { <span class="keyword">return</span> i }
  <span class="keyword">return</span> localFibRec!(i-<span class="number">1</span>) + localFibRec!(i-<span class="number">2</span>)
}
<span class="keyword">let</span> localFib = localFibRec
</code></pre><p>The optional and extra level of indirection is there because of definite initialization: a variable needs to have a value before it is captured, so <code>localFibRec</code> needs to have a value (in this case, <code>nil</code>), because it can be captured in the closure that eventually gives <code>localFibRec</code> its value. When the language is fighting you that hard, find another way.</p><p>Enough local functions, now let's move along to a feature that Swift borrowed from... Ruby!</p><h2>Trailing closures</h2><p>When passing C++ lambdas into C++ standard library algorithms, we often end up with this ugly like <code>})</code> thing at the end of every call:</p><pre><code>std::<span class="call">copy_if</span>(numbers.<span class="call">begin</span>(), numbers.<span class="call">end</span>(), std::<span class="call">back_inserter</span>(even_numbers), [](auto x) {
  <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>
});
</code></pre><p>I know, it's just syntax. It shouldn't be a big deal. But these standard algorithms are supposed to feel like extensions of the language. It turns out that Ruby has a nice approach here, which allows a closure to be juxtaposed with a function name or call to be passed like a normal parameter. The <code>std::copy_if</code> above, in Swift, would be a <a href="https://developer.apple.com/documentation/swift/string/filter(_:)"><code>filter</code></a> operation that looks more like this:</p><pre><code>numbers.<span class="call">filter</span> { $0 % <span class="number">2</span> == <span class="number">0</span> }
</code></pre><p>The actual <code>filter</code> function is a collection algorithm declared like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">func</span> filter(<span class="keyword">_</span> isIncluded: () -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] { ... }
}
</code></pre><p>You can call <code>filter</code> by passing a function in parentheses, e.g., <code>numbers.filter(isPrime)</code>, or use trailing closure syntax as we did above. When designing Swift APIs involving closures, you generally want to put the closure parameter at the end to allow trailing closure syntax. For example, perhaps we want a version of <code>filter</code> that puts an upper limit on the number of elements that will be removed. We could design it like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">func</span> filtering(removingAtMost maxRemovals: <span class="type">Int</span>? = <span class="keyword">nil</span>, isIncluded: () -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] { ... })
}
</code></pre><p>This <code>filtering</code> function can be called with or without <code>removingAtMost</code>, while still using trailing closure syntax:</p><pre><code>numbers.<span class="call">filtering</span>(removingAtMost: <span class="number">17</span>) { ... } <span class="comment">// A</span>
numbers.<span class="call">filtering</span> { ... }                     <span class="comment">// B, maxRemovals defaults to nil</span>

numbers.<span class="call">filtering</span>(removingAtMost: <span class="number">17</span>, isIncluded: { ... }) <span class="comment">// same as A</span>
numbers.<span class="call">filtering</span>(isIncluded: { ... })                     <span class="comment">// same as B, maxRemovals defaults to nil</span>
</code></pre><p>You may have noticed that the trailing closure is unlabeled: the responsibiity is on the author of the function to ensure that the name of the function strongly implies what the trailing closure does, so that code using the function reads clearly. After all, <em>clarity at the point of use</em> is one of the central tenets of Swift's <a href="https://www.swift.org/documentation/api-design-guidelines/">API design guidelines</a>.</p><h3>Multiple trailing closures</h3><p>When a function takes multiple closure parameters, it's possible to call it with multiple trailing closures. This can help make code clearer when there are multiple actions that could be taken. For example, imagine an API that executes an operation with a timeout, cancelling it early if time expires:</p><pre><code><span class="comment">/// Run the given 'operation'. If it takes more than 'seconds', call the `onTimeout` function to
/// abort the operation and throw a `TimeoutError` instance.</span>
<span class="keyword">func</span> run&lt;R&gt;(timeout seconds: <span class="type">Double</span>, operation: () -&gt; <span class="type">R</span>, onTimeout: () -&gt; <span class="type">Void</span>) <span class="keyword">throws</span> -&gt; <span class="type">R</span>
</code></pre><p>A call to this function could make use of multiple trailing closures:</p><pre><code><span class="call">run</span>(timeout: <span class="number">0.5</span>) {
  <span class="keyword">while</span> !<span class="call">aborted</span> {
    <span class="comment">// part of a long-running operation</span>
  }
} onTimeout: {
  aborted = <span class="keyword">true</span>
}
</code></pre><p>Beyond the first trailing closure, the remaining trailing closures must have labels matching the corresponding parameter's label. Again, this needs to be reflected in API design: the primary "control flow" operation should be the first closure, and remaining closures should have labels that clearly express how and when the closure will be run.</p><h2>Wrap-up &amp; what's next</h2><p>For the most part, you can think of Swift closures like C++ lambdas. Similar use cases, similar syntax. Swift provides a safe model of captures that means you don't generally have to fret over returning a closure or how captures occur, although you will need to mark some parameters <code>@escaping</code> for those times when you want to save a closure to be called later.</p><p>Trailing closure syntax is a little nicety in Swift that makes closure-based APIs cleaner to use. Yes, it's <em>basically</em> nothing more than removing the unsightly <code>})</code> from a bunch of calls, but it's part of a larger design goal of enabling the design of powerful libraries that feel like extensions of the language. In fact, that's going to be our next topic: the features Swift provides for language extensibility and domain-specific embedded languages.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>