<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-closures"/><title>Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 7: Closures | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta property="og:description" content="Swift for C++ Practitioners, Part 7: Closures"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2024-04-28 03:09:00 +0000</p><p>Last updated on 2024-04-29 06:15:39 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 7: Closures</h1><p>Throughout this series, I've been using closures in examples without really defining them. Swift closures are a whole lot like C++ lambdas, with a similar design and syntax, and generally the same use cases. This post is going to dig a little deeper into Swift closures to give a better feel for how they work and how to make the best use of them.</p><h2>The syntax</h2><p>A Swift closure is an expression delimited by curly braces, <code>{ ... }</code> that represents an anonymous function. For example, this</p><pre><code><span class="keyword">let</span> hello = { <span class="string">"Hello"</span> }
</code></pre><p>defines a local variable <code>hello</code> that stores the closure. The type of <code>hello</code> is <code>() -&gt; String</code>, i.e., a function that takes no parameters.</p><p>Swift closures can be provided with parameters in one of two ways: anonymous parameters <code>$0</code>, <code>$1</code>, <code>$2</code>, and so on let you write very short closures for quick one-off operations. For example:</p><pre><code><span class="keyword">let</span> arithmeticOp: (<span class="type">Double</span>, <span class="type">Double</span>) -&gt; <span class="type">Double</span>
<span class="keyword">switch</span> opCode {
<span class="keyword">case</span> <span class="string">"+"</span>: arithmeticOp = { $0 + $1 }
<span class="keyword">case</span> <span class="string">"-"</span>: arithmeticOp = { $0 - $1 }
<span class="keyword">case</span> <span class="string">"*"</span>: arithmeticOp = { $0 * $1 }
<span class="keyword">case</span> <span class="string">"/"</span>: arithmeticOp = { $0 / $1 }
<span class="keyword">default</span>: <span class="keyword">throw</span> <span class="type">InterpreterError</span>.<span class="call">invalidOpcode</span>(opCode)
}
</code></pre><p><em>Please</em> only use this shorthand for the smallest closures. Once you get behind a single short expression, it's much better to name your parameters. To do so, list them prior to <code>in</code> within the curly braces. The <code>in</code> separates the declaration part of the closure from its statements. For example, the first case above could instead by written like this:</p><pre><code>{ x, y <span class="keyword">in</span> x + y }
</code></pre><p>In fact, prior to the <code>in</code>, you can write a full-fledged parameter list with type annotations, result type, and effect specifiers, if you don't want to leave them up to inference:</p><pre><code>{ (x: <span class="type">Double</span>, y: <span class="type">Double</span>) <span class="keyword">throws</span> -&gt; <span class="type">Double</span> <span class="keyword">in 
     let</span> result = <span class="keyword">try</span> <span class="call">addSafely</span>(x, y) }
     <span class="keyword">return</span> result
}
</code></pre><p>It's fairly uncommon to see such closures with all of the types written out like this, because the parameter types are generally inferred by context and the result type can be inferred from the closure body. Indeed, if you end up finding yourself writing a long closure that needs the full type annotations, it's likely that you should write a local function. Local functions are just like functions at module or type scope, e.g.,</p><pre><code><span class="keyword">func</span> produceAdder(x: <span class="type">Double</span>) {}
  <span class="keyword">func</span> doAdd(y: <span class="type">Double</span>) -&gt; <span class="type">Double</span> {
    <span class="keyword">return</span> x + y
  }
}
</code></pre><p>Like closures, local functions can capture local variables (such as <code>x</code> in the example above). Unlike closures, local functions have a name and can have their own generic parameters. I'm not going to talk about local functions more, because there's nothing more to say: they're functions, and they're local, and they work as you'd expect. I do want to talk about captures, though!</p><h2>Captures</h2><p>A <em>capture</em> is when a closure refers to a local variable (or parameter) from its enclosing scope. In such cases, the closure needs to a way to reference that variable---or it's value---when it executes. A simple example would be a closure that inserts elements into a set to remove duplicates from a collection, returning a new array with the elements uniqued:</p><pre><code><span class="keyword">func</span> uniquing&lt;C: <span class="type">Collection</span>&gt;(from collection: <span class="type">C</span>) -&gt; [<span class="type">C</span>.<span class="type">Element</span>] <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Element</span>: <span class="type">Hashable</span> {
  <span class="keyword">var</span> known: <span class="type">Set</span>&lt;<span class="type">C</span>.<span class="type">Element</span>&gt; = []
  <span class="keyword">return</span> collection.<span class="call">filter</span>({
    known.<span class="call">insert</span>($0).<span class="property">inserted</span>
  })
}
</code></pre><p>The closure passed to <code>filter</code> captures the local variable <code>known</code>. Each time it is called, it tries inserting the element it was given into the known set. If successful (i.e., the element wasn't there), the <code>inserted</code> field in the result is <code>true</code>, so the element is kept in the filtered sequence. If the element wasn't there, the <code>inserted</code> field in the result is <code>false</code>, so it's dropped.</p><p>Swift's captures are by reference. You can explicitly state the variables you want to capture by providing a capture list using the familiar square bracket syntax from C++ lambdas, but <em>within</em> the curly braces and before the (optional) parameter list. The <code>filter</code> call could, equivalently, look like this:</p><pre><code>   <span class="keyword">return</span> collection.<span class="call">filter</span>({ [known] <span class="keyword">in</span>
    known.<span class="call">insert</span>($0).<span class="property">inserted</span>
  })
</code></pre><p>This makes the capture more explicit to the reader, but doesn't change the semantics. If you want a by-copy capture rather than a by-reference capture, you can define a new captured variable and give it an initializer, again with syntax lifted from C++ lambdas:</p><pre><code>   <span class="keyword">return</span> collection.<span class="call">filter</span>({ [known=known] <span class="keyword">in</span>
    known.<span class="call">insert</span>($0).<span class="property">inserted</span>     <span class="comment">// error: known is immutable</span>
  })
</code></pre><p>This will make a copy of <code>known</code> into a capture called <code>known</code>. Note that such captures are immutable, so the above code would actually fail with an error <code>cannot assign to value: 'count' is an immutable capture</code>. However, this is a reasonable way to compute a captured value at the point of capture, ensuring that you get a copy. For example, here we create a bunch of closures that produce string values of the index in the loop where they were created:</p><pre><code><span class="keyword">var</span> closures: [() -&gt; <span class="type">String</span>] = []
<span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..&lt;<span class="number">100</span> {
  closures.<span class="call">append</span>({ [string = <span class="type">String</span>(i)] <span class="keyword">in</span> string })
}
</code></pre><p>I wouldn't expect most of the above to be surprising to a C++ practitioner, because it's mostly the same as lambdas. But the "captures are by reference" statement might be a little nerve-wracking, because what happens if you return a closure that captures by reference?</p><pre><code><span class="comment">// Produce a function that adds `x` to whatever integer value it is given.</span>
<span class="keyword">func</span> adding(x: <span class="type">Int</span>) -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) {
  <span class="keyword">return</span> { x + $0 }
}
</code></pre><p>Bad news, right? Not in Swift... let's look into the implementation model a bit.</p><h3>Implementation model for captures</h3><p>The implementation of C++ lambdas is fairly straightforward: for each lambda, the compiler synthesizes a class. The code of the lambda goes into its <code>operator()</code>, and for each capture the compiler will create a non-static data member. For example, let's consider this C++ lambda expression:</p><pre><code>std::vector&lt;int&gt; values;
int target;

auto fn = [&amp;values,target]() {
  values[<span class="number">0</span>] = target;
};
</code></pre><p>The corresponding synthesized class will look something like this:</p><pre><code><span class="keyword">class</span> Synthesized {
  std::vector&lt;int&gt; &amp;values;
  int target;
  
public:
  <span class="type">Synthesized</span>(std::vector&lt;int&gt; &amp;values, int target) : <span class="call">values</span>(values), <span class="call">target</span>(target) { }

  void <span class="call">operator</span>()() <span class="call">const</span> {
    values[<span class="number">0</span>] = target;
  }
};
</code></pre><p>By-reference captures produce a non-static member of reference type, while by-value captures are of non-reference type (so you get a copy).</p><p>Swift's translation of closures is conceptually similar, but the main difference is in the handling of by-reference captures. Semantically, a by-reference capture in Swift promotes the captured local to the heap, and uses a reference type to box it up. For example, imagine we have this <code>Box</code> type:</p><pre><code><span class="keyword">class</span> Box&lt;T&gt; {
  <span class="keyword">var</span> value: <span class="type">T</span>
  
  <span class="keyword">init</span>(value: <span class="type">T</span>) {
    <span class="keyword">self</span>.<span class="property">value</span> = value
  }
}
</code></pre><p>When a local variable like</p><pre><code><span class="keyword">var</span> numbers: [<span class="type">Int</span>]
</code></pre><p>is captured by-reference in a closure, it is <em>as if</em> the local variable were rewritten to</p><pre><code><span class="keyword">var</span> numbers: <span class="type">Box</span>&lt;[<span class="type">Int</span>]&gt;
</code></pre><p>and every initialization of <code>numbers</code> creates a box instance, and every subsequent access to <code>numbers</code>, whether it's in the function or a closure that captures it by reference, is rewritten to <code>numbers.value</code>.</p><p>This model makes it safe to return a closure from a function, even when that closure captures a local in the function by reference:</p><pre><code><span class="keyword">func</span> numberAccessor() -&gt; ((<span class="type">Int</span>) -&gt; <span class="type">Int</span>) {
  <span class="keyword">var</span> numbers: [<span class="type">Int</span>] = ...
  <span class="keyword">return</span> { x <span class="keyword">in</span> numbers[x] }
}
</code></pre><p>Since <code>numbers</code> is promoted to a <code>Box&lt;[Int]&gt;</code>, the returned closure itself keeps the "local" variable alive on the heap until the closure is no longer used. It's a simple model, and a safe one.</p><p>But if you actually did this for every local variable captured everywhere, it would be a very, very slow model. Let's talk about optimizations.</p><h3>Optimizations for captures</h3><p>There are two main optimizations for by-reference captures in Swift. The first is to realize when the capture doesn't need to be by-reference at all: if we're capturing a <code>let</code>, its value can't change anyway, so we can capture by value to avoid the boxing overhead without changing the semantics. There are more complicated analyses one can do when capturing a <code>var</code>: if the <code>var</code> isn't modified after the point of capture (either in the closure or outside of it), then we can capture by value because the value isn't going to change.</p><p>The second optimization is when you can be sure that the closure itself won't live longer than the variables it is capturing. In these cases, it is safe to do a by-reference capture of the stack variable, without moving it to the heap. As C++ programmers, we make this kind of decision all the time based on knowledge of the functions we are calling: it's perfectly reasonable to use by-reference captures when passing a lambda into <code>std::transform</code>, because the algorithm isn't going to escape the closure.</p><p>The problem in C++, of course, is that we could be wrong: if the lambda does use by-reference captures and escapes, we have a stack use-after-free. If the lambda uses expensive by-copy captures and it never escapes, we've wasted some processor cycles and some memory.</p><p>Shouldn't the optimizer just figure out for us? Ideally, when the closure doesn't escape, we'd use by-reference captures that refer to the local variable on the stack, with no overhead. And when the closure does escape, we'd promote the captured local variables to the heap to maintain memory safety. Easy, right?</p><p>The problem is that you can't always see the code you're calling to determine whether it stashes a copy of the closure somewhere. If I call some C++ function:</p><pre><code>void <span class="call">doSomething</span>(std::function&lt;<span class="call">int</span>(int)&gt; f);
</code></pre><p>with a lambda, I have <em>no idea</em> what it is going to do with <code>f</code>. Even if it's a C++ template like this:</p><pre><code>template&lt;typename <span class="type">F</span>&gt;
void <span class="call">doSomething</span>(<span class="type">F</span> f);
</code></pre><p>the code might be hidden behind an explicit instantiation, or do something tricky with <code>f</code> that obscures the fact that it's storing a copy of it to execute later. So either the optimizer has to go through heroics to prove that <code>doSomething</code> doesn't stash a copy of <code>f</code> somewhere on the side, or it has to conservatively assume that the lambda could escape. The end result is that escape analysis like the one we would need to have both safe and efficient by-reference closures isn't actually very effective in C++.</p><p>To address this issue in Swift, we decided to change the language to make this optimization more reliable. The idea is simple:</p><h3>Parameters of function type are non-escaping by default</h3><p>In Swift, a parameter of function type is (by default) not allowed to escape the function's stack frame. Let's see an example:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>

  <span class="keyword">mutating func</span> doSomething(f: () -&gt; <span class="type">Int</span>) {
    fn = f  <span class="comment">// error: assigning non-escaping parameter 'f' to an @escaping closure</span>
  }
}
</code></pre><p>The function <code>doSomething</code> is trying to escape the value of <code>f</code> out of its stack frame by writing into the instance property <code>fn</code>. The compiler prevents such escapes systematically, and only allows the code to use <code>f</code> in a manner that either calls it (which is fine) or passes it down the stack to other functions that won't escape it.</p><p>Because the non-escaping behavior is part of the interface contract, the optimizer can safely assume that a closure passed to <code>doSomething</code> won't outlive its own stack frame. So this kind of code:</p><pre><code><span class="keyword">var</span> numbers: [<span class="type">Int</span>] = ...
s.<span class="call">doSomething</span> { 
  <span class="keyword">if let</span> value = numbers.<span class="property">last</span> {
    numbers.<span class="call">removeLast</span>()
    <span class="keyword">return</span> value
  }
 
  <span class="keyword">return</span> <span class="number">0</span>
}
</code></pre><p>we get by-reference captures without the overhead of promoting the local variables to the heap. By making non-escaping the default, we get better performance for the common cases that use closures for (e.g.) algorithms and callbacks while maintaining the safe model.</p><h3>Escaping function types</h3><p>You might have noticed that my struct <code>S</code> had an instance property of function type:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>
}
</code></pre><p>Outside of function parameters, values of function type are assumed to be escaping. If I were to assign directly into <code>S.fn</code>, the closure provided would be assumed to be escaping, so it would promote mutable captures to the heap:</p><pre><code>s.<span class="property">fn</span> = {      <span class="comment">// promotes numbers to the heap</span>
  <span class="keyword">if let</span> value = numbers.<span class="property">last</span> {
    numbers.<span class="call">removeLast</span>()
    <span class="keyword">return</span> value
  }
 
  <span class="keyword">return</span> <span class="number">0</span>
}
</code></pre><p>A function parameter can be explicitly marked with <code>@escaping</code> to allow its value to escape the function's stack frame. This is part of the type of the function, so callers know that they need to promote captures to the heap. For our <code>doSomething</code> function, it would look like this:</p><pre><code><span class="keyword">struct</span> S {
  <span class="keyword">var</span> fn: () -&gt; <span class="type">Int</span>

  <span class="keyword">mutating func</span> doSomething(f: <span class="keyword">@escaping</span> () -&gt; <span class="type">Int</span>) {
    fn = f  <span class="comment">// ok, f is marked @escaping</span>
  }
}
</code></pre><h3>Getting around the escaping restrictions</h3><p>The restriction on non-escaping functions can feel pretty harsh some times: you can't, for example, put the non-escaping value into another local variable or inside a local struct, because the Swift compiler will flag it as a local escape. For example, even this is disallowed:</p><pre><code><span class="keyword">func</span> haveFun(f: () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="keyword">var</span> s = <span class="type">S</span>(fn: f)  <span class="comment">// error: passing non-escaping parameter 'f' to function expecting an @escaping closure</span>
  <span class="keyword">return</span> s.<span class="call">fn</span>()
}
</code></pre><p>Swift does have a mechanism to deal with such cases, using the standard library function <a href="https://developer.apple.com/documentation/swift/withoutactuallyescaping(_:do:)"><code>withoutActuallyEscaping</code></a>: the basic idea is that <code>withoutActuallyEscaping</code> lets you temporarily convert a non-escaping closure into an escaping one. The escaping one is passed into a second closure that is immediately evaluated and its result returned. So <code>haveFun</code> can be implemented as follows:</p><pre><code><span class="keyword">func</span> haveFun(f: () -&gt; <span class="type">Int</span>) -&gt; <span class="type">Int</span> {
  <span class="call">withoutActuallyEscaping</span>(f, body: { escapingF <span class="keyword">in 
    var</span> s = <span class="type">S</span>(fn: escapingF)
    <span class="keyword">return</span> s.<span class="call">fn</span>()
  })
}
</code></pre><p>The first parameter to <code>withoutActuallyEscaping</code> is the non-escaping function <code>f</code>. The second parameter, <code>body</code>, is a closure that takes the escaping form of <code>f</code> and is executed immediately.</p><p>I know what you're thinking: after all that talk about safety with non-escaping parameters, how can there possibly be a standard library function that just throws all of it away? Madness!</p><p>What <code>withoutActuallyEscaping</code> is actually doing is deferring the correctness check for a non-escaping closure into a runtime check. If you try any funny business that actually escapes <code>escapingF</code> out of the <code>body</code> closure, the program will trap at runtime:</p><pre><code><span class="number">0</span>    escape                             0x000000010423750c <span class="call">haveFun</span>(f:) + <span class="number">144
1</span>    escape                             0x00000001042374dc main + <span class="number">24
2</span>    dyld                               0x0000000187fa87a8 start + <span class="number">2360</span>
closure argument was escaped <span class="keyword">in</span> withoutActuallyEscaping block: file escape.<span class="property">swift</span>, line <span class="number">9</span>, column <span class="number">3</span> 
</code></pre><p>I triggered this by writing <code>escapingF</code> into a global. The implementation of <code>withoutActuallyEscaping</code> is actually pretty neat: since escaping closures are reference counted (like other reference types in Swift), <code>withoutActuallyEscaping</code> records the reference count of the function <code>escapingF</code> when it's passed into the body closure. Then, it checks whether the reference count is the same on the way out of the body closure---if it is, all is well. If the reference count on the way out is <em>different</em>, it means that <code>escapingF</code> has escaped out of <code>body</code>, and we need to halt lest we cause undefined behavior.</p><p>You probably won't need <code>withoutActuallyEscaping</code> often, but when you need it, you <em>really</em> need it. It also illustrates an important principle: static safety is great, but sometimes you need to step outside of the bounds of what a compiler can statically prove is safe. When that happens, Swift takes the view that it's better to roll into dynamic checking to maintain the safety model rather than ban the code entirely or throw away safety. We saw this in our discussions of the law of exclusivity in part 1 of this series, and it comes up again as part of Swift's concurrency model.</p><h2>Trailing closures</h2><p>When passing C++ lambdas into C++ standard library algorithms, we often end up with this ugly like <code>})</code> thing at the end of every call:</p><pre><code>std::<span class="call">copy_if</span>(numbers.<span class="call">begin</span>(), numbers.<span class="call">end</span>(), std::<span class="call">back_inserter</span>(even_numbers), [](auto x) {
  <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>
});
</code></pre><p>I know, it's just syntax. It shouldn't be a big deal. But these standard algorithms are supposed to feel like extensions of the language. It turns out that Ruby has a nice approach here, which allows a closure to be juxtaposed with a function name or call to be passed like a normal parameter. The <code>std::copy_if</code> above, in Swift, would be a <a href="https://developer.apple.com/documentation/swift/string/filter(_:)"><code>filter</code></a> operation that looks more like this:</p><pre><code>numbers.<span class="call">filter</span> { $0 % <span class="number">2</span> == <span class="number">0</span> }
</code></pre><p>The actual <code>filter</code> function is a collection algorithm declared like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">func</span> filter(<span class="keyword">_</span> isIncluded: () -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] { ... }
}
</code></pre><p>You can call <code>filter</code> by passing a function in parentheses, e.g., <code>numbers.filter(isPrime)</code>, or use trailing closure syntax as we did above. When designing Swift APIs involving closures, you generally want to put the closure parameter at the end to allow trailing closure syntax. For example, perhaps we want a version of <code>filter</code> that puts an upper limit on the number of elements that will be removed. We could design it like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">func</span> filtering(removingAtMost maxRemovals: <span class="type">Int</span>? = <span class="keyword">nil</span>, isIncluded: () -&gt; <span class="type">Bool</span>) -&gt; [<span class="type">Element</span>] { ... })
}
</code></pre><p>This <code>filtering</code> function can be called with or without <code>removingAtMost</code>, while still using trailing closure syntax:</p><pre><code>numbers.<span class="call">filtering</span>(removingAtMost: <span class="number">17</span>) { ... } <span class="comment">// A</span>
numbers.<span class="call">filtering</span> { ... }                     <span class="comment">// B, maxRemovals defaults to nil</span>

numbers.<span class="call">filtering</span>(removingAtMost: <span class="number">17</span>, isIncluded: { ... }) <span class="comment">// same as A</span>
numbers.<span class="call">filtering</span>(isIncluded: { ... })                     <span class="comment">// same as B, maxRemovals defaults to nil</span>
</code></pre><p>You may have noticed that the trailing closure is unlabeled: the responsibiity is on the author of the function to ensure that the name of the function strongly implies what the trailing closure does, so that code using the function reads clearly. After all, <em>clarity at the point of use</em> is one of the central tenets of Swift's <a href="https://www.swift.org/documentation/api-design-guidelines/">API design guidelines</a>.</p><h3>Multiple trailing closures</h3><p>When a function takes multiple closure parameters, it's possible to call it with multiple trailing closures. This can help make code clearer when there are multiple actions that could be taken. For example, imagine an API that executes an operation with a timeout, cancelling it early if time expires:</p><pre><code><span class="comment">/// Run the given 'operation'. If it takes more than 'seconds', call the `onTimeout` function to
/// abort the operation and throw a `TimeoutError` instance.</span>
<span class="keyword">func</span> run&lt;R&gt;(timeout seconds: <span class="type">Double</span>, operation: () -&gt; <span class="type">R</span>, onTimeout: () -&gt; <span class="type">Void</span>) <span class="keyword">throws</span> -&gt; <span class="type">R</span>
</code></pre><p>A call to this function could make use of multiple trailing closures:</p><pre><code><span class="call">run</span>(timeout: <span class="number">0.5</span>) {
  <span class="keyword">while</span> !<span class="call">aborted</span> {
    <span class="comment">// part of a long-running operation</span>
  }
} onTimeout: {
  aborted = <span class="keyword">true</span>
}
</code></pre><p>Beyond the first trailing closure, the remaining trailing closures must have labels matching the corresponding parameter's label. Again, this needs to be reflected in API design: the primary "control flow" operation should be the first closure, and remaining closures should have labels that clearly express how and when the closure will be run.</p><h2>Wrap-up &amp; what's next</h2><p>For the most part, you can think of Swift closures like C++ lambdas. Similar use cases, similar syntax. Swift provides a safe model of captures that means you don't generally have to fret over returning a closure or how captures occur, although you will need to mark some parameters <code>@escaping</code> for those times when you want to save a closure to be called later.</p><p>Trailing closure syntax is a little nicety in Swift that makes closure-based APIs cleaner to use. Yes, it's <em>basically</em> nothing more than removing the unsightly <code>})</code> from a bunch of calls, but it's part of a larger design goal of enabling the design of powerful libraries that feel like extensions of the language. In fact, that's going to be our next topic: the features Swift provides for language extensibility and domain-specific embedded languages.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>