<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/posts/swift-for-cxx-practitioners-move"/><meta name="twitter:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-move"/><meta property="og:url" content="https://www.douggregor.net/posts/swift-for-cxx-practitioners-move"/><title>Swift for C++ Practitioners, Part 12: Move Semantics | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 12: Move Semantics | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 12: Move Semantics | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 12: Move Semantics"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 12: Move Semantics"/><meta property="og:description" content="Swift for C++ Practitioners, Part 12: Move Semantics"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body class="item-page"><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts" class="selected">Posts</a></li></ul></nav></div></header><div class="wrapper"><article><p>Originally posted on 2025-01-07 06:00:00 +0000</p><p>Last updated on 2025-01-06 23:22:48 +0000</p><div class="content"><h1>Swift for C++ Practitioners, Part 12: Move Semantics</h1><p>Since their introduction in C++11, move semantics have been an integral part of programming in C++. Move semantics are implemented in C++ with <em>rvalue references</em>, which express the idea that the entity they refer to is temporary in nature (an <em>rvalue</em> in programming language speak) and effectively won't be used again later. There are a number of uses of rvalue references in C++, but I like to think of them as enabling three separate but complementary features:</p><ul><li><em>Move optimizations</em>: when one needs to copy a value, but the source of that copy is not going to be used afterward, one can optimize the copy by transferring ownership of the resources from the source to the destination instead of copying them. For container types like <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a> or <a href="https://en.cppreference.com/w/cpp/string/basic_string"><code>std::string</code></a>, this means replacing a linear-time copy with a constant-time move, making it a valuable optimization. One can trigger this optimization explicitly using <a href="https://en.cppreference.com/w/cpp/utility/move"><code>std::move</code></a>.</li><li><em>Move-only types</em>: as their name implies, move-only types can be moved, but they can never be copied. They are primarily used for providing unique ownership of resources that either can't be copied or for which the overhead of copying is so great that the programmer wants to make every copy explicit. <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a> is the canonical example of a move-only type in C++.</li><li><em>Perfect forwarding</em>: in C++ templates, one often needs to take some argument values and forward them to another template. In doing so, we want to retain as many of the characteristics of the original argument as possible: it's type, but also whether it is <code>const</code> and whether it refers to an lvalue (named thing) or rvalue (temporary thing), so that (for example) the argument can be moved-from in the template being forwarded to if the argument originally started its live as a non-<code>const</code> rvalue. One can use <a href="https://en.cppreference.com/w/cpp/utility/forward"><code>std::forward</code></a> along with rvalue-reference arguments to forward.</li></ul><p>More or less, the same reasons that motivated the introduction of move semantics into C++ are applicable to Swift. We'll dive in a moment, but at a very high level:</p><ul><li>Move optimizations are automatic in Swift, which is good for performance but can hold some surprises for C++ programmers, especially around the <a href="https://en.wikipedia.org/wiki/Resource_acquisition_is_initialization">RAII</a> idiom.</li><li>Move-only types are available in Swift under the name "non-copyable types", and I'll spend the bulk of this post talking about them.</li><li>Perfect forwarding isn't possible in Swift, because we haven't found a solution that works well with Swift's separate type checking model.</li></ul><h2>Automatic move optimizations</h2><p>I defined a move optimization as a place where something that would normally be a copy is replaced by a "move", that steals the resources from the source rather than making a copy of them. So long as the source value isn't used again after it is moved-from (or is assigned to again), and this is a safe optimization. Let's start with a C++ <code>shared_ptr</code> example and assess the copies that occur:</p><pre><code><span class="keyword">class</span> Counter {
  int value;
  
public:
  <span class="type">Counter</span>() : <span class="call">value</span>(<span class="number">0</span>) { }
};

std::shared_ptr&lt;<span class="type">Counter</span>&gt; <span class="call">createCounter</span>() {
  auto counter = std::make_shared&lt;<span class="type">Counter</span>&gt;(); <span class="comment">// (A)</span>
  auto counter2 = counter;                    <span class="comment">// (B)</span>
  <span class="keyword">return</span> counter2;                            <span class="comment">// (C)</span>
}
</code></pre><p>All three of the marked lines here are interesting for different reasons. The line marked (A) creates a new <code>std::shared_ptr&lt;Counter&gt;</code> instance and initializes <code>counter</code> with it. This looks like a copy, but because the initializer on the right-hand side an rvalue (temporary), this ends up calling <code>shared_ptr</code>'s move constructor, so C++ is getting an implicit move optimization.</p><p>The line marked (B) initializes another <code>std::shared_ptr&lt;Counter&gt;</code> instance, <code>counter2</code>, from the first <code>counter</code>. This looks a little like the first line, but because <code>counter</code> is an lvalue (a thing with a name), C++ will not turn it into a move: this still calls <code>shared_ptr</code>'s' copy constructor.</p><p>The line marked (C) is returning <code>counter2</code>, which is conceptually copying the <code>shared_ptr</code> instance out as the return value. However, C++ does another, conceptually related optimization here---the Named Return Value Optimization, or NRVO---to not call any constructor at all. It puts the local variable <code>counter2</code> in the place where the return value should go, so it doesn't have to copy or move to it later.</p><p>So in C++, we get a move, a copy, and an NRVO optimization in this example. All of this is required by the language, and you can observe it if you were to inspect the compiler's output or annotate <code>shared_ptr</code>'s various constructors with logging to see what happens.</p><p>In Swift, things are a bit different. Let's translate that example:</p><pre><code><span class="keyword">class</span> Counter {
  <span class="keyword">var</span> value: <span class="type">Int</span> = <span class="number">0</span>
}

<span class="keyword">func</span> createCounter() -&gt; <span class="type">Counter</span> {
  <span class="keyword">let</span> counter = <span class="type">Counter</span>()          <span class="comment">// (A)</span>
  <span class="keyword">let</span> counter2 = counter           <span class="comment">// (B)</span>
  <span class="keyword">return</span> counter2                  <span class="comment">// (C)</span>
}
</code></pre><p>Semantically, all of (A), (B), and (C) are copies in Swift. However, Swift's optimizer will turn all of them into moves. For the line marked (A), this is trivial for the same reasons as in C++: the right-hand side of the initialization is a temporary, so we can move from it.</p><p>The line marked (B) requires more analysis. The right-hand side is <code>counter</code>, which is not used after the initialization of <code>counter2</code>, so it's safe to <em>end its lifetime early</em> by moving from it rather than copying. If you were to add a <code>print(counter)</code> or similar use after (B), then (B) would remain a copy. The line marked (C) uses a similar analysis to (B): after the return, <code>counter2</code> isn't used, so it can safely be moved-from, ending its lifetime.</p><p>These optimizations are possible in Swift because code cannot observe copies or moves: there's no equivalent to a user-written copy or move constructor, so there is no place that one could provide behavior that differs between the two. Yes, you can inspect the compiler's output to see what happens (the compiler flag <code>-emit-sil</code> is good for doing this), and perhaps copies will show up in a profile if they are happening too often, but that's it.</p><h3>Explicitly consuming (moving from) a value</h3><p>Is that unnecessary copy at the line marked (B) in the C++ code <em>still</em> bothering you? I thought so, and this is why <code>std::move</code> exists in C++. <code>std::move</code> effectively turns an lvalue into an rvalue, allowing move optimizations to occur. This has no copies in it:</p><pre><code>std::shared_ptr&lt;<span class="type">Counter</span>&gt; <span class="call">createCounter</span>() {
  auto counter = std::make_shared&lt;<span class="type">Counter</span>&gt;(); <span class="comment">// (A)</span>
  auto counter2 = std::<span class="call">move</span>(counter);         <span class="comment">// (B)</span>
  <span class="keyword">return</span> counter2;                            <span class="comment">// (C)</span>
}
</code></pre><p>From the C++ perspective, the lifetime of <code>counter</code> hasn't changed even after it has been moved-from at the line marked (B). However, the move constructor has possibly stolen its resources and left it in some assignable-and-destructible state. If you really wanted to add a line after (B) this does something like this:</p><pre><code>std::cout &lt;&lt; counter-&gt;value &lt;&lt; <span class="string">"\n"</span>;
</code></pre><p>the C++ language won't stop you. The C++ standard will tell you it was a bad idea, because you shouldn't be using a moved-from value unless you are destroying it or assigning to it. If you run this code, it'll probably SEGFAULT, because the move constructor for <code>shared_ptr</code> makes the moved-from pointer <code>NULL</code>, stealing the pointer to avoid increasing the reference count. We tend to say that C++ has "non-destructive" moves, because moving from a value still leaves the value accessible, and it's up to the programmer to do so correctly.</p><p>Swift has an equivalent to <code>std::move</code> called <code>consume</code>. It is used to force Swift to perform a move (rather than a copy) either to be more explicit about documenting the end of a value's lifetime or to ensure that a desired optimization happens. Let's do that to the Swift version of <code>createCounter</code>:</p><pre><code><span class="keyword">func</span> createCounter() -&gt; <span class="type">Counter</span> {
  <span class="keyword">let</span> counter = <span class="type">Counter</span>()          <span class="comment">// (A)</span>
  <span class="keyword">let</span> counter2 = consume counter   <span class="comment">// (B)</span>
  <span class="keyword">return</span> counter2                  <span class="comment">// (C)</span>
}
</code></pre><p>The <code>consume</code> ensures that a move will occur, whether or not the optimizer would have done so on its own. Consumes in Swift are destructive, meaning that this <code>consume</code> operation ends the lifetime of <code>counter</code> entirely: the variable can no longer be read from. If I try to print its value, I'll get a compile-time error like this:</p><pre><code><span class="number">15</span> | 
<span class="number">16</span> | <span class="keyword">func</span> createCounter() -&gt; <span class="type">Counter</span> {
<span class="number">17</span> |   <span class="keyword">let</span> counter = <span class="type">Counter</span>()
   |                 `- error: 'counter' used after consume
<span class="number">18</span> |   <span class="keyword">let</span> counter2 = consume counter
   |                  `- note: consumed here
<span class="number">19</span> |   <span class="call">print</span>(counter.<span class="property">value</span>)
   |                 `- note: used here
<span class="number">20</span> |   <span class="keyword">return</span> counter2
<span class="number">21</span> | }
</code></pre><p>It's not that common to use <code>consume</code> in Swift, because the move optimizations are often good enough. But it's a tool for making those moves more explicit, and unlike <code>std::move</code>, the Swift compiler will ensure that you don't use the value after it was moved-from.</p><h3>Variable lifetimes can be shortened in Swift</h3><p>Earlier, I noted that you cannot observe copies or moves (other than an explicit <code>consume</code>). However, you <em>can</em> observe when a move optimization ends the lifetime of a value early, because classes can have a <code>deinit</code> that (like a C++ destructor) runs when the instance is destroyed. Here's an example in Swift where I've triggered the "early" destruction of a class instance via a move optimization:</p><pre><code><span class="keyword">class</span> Counter {
  <span class="keyword">var</span> value = <span class="number">0</span>

  <span class="keyword">deinit</span> {
    <span class="call">print</span>(<span class="string">"Destroying Counter(</span>\(value)<span class="string">)"</span>)
  }
}

<span class="keyword">class</span> TakeCounter {
  <span class="keyword">init</span>(<span class="keyword">_</span>: <span class="type">Counter</span>) { }

  <span class="keyword">deinit</span> {
    <span class="call">print</span>(<span class="string">"Destroying TakeCounter"</span>)
  }
}

<span class="keyword">func</span> eatCounter() {
  <span class="keyword">let</span> counter = <span class="type">Counter</span>()
  <span class="keyword">let</span> takeCounter = <span class="type">TakeCounter</span>(counter)
}

<span class="call">eatCounter</span>()
</code></pre><p>If you run this without optimizations, you'll get the following output:</p><pre><code><span class="type">Destroying TakeCounter
Destroying Counter</span>(<span class="number">0</span>)
</code></pre><p>This is what you would expect from C++: <code>takeCounter</code> is initialized second, so it is destroyed first, as a rule. When Swift's optimizer is enabled (e.g., by providing <code>-O</code> on the command line), passing <code>counter</code> into the <code>TakeCounter</code> initializer is optimized into a move (rather than a copy), because <code>counter</code> isn't used later in the function. The <code>TakeCounter</code> initializer cleans up the <code>counter</code> argument it is given, ending the lifetime early, so the output you will get is:</p><pre><code><span class="type">Destroying Counter</span>(<span class="number">0</span>)
<span class="type">Destroying TakeCounter</span>
</code></pre><p>This optimization is important for the performance of automatic reference counting and for working with large value types like arrays and dictionaries (which use automatic reference counting under-the-hood). However, it's likely to surprise seasoned C++ developers who have internalized C++'s strict rules for when objects are destroyed.</p><h3>RAII is not the same</h3><p>The shortening of variable lifetimes also means that one of the core idioms of C++, Resource Acquisition Is Initialization (RAII) behaves very differently in Swift. You can use safely classes to hold on to resources in Swift, where the initializer allocates the resource and the deinitializer deallocates it. However, you can't depend on strict stack-based deallocation. For example, this class encapsulates a file descriptor:</p><pre><code><span class="keyword">class</span> FileHandle {
  <span class="keyword">var</span> fd: <span class="type">CInt</span>
  
  <span class="keyword">init</span>(filename: <span class="type">String</span>) {
    fd = <span class="call">open</span>(filename, <span class="type">O_RDONLY</span>)
  }
  
  <span class="keyword">deinit</span> {
    <span class="call">close</span>(fd)
  }
}
</code></pre><p>However, it is not safe to use the value of <code>fd</code> from outside of the class because the class instance might get destroyed early:</p><pre><code><span class="keyword">func</span> maybeBadFunc() {
  <span class="keyword">let</span> file = <span class="type">FileHandle</span>(filename: <span class="string">"myfile.txt"</span>)
  <span class="keyword">let</span> fd = file.<span class="property">fd</span>
  <span class="comment">// do stuff 'file' and 'fd'
  // do stuff with 'fd', but don't touch 'file'</span>
}
</code></pre><p>The break in encapsulation that allows the value of <code>fd</code> to be used after the <code>file</code> is no longer used can mean that the file gets closed before we're actually done with it. In Swift, there is a standard idiom for correctly handling this: the <code>FileHandle</code> class will make that state <code>private</code> and provide a <code>withXYZ</code> method that gives the value to a closure. Clients then use that value within the closure, and the file handle is kept alive. Here's what that could look like:</p><pre><code><span class="keyword">class</span> FileHandle {
  <span class="keyword">private var</span> fd: <span class="type">CInt</span>
  
  <span class="comment">// init, deinit stay the same</span>
 
  <span class="keyword">func</span> withFileDescriptor&lt;R, E&gt;(body: (<span class="type">CInt</span>) <span class="call">throws</span>(<span class="type">E</span>) -&gt; <span class="type">R</span>) <span class="call">throws</span>(<span class="type">E</span>) -&gt; <span class="type">R</span> {
    <span class="keyword">return try</span> <span class="call">body</span>(fd)
  }
}
</code></pre><p>The <code>withFileDescriptor</code> method takes a closure and calls it, returning its result. If that closure throws some error type <code>E</code>, then that's what <code>withFileDescriptor</code> throws. A client can use <code>withFileDescriptor</code> to perform an operation on the underlying file descriptor like this:</p><pre><code><span class="keyword">let</span> file = <span class="type">FileHandle</span>(filename: <span class="string">"myfile.txt"</span>)
<span class="keyword">let</span> data = file.<span class="call">withFileDescriptor</span> { fd <span class="keyword">in</span> 
  <span class="comment">// read some bytes from fd
  // decode those bytes into some data</span>
  <span class="keyword">return</span> data
}
</code></pre><p>This explicit form of "with" block is common in Swift: it has the benefit of making the scope of the access to the internal state (here, the file descriptor) clearly called out in the source code, for human reader and Swift optimizer alike, and encourages programmers to keep these blocks small and focused.</p><h2>Non-copyable ("move-only") types</h2><p>In both C++ and Swift, most types are copyable by default. In C++, one can define a move-only type by explicitly deleting the copy constructor and copy-assignment operator. For example, a simple move-only file handle might look like this:</p><pre><code><span class="keyword">class</span> FileHandle {
  int fd;
  
public:
  <span class="type">FileHandle</span>(const <span class="type">FileHandle</span> &amp;) = delete;
  <span class="type">FileHandle</span> &amp;operator=(const <span class="type">FileHandle</span> &amp;) = delete;
};
</code></pre><p>In Swift, you can't delete those because you can't write them in the first place. Instead, you make the type <em>non-copyable</em> (Swift's term for "move-only") by suppressing its copyability in the type definition:</p><pre><code><span class="keyword">struct</span> FileHandle: ~<span class="type">Copyable</span> {
  <span class="keyword">private let</span> fd: <span class="type">CInt</span>
  
  <span class="keyword">init</span>(filename: <span class="type">String</span>) {
    fd = <span class="call">open</span>(filename, <span class="type">O_RDONLY</span>)
  }
  
  <span class="keyword">deinit</span> {
    <span class="call">close</span>(fd)
  }
}
</code></pre><p>Here, <code>Copyable</code> is a protocol that all copyable types in Swift implicitly conform to. The tilde (<code>~</code>) suppresses that implicit conformance, so our definition of <code>FileHandle</code> here is suppressing the implicit conformance to <code>Copyable</code>. Therefore, it is a non-Copyable (or "move-only") type.</p><p>Non-copyable types look and act like other types in Swift, except that they are never copied. If you do something that would require a copy, the compiler will produce an error. Here's an example taking a file handle and trying to use it afterward:</p><pre><code><span class="keyword">func</span> useSomething() {
  <span class="keyword">var</span> fileHandle = <span class="type">FileHandle</span>(filename: <span class="string">"myfile.txt"</span>)
  <span class="keyword">let</span> otherHandle = fileHandle
  <span class="keyword">_</span> = fileHandle
}
</code></pre><p>The Swift compiler will reject this with the following error:</p><pre><code><span class="number">14</span> | 
<span class="number">15</span> | <span class="keyword">func</span> useSomething() {
<span class="number">16</span> |   <span class="keyword">var</span> fileHandle = <span class="type">FileHandle</span>(filename: <span class="string">"myfile.txt"</span>)
   |       `- error: 'fileHandle' consumed more than once
<span class="number">17</span> |   <span class="keyword">let</span> otherHandle = fileHandle
   |                     `- note: consumed here
<span class="number">18</span> |   <span class="keyword">_</span> = fileHandle
   |     `- note: consumed again here
<span class="number">19</span> | }
</code></pre><p>I like to think of this as being a spectrum for move optimizations: copies of copyable value types will be optimized to moves when safe, and you can force the optimization in particular instances with <code>consume</code>. Non-copyable types force the move optimization <em>everywhere</em>, so every copy is removed (or else the program fails to compile). If we tried the above with C++, we'd have to write a <code>std::move(fileHandle)</code> in the initialization of <code>otherHandle</code>, but it would still allow us to access <code>fileHandle</code> (incorrectly) later in the function body.</p><h3>Deinitializers in structs!?</h3><p>Our first <code>FileHandle</code> in Swift was a class, with a deinitializer that closes the file. You may have been tempted to write a deinitializer in a struct or an enum, only to be rebuked by the compiler with an error like this:</p><pre><code>error: deinitializer cannot be declared <span class="keyword">in struct</span> '<span class="type">FileHandle</span>' that conforms to '<span class="type">Copyable</span>'
</code></pre><p>Because (copyable) structs and enums can be freely copied, there's no single point of ownership that can be identified, so there's no way to know when the last copy is destroyed. They can't meaningfully have <code>deinit</code>s. But non-copyable structs and enums <em>do</em> have a single point of ownership: it's the live variable storing the value. In our example above, when we initialized <code>fileHandle</code>, that variable owned the value. When <code>otherHandle</code> was initialized from <code>fileHandle</code>, ownership was transferred from the now-dead <code>fileHandle</code> over to <code>otherHandle</code>. This ownership is understood by the compiler, so the <code>deinit</code> will be invoked exactly once, when the live value goes out of scope.</p><p>C++ move-only types also generally have this notion of the "live value", but it's not understood by the compiler. Rather, it's built into the types themselves. For example, <code>std::unique_ptr</code> will store a NULL pointer to indicate that it doesn't have the live value, and moving from a <code>std::unique_ptr</code> always makes the moved-from value have a NULL pointer. Effectively, every move-only type in C++ has to have a "dead" state where the destructor does nothing, because the C++ compiler will run the destructor for both the live value and the dead values. Noncopyable Swift structs and enums don't need to have a "dead" state, because the deinitializer won't get called on dead values. This is one of the other benefits of destructive moves: they simplify non-copyable/move-only types by eliminating the dead state, and eliminate a branch in the destructor/deinitializer to test for that dead state.</p><p>Noncopyable structs (and enums) can have a deinit to free resources, and they provide strict ownership without any runtime overhead. For automatically managing a resource in Swift, use either a class (when the resource is shared) or a noncopyable struct or enumerator (when the resource must be uniquely owned). Allocate the resource in the initializer, deallocate it in the deinitializer.</p><h3>Parameter passing</h3><p>When passing around values to functions, Swift will make copies as needed to provide arguments to functions. With non-copyable types, we can no longer make a copy when passing an argument to a function, so we need to know more about what the function will do with the argument. Is it going to mutate it? Store it in some data structure somewhere else? This is part of the interface to the function, so it expressed as part of the parameter:</p><ul><li><code>consuming</code> parameters will consume their argument, ending its lifetime. Think of this as an rvalue reference parameter, <code>FileHandle&amp;&amp;</code>, where you are expected to take the value in C++ (and it's enforced in Swift) and the caller can no longer use it.</li><li><code>borrowing</code> parameters will operate on their argument for a time without modifying it or ending its lifetime. Think of this as a constant lvalue reference parameter, <code>const FileHandle &amp;</code>, where you can access but not mutate the value you're given.</li><li><code>inout</code> parameters can mutate their argument but will not end its lifetime. Think of this as a non-constant lvalue reference parameter, <code>FileHandle &amp;</code>, where you can access and mutate the value. We discussed these before in the post on <a href="../swift-for-cxx-practitioners-value-types/">value types</a>, and the behavior is the same for copyable and non-copyable value types.</li></ul><p>These modifiers are placed on the function parameter to say how the function will work with that parameter. Of these, the most interesting is <code>consuming</code>, because it does something not available with normal copyable value types: it ends the lifetime of its argument so it cannot be used again. For example, one could make a function that explicitly consumes a file handle so that it will be closed before the function returns:</p><pre><code><span class="keyword">func</span> closeMe(<span class="keyword">_</span> fileHandle: consuming <span class="type">FileHandle</span>) { }

<span class="keyword">func</span> testClose() {
  <span class="keyword">let</span> fileHandle = <span class="type">FileHandle</span>(filename: <span class="string">"myfile.txt"</span>)
  <span class="call">closeMe</span>(fileHandle)
  <span class="keyword">_</span> = fileHandle <span class="comment">// error: fileHandle was consumed by the call to closeMe</span>
}
</code></pre><p>The call to <code>closeMe</code> consumes <code>fileHandle</code>, and <code>closeMe</code> itself will call the deinitializer for its argument. Therefore, any attempt to use <code>fileHandle</code> after this call is an error. In C++ terms, <code>closeMe</code> would take a <code>FileHandle&amp;&amp;</code> that it steals from, and the call to <code>closeMe</code> would implicity move its argument with <code>std::move(fileHandle)</code>.</p><p>This particular function is probably better off as a method on <code>FileHandle</code>. One can make methods <code>consuming</code> to indicate that they consume <code>self</code> (just like making them <code>mutating</code> indicates that <code>self</code> is <code>inout</code>):</p><pre><code><span class="keyword">extension</span> <span class="type">FileHandle</span> {
  consuming <span class="keyword">func</span> close() {
    <span class="comment">// nothing to do, because the deinitializer will be called implicitly on self</span>
  }
}
</code></pre><p>A <code>consuming</code> method ends the lifetime of <code>self</code>, so again the body is empty because the <code>deinit</code> is called implicitly. However, we should probably introduce some error checking here to make sure that the file closed properly, and (say) throw an error if it didn't---something we cannot do from the deinitializer. To make this work, however, we have to tell Swift <em>not</em> to call the deinitializer, because we don't want to end up introducing a "dead" state like we have to in C++. We can do so with the statement <code>discard self</code>, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">FileHandle</span> {
  consuming <span class="keyword">func</span> closeMe() {
    <span class="keyword">let</span> result = <span class="call">close</span>(fd)
    discard <span class="keyword">self
    if</span> result != <span class="number">0</span> {
      <span class="keyword">throw</span> <span class="type">FileError</span>.<span class="property">closeFailed</span>
    }
  }
}
</code></pre><p>Here, we close the file, tell Swift <em>not</em> to destroy <code>self</code> for us, and then throw an error if the close failed. From the caller perspective, the <code>FileHandle</code> has been consumed either way, and they'll be able to react to an error using Swift's error-handling mechanisms.</p><p><code>borrowing</code> and <code>inout</code> are more straightforward, because they work similarly to parameters that have copyable value types: neither consumes the value, so the main difference is that <code>borrowing</code> parameters can only look at the argument (not change it), whereas <code>inout</code> parameters are allowed to change the argument. As noted above, this is like the difference between <code>const FileHandle&amp;</code> and <code>FileHandle&amp;</code> in C++. However, Swift has more safeguards here, because it's going to ensure that a mutable reference to a value is unique. To explain, let's return to our old friend from the <a href="../swift-for-cxx-practitioners-value-types/">value types post</a>, the Law of Exclusivity.</p><h3>The Law of Exclusivity, again</h3><p>Swift's Law of Exclusivity says that a mutable reference to a value can only exist if it is the only place referencing the value. If you have an <code>inout</code> parameter, Swift will ensure that nobody else can access (read <em>or</em> write) the argument for the duration of the call. An example I used before is a mutating <code>swap</code> method on value types, shown here with the "conflicting access" error when code tries to violate this law:</p><pre><code><span class="number">26</span> │   <span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="number">27</span> │   <span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
<span class="number">28</span> │   p1.<span class="call">swapX</span>(&amp;p1)
   │   │        ╰─ note: conflicting access <span class="keyword">is</span> here
   │   ╰─ error: overlapping accesses to 'p1', but modification requires exclusive access; consider copying
 to a local variable
<span class="number">29</span> │ 
</code></pre><p><code>inout</code> behaves the same way for copyable types and non-copyable types: you need to have exclusive access to the argument to pass it as <code>inout</code>. <code>consuming</code> parameters (of non-copyable type) are the same way: you must have exclusive ownership to be able to transfer that ownership to the parameter. <code>borrowing</code> parameters, on the other hand, don't need exclusive access: you can have many borrows (readers) of the same value at the same time, so long as there are no inouts or consumes of that value (since those can mutate the value).</p><p>As an example, let's imagine a <code>merge</code> function to merge the contents of two files into a third file, with this signature:</p><pre><code><span class="keyword">func</span> merge(
  <span class="keyword">_</span> first: borrowing <span class="type">FileHandle</span>,
  and second: borrowing <span class="type">FileHandle</span>,
  into result: <span class="keyword">inout</span> <span class="type">FileHandle</span>
) {
  <span class="comment">// ...</span>
}
</code></pre><p>Let's say we have three file handles, named <code>f1</code>, <code>f2</code>, and <code>f3</code>:</p><pre><code><span class="keyword">let</span> f1 = <span class="type">FileHandle</span>(filename: <span class="string">"1.txt"</span>)
<span class="keyword">let</span> f2 = <span class="type">FileHandle</span>(filename: <span class="string">"2.txt"</span>)
<span class="keyword">var</span> f3 = <span class="type">FileHandle</span>(filename: <span class="string">"3.txt"</span>)
</code></pre><p>It's fine to merge <code>f1</code> and <code>f2</code> into <code>f3</code>, e.g.,</p><pre><code><span class="call">merge</span>(f1, and: f2, into: &amp;f3)
</code></pre><p>and, because the first two parameters are borrowing, to merge a file into itself to produce a third output:</p><pre><code><span class="call">merge</span>(f1, and: f1, into: &amp;f3) <span class="comment">// okay</span>
</code></pre><p>However, trying to alias the third parameter with either of the first two parameters will produce an error:</p><pre><code><span class="number">48</span> |   <span class="call">merge</span>(f1, and: f3, into: &amp;f3)
   |                  |         `- error: overlapping accesses to 'f3', but modification requires exclusive access
   |                  `- note: conflicting access <span class="keyword">is</span> here
</code></pre><p>The same applies with <code>consuming</code> operations. For example, perhaps we have a merge-and-close function with this signature:</p><pre><code><span class="keyword">func</span> mergeAndClose(
  <span class="keyword">_</span> first: borrowing <span class="type">FileHandle</span>,
  and second: borrowing <span class="type">FileHandle</span>,
  into result: consuming <span class="type">FileHandle</span>
) {
  <span class="comment">// ...</span>
}
</code></pre><p>Again, it's fine to merge-and-close <code>f1</code> and <code>f2</code> into <code>f3</code>, or merge-and-close <code>f1</code> and itself into <code>f3</code>, because such a call borrows the first two arguments and consumes the third. However, one cannot alias the first or second arguments with the third, consumed argument:</p><pre><code><span class="number">56</span> |   <span class="call">mergeAndClose</span>(f1, and: f3, into: f3)
   |                          |         `- error: overlapping accesses to 'f3', but deinitialization requires exclusive access
   |                          `- note: conflicting access <span class="keyword">is</span> here
<span class="number">57</span> | }
</code></pre><p>As the error message notes, this call is ending the lifetime of <code>f3</code>. One cannot access it's value after the call, but because it is a <code>var</code>, it can still be reassigned to a new value:</p><pre><code>f3 = <span class="type">FileHandle</span>(filename: <span class="string">"otherfile.txt"</span>)
</code></pre><p>The Law of Exclusivity, which is crucial to Swift's memory-safety story, encompasses noncopyable types and well as copyable types. In the earlier discussion of the Law of Exclusivity, I'd said that it's mostly invisible to Swift programmers, because the Swift language model introduces copies in many places to avoid exclusivity violations. With noncopyable types, we can't copy our way out of potential exclusivity violations, so you're likely to encounter more compiler errors intended to guide you to verifiably correct, unique ownership of resources.</p><h3>RAII with non-copyable types</h3><p>Earlier, I warned against using Swift classes for the Resource Acquisition Is Initialization (RAII) idiom that we're accustomed to in C++, because the easy of copying and the Swift compiler's reference-counting optimizations can make lifetimes less predictable than in C++, at least for those who have internalized C++'s lifetime rules.</p><p>However, Swift's noncopyable types are much more suitable for RAII, because the lifetimes of noncopyable values are predictable: there are no extraneous copies, and the lifetime ends either when the value is consumed or goes out of scope. One cannot accidently use a value after its lifetime has ended (because the compiler checks for that), and code can document its intention to end the lifetime of a value earlier with a <code>consume</code> expression.</p><h2>Non-copyable types and generics</h2><p>Most types in Swift are copyable by default, and one can opt out of copyability with the <code>~Copyable</code> syntax. The same holds true for generic parameters: they are considered to be <code>Copyable</code> unless one explicitly opts out. Let's revisit our <a href="../swift-for-cxx-practitioners-generics">first generic function</a>, the identity function, with this in mind. The following function</p><pre><code><span class="keyword">func</span> identity&lt;T&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span> {
  <span class="keyword">return</span> value
}
</code></pre><p>is treated as if one had written a <code>Copyable</code> constraint on <code>T</code>, like this:</p><pre><code><span class="keyword">func</span> identity&lt;T: <span class="type">Copyable</span>&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span> {
  <span class="keyword">return</span> value
}
</code></pre><p>Attempting to call this function with an instance of <code>FileHandle</code> will, therefore, produce an error like this:</p><pre><code><span class="number">67</span> |   <span class="keyword">let</span> f = <span class="type">FileHandle</span>(filename: <span class="string">"1.txt"</span>)
<span class="number">68</span> |   <span class="call">identity</span>(f)
   |   `- error: global function 'identity' requires that '<span class="type">FileHandle</span>' conform to '<span class="type">Copyable</span>'
</code></pre><p>We can generalize <code>identity</code> to make it work with non-copyable types by <em>suppressing</em> the implicit requirement that <code>T</code> conform to <code>Copyable</code> with the same <code>~Copyable</code> syntax, like this:</p><pre><code><span class="keyword">func</span> identity&lt;T: ~<span class="type">Copyable</span>&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span> {
  <span class="keyword">return</span> value
}
</code></pre><p>Written this way, the compiler will produce an error because it doesn't know what parameter passing convention to apply to the <code>value</code> parameter:</p><pre><code><span class="number">62</span> | <span class="keyword">func</span> identity&lt;T: ~<span class="type">Copyable</span>&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span> {
   |                                      |- error: parameter of noncopyable type '<span class="type">T</span>' must specify ownership
   |                                      |- note: add 'borrowing' <span class="keyword">for</span> an immutable reference
   |                                      |- note: add '<span class="keyword">inout</span>' <span class="keyword">for</span> a mutable reference
   |                                      `- note: add 'consuming' to take the value from the caller
<span class="number">63</span> |   <span class="keyword">return</span> value
<span class="number">64</span> | }
</code></pre><p>For this function, <code>consuming</code> is the only option that makes sense, and adding that annotation allows us to pass a <code>FileHandle</code> instance into the <code>identity</code> function.</p><h3>Non-copyable is NOt Necessarily Copyable</h3><p>The generalization of the <code>identity</code> function does not require <code>T</code> to be <code>Copyable</code>, so it must ensure that the value is uniquely owned. That means attempts to copy the same value twice will produce a compiler error, just like in non-generic code:</p><pre><code><span class="number">71</span> | <span class="keyword">func</span> badIdentity&lt;T: ~<span class="type">Copyable</span>&gt;(<span class="keyword">_</span> value: consuming <span class="type">T</span>) -&gt; <span class="type">T</span> {
   |                                  `- error: 'value' consumed more than once
<span class="number">72</span> |   <span class="keyword">let</span> firstCopy = value
   |                   `- note: consumed here
<span class="number">73</span> |   <span class="keyword">let</span> secondCopy = value
   |                    `- note: consumed again here
<span class="number">74</span> |   <span class="keyword">return</span> firstCopy
<span class="number">75</span> | }
</code></pre><p>The fact that the type argument for <code>T</code> is not required to be <code>Copyable</code> doesn't mean that it can't be <code>Copyable</code>, though: the generalized <code>identity</code> really is more general, because it allows both copyable and non-copyable types. When used with a <code>Copyable</code> type like <code>String</code>, the copy operations will simply never be used within the generic function. This is why Swift uses the tilde (<code>~</code>) rather than something that implies the actual opposite, like <code>!</code> or <code>-</code>. Even so, the phrase "non-copyable type" sounds more restrictive than it is: when dealing with generics, it's really that they are NOt Necessarily Copyable (but it's okay if they are).</p><p>One side benefit of generalizing a generic function to support non-copyable types is that it guarantees that all copying operations (which can involve reference counting) are completely eliminated. That can provide a stronger performance guarantee than one can get when relying on compiler optimizations to remove reference-counting overhead. It's not likely to matter for small generic functions, but for more complicated algorithms it can force one to write them in a way that eliminates all extraneous copies.</p><h3>Conditionally-copyable generic types</h3><p>Generic types can opt out of the implicit <code>Copyable</code> conformance in the same way as non-generic types can. For example, we can create a <code>Pair</code> type that is non-copyable:</p><pre><code><span class="keyword">struct</span> NCPair&lt;T, U&gt;: ~<span class="type">Copyable</span> {
  <span class="keyword">var</span> first: <span class="type">T</span>
  <span class="keyword">var</span> second: <span class="type">U</span>
}
</code></pre><p>Here, we have made every instance of <code>NCPair</code> non-copyable. That is fine, but the type still requires its generic arguments to be <code>Copyable</code> (due to the implicit requirement) making <code>NCPair</code> itself unusable with non-copyable types like <code>FileHandle</code>. It would be far better to suppress the <code>Copyable</code> requirement on its argument types, <code>T</code> and <code>U</code>, to produce a pair type that can aggregate non-copyable types:</p><pre><code><span class="keyword">struct</span> Pair&lt;T: ~<span class="type">Copyable</span>, U: ~<span class="type">Copyable</span>&gt;: ~<span class="type">Copyable</span> {
  <span class="keyword">var</span> first: <span class="type">T</span>
  <span class="keyword">var</span> second: <span class="type">U</span>
}
</code></pre><p>This <code>Pair</code> type can be specialized for both copyable and non-copyable types, e.g., <code>Pair&lt;Int, FileHandle&gt;</code>, but is always non-copyable. That is still too strict: there is no reason why a <code>Pair</code> of two copyable types (say, <code>Pair&lt;Int, String&gt;</code>) should be restricted to be non-copyable. Indeed, we can express the actual semantics here with a conditional conformance that makes <code>Pair</code> <code>Copyable</code> when both of its argument types are non-copyable, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span>: <span class="type">Copyable</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Copyable</span>, <span class="type">U</span>: <span class="type">Copyable</span> { }
</code></pre><p>Such a type is called a <em>conditionally-copyable type</em>, because it is sometimes copyable and sometimes not. Conditionally-copyable types are great for low-level generic libraries where some clients might opt to use them with non-copyable types (for stronger ownership and performance guarantees) while also allowing clients to use copyable types (that are generally simpler to learn and program with). The Swift standard library provides conditionally-copyable types for core types like <code>Optional</code>.</p><h3>Extending generic types with noncopyable generic parameters</h3><p>There's one thing to be aware of when extending generic types with non-copyable generic parameters: the implicit copyability requirement applies to the generic parameters of the extended generic type unless it is actively suppressed. So if we extend the generic <code>Pair</code> above like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> {
  <span class="comment">// ...</span>
}
</code></pre><p>then it is equivalent to having written a constrained extension like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Copyable</span>, <span class="type">U</span>: <span class="type">Copyable</span> {
  <span class="comment">// ...</span>
}
</code></pre><p>If our extension had added a conformance to a protocol, the conformance would be conditional on the generic arguments to <code>T</code> and <code>U</code> being <code>Copyable</code>. This behavior is consistent with the rule stated previously, that generic parameters require <code>Copyable</code> arguments unless specified otherwise.</p><p>To extend <em>every</em> instance of <code>Pair</code>, one can suppress the <code>Copyable</code> requirements the same way one does for a generic function:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> <span class="keyword">where</span> <span class="type">T</span>: ~<span class="type">Copyable</span>, <span class="type">U</span>: ~<span class="type">Copyable</span> {
  <span class="comment">// ...</span>
}
</code></pre><p>Any members within such an extension will need to work with <code>T</code>, <code>U</code>, and the type <code>Pair&lt;T, U&gt;</code> as non-copyable types, but will of course still be usable if <code>T,</code>, <code>U</code>, or both happen to be <code>Copyable</code>.</p><h3>Noncopyable protocols</h3><p>Finally, protocols can also suppress copyability with <code>~Copyable</code>, which will allow non-copyable types to conform to them:</p><pre><code><span class="keyword">protocol</span> DebugPrint: ~<span class="type">Copyable</span> {
  <span class="keyword">func</span> debugPrint()
}

<span class="keyword">extension</span> <span class="type">Pair</span>: <span class="type">DebugPrint</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">DebugPrint</span> &amp; ~<span class="type">Copyable</span>, <span class="type">U</span>: <span class="type">DebugPrint</span> &amp; ~<span class="type">Copyable</span> {
  <span class="keyword">func</span> debugPrint() {
    first.<span class="call">debugPrint</span>()
    second.<span class="call">debugPrint</span>()
  }
}
</code></pre><p>The best way to think of a non-copyable protocol is to recall that every protocol has an implicit type parameter named <code>Self</code> that conforms to that protocol. For a non-copyable protocol, the implicit <code>Self</code> parameter is not necessarily copyable, i.e., the protocol has the requirement <code>Self: ~Copyable</code>. All of the other behaviors with respect to non-copyable protocols fall out from that definition. For example, an extension of <code>DebugPrint</code> will have the implicit requirement <code>Self: Copyable</code> unless explicitly suppressed with <code>Self: ~Copyable</code>, as will any protocol that inherits from <code>DebugPrint</code>.</p><h2>Whither perfect forwarding?</h2><p>I noted in the beginning that Swift does not have an equivalent to C++'s "perfect forwarding"' construct with rvalue references. The rest of this section will describe "why", for folks interested in the language design aspects of it. If you're not interested, feel free to skip ahead to the conclusion :)</p><p>Still here? Okay. Perfect forwarding in a C++ function template passes on the type, const-ness, and lvalue-or-rvalue-ness of an argument along when making another function call, such as in this <code>apply</code> template:</p><pre><code>template&lt;typename <span class="type">F</span>, typename ...<span class="type">T</span>&gt;
void <span class="call">apply</span>(<span class="type">F</span> &amp;&amp;f, <span class="type">T</span> &amp;&amp;...t) {
  std::forward&lt;<span class="type">F</span>&gt;(f)(std::forward&lt;<span class="type">T</span>&gt;(t)...);
}
</code></pre><p>In Swift, we can express the notion of taking a function with an arbitrary number of parameters that we then forward, like this:</p><pre><code><span class="keyword">func</span> apply&lt;each <span class="type">T</span>&gt;(<span class="keyword">_</span> f: (repeat each <span class="type">T</span>) -&gt; <span class="type">Void</span>, <span class="keyword">_</span> t: <span class="keyword">repeat</span> each <span class="type">T</span>) {
  <span class="call">f</span>(repeat each t)
}
</code></pre><p>However, this only works for copyable types passed by-value: attempting to pass in a function for <code>f</code> that uses <code>inout</code>, or noncopyable types (which must use <code>borrowing</code> or <code>consuming</code> for their convention) will match the function type <code>(repeat each T) -&gt; Void</code> because the parameter passing convention isn't part of the type <code>T</code>: it's a separate aspect of each parameter.</p><p>There is a similar limitation in C++ that can illustrate this idea of a missing abstraction mechanism. Imagine that you want to implement the C++ standard library's <code>is_member_function_pointer</code> by partial specialization to recognize all member function pointer types. You might start like this:</p><pre><code>template&lt;typename <span class="type">T</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer : bool_constant&lt;<span class="keyword">false</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...)&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };
</code></pre><p>This almost works, accounting for any class type, any return type, and any number of parameters including their types and (because <code>const</code>, <code>volatile</code>, and references are part of the type system) parameter-passing conventions. But this doesn't handle <code>const</code> or <code>volatile</code> member functions, or ones where <code>*this</code> is an rvalue reference, because there's no way to abstract over the <code>*this</code> parameter in C++. You have to provide partial specializations for <em>all</em> combinations:</p><pre><code>template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) volatile&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const volatile&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const &amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) volatile &amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const volatile &amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const &amp;&amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) volatile &amp;&amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };

template&lt;typename <span class="type">R</span>, typename <span class="type">C</span>, typename ...<span class="type">Args</span>&gt;
<span class="keyword">struct</span> is_member_function_pointer&lt;R (<span class="type">C</span>::*)(<span class="type">Args</span>...) const volatile &amp;&amp;&gt; : bool_constant&lt;<span class="keyword">true</span>&gt; { };
</code></pre><p>Yuck. This is the same issue Swift has with parameter-passing conventions, just applied to <code>*this</code> in C++.</p><p>However, there's another complication in Swift: the parameter passing convention is part of a parameter, not part of its type, because there is no way to abstract over parameter passing in a manner that allows separate type checking: a <code>borrowing</code> parameter works very differently from a <code>consuming</code> or <code>inout</code> one, so there's very little one could do without knowing the convention. We actually see this in C++ as well: it's actually quite hard to implement a template that works properly with normal types as well as reference types, because they act so differently once instantiated. So, Swift would need to grow an abstraction over how the parameter is passed that provides meaningful semantics for any of the conventions while maintaining separate type checking.</p><h2>When to use non-copyable types</h2><p>Non-copyable types offer guaranteed unique ownership over a resource with zero runtime overhead, providing more safety and better usability than move-only types in C++. There are three situations in which non-copyable types are most appropriate:</p><ul><li>Unique ownership of a resource: if you need a resource to be uniquely owned and never shared.</li><li>RAII: if you need to scope the ownership of a resource to a lexical block and reason specifically about where it will be freed.</li><li>Zero overhead: if you need to ensure that a value is never copied unnecessarily, for example to guarantee that a section of code has no extraneous reference counting.</li></ul><p>Non-copyable types should be considered an advanced feature in Swift, and should be used only when the benefits outweigh the additional complexity that non-copyability introduces. Most Swift code should continue using copyable types, and Swift's defaults (including for conditionally-copyable types) intentionally skew toward using copying to maintain local reasoning and a simpler programmer model for most users.</p></div><span>Tagged with: </span><ul class="tag-list"><li><a href="/tags/swift">Swift</a></li><li><a href="/tags/c">C++</a></li></ul></article></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>