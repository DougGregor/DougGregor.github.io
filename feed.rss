<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Doug's Compiler Corner</title><description>Musings on programming languages and compilers.</description><link>https://www.douggregor.net</link><language>en</language><lastBuildDate>Thu, 11 Apr 2024 09:25:16 -0400</lastBuildDate><pubDate>Thu, 11 Apr 2024 09:25:16 -0400</pubDate><ttl>250</ttl><atom:link href="https://www.douggregor.net/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure</guid><title>Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes</title><description>Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes</description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-type-erasure</link><pubDate>Thu, 11 Apr 2024 10:14:00 -0400</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 5: Type erasure &amp; metatypes</h1><p>What do you do in C++ when you want to support different types, but don't want to have one template instantiation per type? Yes, you can introduce a class hierarchy with virtual functions, but more often a better answer is to use <em>type erasure</em>. Type erasure is a mechanism for <em>runtime polymorphism</em>, allowing you to provide different types at runtime while using the same code expressed with a single, concrete type. The C++ standard library contains two type-erased utility types: <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a> and <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>. In both cases, you can have a concrete value whose underlying type can change:</p><pre><code>std::any a = <span class="number">17</span>;              <span class="comment">// okay, stores an int</span>
a = std::<span class="call">string</span>(<span class="string">"hello"</span>);     <span class="comment">// now it stores a std::string!</span>

std::function&lt;<span class="call">int</span>(int, int)&gt; op = [](int a, int b) { <span class="keyword">return</span> a + b; }; <span class="comment">// okay, it adds integers</span>
op = [](int a, int b) { <span class="keyword">return</span> a * b; }                               <span class="comment">// now it multiplies them!</span>
</code></pre><p>Type erasure in C++ has been around for a long time, and it's a useful technique. <a href="https://www.boost.org/doc/libs/1_84_0/doc/html/any.html">Boost.Any</a> popularized the idea, and now there are numerous blog posts describing implementation techniques and C++ libraries implementing them.</p><p>In Swift, it's part of the language, and you can type-erase any protocol using the keyword <code>any</code>. In this post, we're going to dive into how Swift handles type erasure, and explore related features like <em>metatypes</em> and <em>opaque types</em>.</p><h2>The basics of type erasure</h2><p>For example, let's bring back that the <code>Quantifiable</code> protocol from the last post. It looked like this:</p><pre><code><span class="keyword">protocol</span> Quantifiable {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span>
}
</code></pre><p>One can conform types to <code>Quantifiable</code> and write generic algorithms using <code>Quantifiable</code> as a constraint. If we want to use runtime polymorphism to store a value of any <code>Quantifiable</code> type, we can do so with <code>any Quantifiable</code> like this:</p><pre><code><span class="keyword">var</span> q: any <span class="type">Quantifiable</span> = <span class="number">1</span>   <span class="comment">// okay, Int conforms to Quantifiable</span>
<span class="call">print</span>(q.<span class="call">cost</span>())               <span class="comment">// can use the members of the Quantifiable protocol</span>

q = <span class="string">"Hello"</span>                   <span class="comment">// okay, String conforms to Quantifiable</span>
</code></pre><p>You can think of the type of <code>q</code> as being "anything that is <code>Quantifiable</code>": the actual type isn't known until runtime, and can change by reassigning the variable to another value with a different type.</p><p>One can compose multiple protocols together using the <code>&amp;</code> sign. For example, a value of type <code>any Quantifiable &amp; Describable</code> can hold a value of any type that conforms to both <code>Quantifiable</code> and <code>Describable</code>, and you can use any operations that are available to a <code>Describable</code> type or <code>Quantifiable</code> type:</p><pre><code><span class="keyword">var</span> dq: any <span class="type">Quantifiable</span> &amp; <span class="type">Describable</span> = <span class="number">1</span>
dq.<span class="call">cost</span>()
dq.<span class="call">describe</span>()
</code></pre><p>The Swift equivalent to <code>std::any</code> is called, simply, <code>Any</code>: it is effectively an <code>any</code> type with no protocols listed, so it can store a value of any type in it. Now, just like with <code>std::any</code>, you can't do much with a value of type <code>Any</code> other than copy it around, because there are aren't many operations that work on all types.</p><h2>Dynamic casting</h2><p>One thing you can do with values of <code>Any</code> type is to perform a runtime check of the actual stored type. This is accomplished with the same <code>as?</code> cast we introduced for downcasting to a subclass. For example, here's a function that checks whether a value of type <code>Any</code> is actually an <code>Int</code>:</p><pre><code><span class="keyword">func</span> maybeIntValue(<span class="keyword">_</span> value: <span class="type">Any</span>) -&gt; <span class="type">Int</span>? {
  <span class="keyword">if let</span> integer = value <span class="keyword">as</span>? <span class="type">Int</span> {
    <span class="keyword">return</span> integer
  }
  
  <span class="keyword">return nil</span>
}
</code></pre><p>The same works for <code>switch</code> statements, where a <code>case</code> can use the <code>as</code> operator to apply only when a dynamic cast to the type succeeds. Here's a <code>switch</code> to identify a number of concrete types:</p><pre><code><span class="keyword">func</span> whatAmI(<span class="keyword">_</span> value: <span class="type">Any</span>) {
  <span class="keyword">switch</span> value {
    <span class="keyword">case let</span> bool <span class="keyword">as</span> <span class="type">Bool</span>: <span class="call">print</span>(<span class="string">"Bool</span> \(bool)<span class="string">"</span>)
    <span class="keyword">case let</span> integer <span class="keyword">as</span> <span class="type">Int</span>: <span class="call">print</span>(<span class="string">"Integer</span> \(integer)<span class="string">"</span>)
    <span class="keyword">case let</span> double <span class="keyword">as</span> <span class="type">Double</span>: <span class="call">print</span>(<span class="string">"Double</span> \(double)<span class="string">"</span>)
    <span class="keyword">case let</span> string <span class="keyword">as</span> <span class="type">String</span>: <span class="call">print</span>(<span class="string">"String</span> \(string)<span class="string">"</span>)
    <span class="keyword">default</span>: <span class="call">print</span>(<span class="string">"I don't know what this is"</span>)
  }
}
</code></pre><p>Such a <code>switch</code> must have a <code>default</code> clause, because there's no way to enumerate every type. The Swift compiler will produce an error <code>switch must be exhaustive</code> if you forget.</p><p>One particularly important aspect of dynamic casting is that you can cast to an <code>any</code> type, which lets you discover the capabilities of a value at runtime. For example, one can cast to <code>any Quantifiable</code> to determine whether a value conforms to <code>Quantifiable</code>.</p><pre><code><span class="keyword">var</span> value: <span class="type">Any</span> = <span class="number">1</span>
<span class="keyword">if let</span> q = value <span class="keyword">as</span>? any <span class="type">Quantifiable</span> {
  <span class="call">print</span>(<span class="string">"Cost is</span> \(q.<span class="call">cost</span>())<span class="string">"</span>)
}
</code></pre><p>Dynamic casting allows one to rediscover type information that has been remove by type erasure. It's common in very dynamic programs where values are dynamically produced in one place, such as via a global registry or deserialization, and consumed elsewhere. To build something like that, which dynamically creates values of potentially unknown type, we need one more Swift feature: metatypes.</p><h2>Metatypes</h2><p>In the prior post on generics, I noted that Swift doesn't have an equivalent to the <code>decltype</code> type in C++. Swift does, however, have a function named <code>type(of:)</code>, which produces the type of its argument. However, it's not producing a type, but a value representing the type, i.e., a <em>metatype</em>.</p><p>Metatypes in Swift are spelled with the <code>.Type</code> suffix, so if we have a type <code>Point</code>:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  
  <span class="keyword">static var</span> origin: <span class="type">Double</span> = <span class="type">Person</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)
}
</code></pre><p>The metatype of <code>Point</code> has the type <code>Point.Type</code>. One can form a value of this type with the expression <code>Point.self</code>.</p><pre><code><span class="keyword">let</span> pointType: <span class="type">Point</span>.<span class="type">Type</span> = <span class="type">Point</span>.<span class="keyword">self</span>
</code></pre><p>What can you do with a metatype? For one thing, you can access static methods and properties, or call an initializer of that type to produce a new value, like this:</p><pre><code><span class="keyword">let</span> point = pointType.<span class="keyword">init</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>)
<span class="keyword">let</span> origin = pointType.<span class="property">origin</span>
</code></pre><p>Technically, when you write <code>Point(x: 0.0, y: 0.0)</code>, you're using syntactic sugar for <code>PointType.self.init(x: 0.0, y: 0.0)</code>.</p><p>The <code>type(of:)</code> operation has this generic signature:</p><pre><code><span class="keyword">func</span> type&lt;T&gt;(of value: <span class="type">T</span>) -&gt; <span class="type">T</span>.<span class="type">Type</span>
</code></pre><p>So if we pass an instance of <code>Point</code> to <code>type(of:)</code>, we get back a <code>Point.Type</code> instance.</p><h3>Class metatypes</h3><p>Metatypes of structs and enums, by themselves, aren't very interesting, because you could generally just refer to the type. With classes, metatypes become a lot more interesting because an instance of class type could actually store one of its subclasses. Let's build a small class hierarchy:</p><pre><code><span class="keyword">class</span> Person {
  <span class="keyword">var</span> name: <span class="type">String</span>
  
  <span class="keyword">required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
  }
  
  <span class="keyword">class var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"PERSON"</span>}
}

<span class="keyword">class</span> Programmer: <span class="type">Person</span> {
  <span class="keyword">var</span> favoriteLanguage: <span class="type">String</span>? = <span class="keyword">nil
  
  required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, favoriteLanguage: <span class="keyword">nil</span>)
  }
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, favoriteLanguage: <span class="type">String</span>?) {
    <span class="keyword">self</span>.<span class="property">favoriteLanguage</span> = favoriteLanguage
	  <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)
  }
  
  <span class="keyword">override class var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"PROGRAMMER"</span> }
}
</code></pre><p>Please ignore the <code>required</code> and <code>class var</code> for the moment---we'll get there shortly. First, let's imagine that we have a <code>person</code> instance, and we ask for its type via <code>type(of: person)</code>:</p><pre><code><span class="keyword">var</span> person: <span class="type">Person</span> = <span class="comment">/*build some kind of person */</span>
<span class="keyword">var</span> personType: <span class="type">Person</span>.<span class="type">Type</span> = <span class="call">type</span>(of: person)
</code></pre><p>Statically, the type of <code>person</code> can only be expressed as <code>Person.Type</code>. But dynamically, the <code>person</code> instance can store a <code>Person</code> object, or a <code>Programmer</code> object, or any instance of any other subclass of <code>Person</code>. The <code>type(of:)</code> operation produces a value of (static) type <code>Person.Type</code>, which dynamically could be <code>Person.self</code>, <code>Programmer.self</code>, or any other subclass's metatype. It's obvious, and a little mind-bending, but then it's obvious again.</p><p>What can we do with a metatype? For one, we can use <code>class</code> methods and properties, which are the overridable equivalent of <code>static</code> methods and properties. (Within a class, <code>static</code> is a synonym for <code>class final</code>). For example, the following:</p><pre><code><span class="call">print</span>(personType.<span class="property">serializecClassName</span>)
</code></pre><p>If <code>person</code> dynamically stores a <code>Person</code> instance, the metatype in <code>personType</code> will be <code>Person.self</code>, and it'll print <code>PERSON</code>. If <code>person</code> dynamically stores a <code>Programmer</code> instance, the metatype in <code>personType</code> will be <code>Programmer.self</code> and it'll print <code>PROGRAMMER</code>.</p><p>We can also initialize a new object by calling <code>personType.init(name:)</code>:</p><pre><code><span class="keyword">let</span> newPerson = personType.<span class="keyword">init</span>(name: <span class="string">"Doug"</span>)
</code></pre><p>and <code>newPerson</code> will have the same type as <code>person</code>. Note that this needs the initializer to be marked <code>required</code>: a <code>required</code> initializer must be implemented by every subclass. They're also needed to satisfy <code>init</code> requirements of a protocol to which the class conforms. For example:</p><pre><code><span class="keyword">protocol</span> InitByName {
  <span class="keyword">init</span>(name: <span class="type">String</span>)
}

<span class="keyword">extension</span> <span class="type">Person</span>: <span class="type">InitByName</span> { 
  <span class="comment">// okay, because init(name:) is a required initializer</span>
}
</code></pre><p>Why do we need <code>required</code>? Making <code>Person</code> conform to <code>InitByName</code> implies that every subclass of <code>Person</code> also conforms to <code>InitByName</code>, because one should always be able to substitute an instance of a subclass where the superclass was expected (this is the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov Substitution Principle</a>). That means you need to be able to create an instance of any subclass by calling <code>init(name:)</code>. Making an initializer <code>required</code> ensures that all subclasses (and subclasses of subclasses, and so on) implement it.</p><p>At this point, we could build a simple registry mapping from the serialized class names to actual <code>Person</code> types:</p><pre><code><span class="keyword">var</span> knownPersonTypes: [<span class="type">String</span>: <span class="type">Person</span>.<span class="property">type</span>] = [:]

<span class="keyword">func</span> addPersonType(<span class="keyword">_</span> personType: <span class="type">Person</span>.<span class="type">Type</span>) {
  knownPersonTypes[personType.<span class="property">serializedTypeName</span>] = personType
}

<span class="call">addPersonType</span>(<span class="type">Person</span>.<span class="keyword">self</span>)
<span class="call">addPersonType</span>(<span class="type">Programmer</span>.<span class="keyword">self</span>)
</code></pre><p>Then we can build a <code>Person</code> instance based on the serialized name and the <code>name</code> field:</p><pre><code><span class="keyword">func</span> instantiatePerson(className: <span class="type">String</span>, name: <span class="type">String</span>) -&gt; <span class="type">Person</span>? {
  knownPersonTypes[className]?.<span class="keyword">init</span>(name: name)
}
</code></pre><h3><code>any</code> metatypes</h3><p>Class metatypes opened up the ability to use dynamic dispatch via subclassing, but there's a more general way: metatypes work with <code>any</code>, so we can express the "type of a some type that conforms to a protocol." For example, a value of type <code>any InitByName.Type</code> stores the metatype for some type that conforms to <code>InitByName</code>. That can be <code>Person</code> (or any of its subclasses), or some <code>struct</code> or <code>enum</code> that conforms to the protocol:</p><pre><code><span class="keyword">struct</span> Fruit: <span class="type">InitByName</span> {
	<span class="keyword">var</span> name: <span class="type">String</span>
  <span class="keyword">static var</span> serializedTypeName: <span class="type">String</span> { <span class="string">"FRUIT"</span> }
}
</code></pre><p>The same registry code from before works just as well when we generalize <code>Person</code> to <code>any InitByName</code>. Here it is:</p><pre><code><span class="keyword">var</span> knownTypes: [<span class="type">String</span>: any <span class="type">InitByName</span>.<span class="type">Type</span>] = [:]

<span class="keyword">func</span> addInitByNameType(<span class="keyword">_</span> type: any <span class="type">InitByName</span>.<span class="type">Type</span>) {
  knownTypes[type.<span class="property">serializedTypeName</span>] = type
}

<span class="keyword">func</span> instantiate(typeName: <span class="type">String</span>, name: <span class="type">String</span>) -&gt; (any <span class="type">InitByName</span>)? {
  knownTypes[typeName]?.<span class="keyword">init</span>(name: name)
}
</code></pre><p>Note how the result of calling the initializer of a value of type <code>any InitByName.Type</code> is a value of type <code>any InitByName</code>. We don't know what metatype will be stored in the <code>any InitByName.Type</code> (although we could check with <code>as?</code> or a <code>case</code>), but we do know that its instance will conform to <code>InitByName</code>, so it's represented as <code>any InitByName</code>.</p><h3>Explicitly-specified generic function arguments</h3><p>C++ allows you to explicitly specify the template arguments for a function template. C++ libraries tend to make use of this feature when a type should be explicitly specified by the caller. For example, imagine a "numeric cast" template like this:</p><pre><code>template&lt;typename <span class="type">To</span>, typename <span class="type">From</span>&gt;
<span class="type">To</span> <span class="call">numeric_cast</span>(const <span class="type">From</span>&amp; from);
</code></pre><p>In C++, the template argument for <code>To</code> can't be inferred by a normal call like <code>numeric_cast(d)</code>, so we explicitly specify the type at the call site, e.g.,:</p><pre><code>double d = <span class="number">17.0</span>;
int x = numeric_cast&lt;int&gt;(d);
</code></pre><p>Now, Swift is actually a bit different here. We can write essentially the same generic function:</p><pre><code><span class="keyword">func</span> numericCast&lt;To: <span class="type">Numeric</span>, From: <span class="type">Numeric</span>&gt;(<span class="keyword">_</span> value: <span class="type">From</span>) -&gt; <span class="type">To</span>
</code></pre><p>but it's going to behave differently at the call site. Swift's type inference uses more contextual cues that C++'s template argument deduction, so a call like this will work fine in Swift:</p><pre><code><span class="keyword">let</span> x: <span class="type">Int</span> = <span class="call">numericCast</span>(d)
</code></pre><p>If you don't have type context to infer the type, i.e., if you just write:</p><pre><code><span class="call">numericCast</span>(d)  <span class="comment">// type inference fails to find a `To` type</span>
</code></pre><p>then type inference will fail to infer a <code>To</code> type. An <code>as</code> coercion can fix this:</p><pre><code><span class="call">numericCast</span>(d) <span class="keyword">as</span> <span class="type">Int</span>
</code></pre><p>Given that type inference usually figures out the types for us, and Swift already has the general notion of using <code>as</code> to provide type information when it doesn't, Swift never got the ability to explicitly provide generic arguments for functions. <code>numericCast&lt;Int&gt;(d)</code> is an error in Swift.</p><p>But what if you <em>want</em> to require the type to be specified at the call site, and not rely entirely on type inference? Turns out that you can use metatypes, and the result is really nice:</p><pre><code><span class="keyword">func</span> numericCast&lt;From: <span class="type">Numeric</span>, To: <span class="type">Numeric</span>&gt;(<span class="keyword">_</span> value: <span class="type">From</span>, to type: <span class="type">To</span>.<span class="type">Type</span>) -&gt; <span class="type">To</span>
</code></pre><p>Here, we've added a <code>to</code> parameter of the metatype of <code>To</code>. The user specifies the metatype of the type to convert to at the call site, like this:</p><pre><code><span class="keyword">let</span> x = <span class="call">numericCast</span>(d, to: <span class="type">Int</span>.<span class="keyword">self</span>)
</code></pre><p>The type of <code>To</code> is inferred from the argument. It also reads really nicely: "numeric cast <code>d</code> to <code>Int</code>".</p><p>Will Swift eventually gain the ability to explicitly specify the generic arguments of a generic function? Maybe someday, but not having this feature led to the discovery of the metatype-based solution above, and I think the end result is better for readability.</p><h2>Associated types</h2><p>Associated types have some interesting interactions with type erasure. Let's explore those now, bringing back the <code>Collection</code> protocol from the prior post on Swift generics to develop these ideas further:</p><pre><code><span class="keyword">protocol</span> Collection {
  <span class="keyword">associatedtype</span> Value
  <span class="keyword">associatedtype</span> Index: <span class="type">Equatable</span>

  <span class="keyword">var</span> startIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">var</span> endIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">func</span> index(after index: <span class="type">Index</span>) -&gt; <span class="type">Index</span>
  
  <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Value</span> { <span class="keyword">get</span> }
}

<span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">var</span> first: <span class="type">Value</span>? { 
    startIndex == endIndex ? <span class="keyword">nil</span> : <span class="keyword">self</span>[startIndex]
  }
}
</code></pre><h3>Erasure of associated types</h3><p>Let's say we have a value <code>c</code> of type <code>any Collection</code>:</p><pre><code><span class="keyword">var</span> c: any <span class="type">Collection</span>
</code></pre><p>At runtime, <code>c</code> could store an <code>[Int]</code> or a <code>[String: (any InitByName).Type]</code>, or a <code>Set&lt;String&gt;</code> or any other collection. If we ask for the <code>first</code> value in <code>c</code>:</p><pre><code><span class="keyword">let</span> f = c.<span class="property">first</span>
</code></pre><p>what type should we expect to get? We know it's the <code>Value</code> type of the underlying collection, but since we don't know what the collection itself is, we don't know the <code>Value</code> type of it, either. Therefore, the type of the <code>first</code> is also type-erased by replacing each occurrence of an associated type (here, it's <code>Value</code>) with an <code>any</code> type based on the constraints placed on that associated type. There are no constraints on <code>Value</code>, so the type of <code>first</code> (<code>Value?</code>) is type-erased to <code>Any?</code>.</p><p>For an associated type like <code>Index</code> that has constraints, we'll get a more interesting resulting type: <code>Index</code> will be type-erased to <code>any Equatable</code>, so if we grab the start and end index of our collection, we'll get <code>any Equatable</code> values:</p><pre><code><span class="keyword">var</span> si = c.<span class="property">startIndex</span>   <span class="comment">// inferred type is 'any Equatable'</span>
<span class="keyword">let</span> ei = c.<span class="property">endIndex</span>     <span class="comment">// inferred type is 'any Equatable'</span>
</code></pre><p>The type erasure for associated types happens automatically, and generally means that once you've erased some type information, that type information stays erased until you do something explicit to bring type information back. Most of the time, that's fine, but it can be surprising.</p><h3>Equality of types</h3><p>Now that we have the start and end indices, it's completely reasonable that we'd want to be able to loop over the elements of our collection <code>c</code>, perhaps like this:</p><pre><code><span class="keyword">while</span> si != <span class="call">ei</span> {
  <span class="keyword">let</span> element = c.<span class="property">subscript</span>[si]
  <span class="call">doSomething</span>(element)
  si = c.<span class="call">index</span>(after: si)
}
</code></pre><p>However, this can't work. Let's focus on the <code>si != ei</code>, which is trying to use the <code>!=</code> operator from the <code>Equatable</code> protocol:</p><pre><code><span class="keyword">protocol</span> Equatable {
  <span class="keyword">static func</span> ==(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
  <span class="keyword">static func</span> !=(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
}
</code></pre><p>Remember that <code>Self</code> is the actual, concrete type that conforms to the protocol <code>Equatable</code>. When we write <code>si != ei</code>, where each of <code>si</code> and <code>ei</code> are of type <code>any Equatable</code>, the actual type for <code>Self</code> is stored inside that <code>any Equatable</code> and can vary at runtime. Here in the call, there's no static guarantee that both <code>si</code> and <code>ei</code> have the same underlying type as run-time, so the compiler has to reject the call. Otherwise, we could end up trying to compare an <code>Int</code> to a <code>String</code>, but there's no operator for that.</p><h3>Opening <code>any</code> types</h3><p>To make this work, we're going to have to <em>dynamically</em> check that both sides have the same type, <em>then</em> use their operator. Let's build a function to check equality of two distinct <code>Equatable</code> types. To do so, we're going to use generics:</p><pre><code><span class="keyword">func</span> isEqual&lt;T: <span class="type">Equatable</span>, U: <span class="type">Equatable</span>&gt;(<span class="keyword">_</span> lhs: <span class="type">T</span>, rhs: <span class="type">U</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">if let</span> rhsAsT = rhs <span class="keyword">as</span>? <span class="type">T</span> {
    <span class="keyword">return</span> lhs == rhsAsT
  }
  
  <span class="keyword">if let</span> lhsAsU = lhs <span class="keyword">as</span>? <span class="type">U</span> {
    <span class="keyword">return</span> lhsAsU == rhs
  }
  
  <span class="keyword">return false</span>
}
</code></pre><p>The types <code>T</code> and <code>U</code> could be different, so we first try to cast <code>rhs</code> to a <code>T</code>: if that succeeds, we can compare the values as <code>T</code> instances because <code>T</code> is <code>Equatable</code>. We also try in the other direction, to compare as <code>U</code> instances (via <code>U: Equatable</code>). If both fail, the types are incomparable, and we return <code>false</code>. Now, our loop condition can be</p><pre><code><span class="keyword">while</span> !<span class="call">isEqual</span>(si, ei) { ... }
</code></pre><p>But how does that <em>work</em>? We passed two <code>any Equatable</code> values (which are firmly runtime-polymorphic) into a generic function (which is statically-polymorphic), and it... just... works. This is what I meant be moving between static and dynamic polymorphism in Swift.</p><p>What's happening under the hood is called "opening" the <code>any</code> type. Effectively, the compiler is reaching in to each <code>any Equatable</code> value to pull out the concrete type, and binding the appropriate generic parameter (<code>T</code> or <code>U</code>) to that concrete type. Swift can do this due to separate compilation of generics, so the <code>isEqual</code> function implementation can work with types that aren't known until runtime.</p><p>We could write a similar function to perform the subscript of the collection, but it would be a lot easier if we turned the whole loop into a generic function on the collection. Say, a for-each operation:</p><pre><code><span class="keyword">func</span> forEach&lt;C: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> c: <span class="type">C</span>, body: (<span class="type">C</span>.<span class="type">Value</span>) -&gt; <span class="type">Void</span>) {
  <span class="keyword">var</span> si = c.<span class="property">startIndex</span>
  <span class="keyword">let</span> ei = c.<span class="property">endIndex</span>
  <span class="keyword">while</span> si != <span class="call">ei</span> {
    <span class="keyword">let</span> current = c[si]
    <span class="call">body</span>(current)
    si = c.<span class="call">index</span>(after: si)
  }
}
</code></pre><p>This operation is generic: we have a name for the collection type (<code>C</code>), and know the relationship to its <code>Value</code> and <code>Index</code> types, so we have strong type equality. We can call this function with a value of type <code>any Collection</code>:</p><pre><code><span class="call">forEach</span>(c) { element <span class="keyword">in</span>
  <span class="call">doSomething</span>(element)
}
</code></pre><p>That call opens up the type of <code>c</code>, binding it to <code>forEach</code>'s generic parameter <code>C</code>. The call itself still needs to erase the associated type, so the <code>element</code> parameter of the closure will be the type-erased <code>Value</code> type, i.e., <code>Any</code>.</p><h3>Primary associated types</h3><p>Sometimes, it can be useful to be able to make some of the associated types concrete even when using an <code>any</code> type. For example, we might want to be able to take any collection stores <code>String</code> values. We can do so with <em>primary</em> associated types, which use generic argument syntax to specify associated types. The primary associated types are listed in angle brackets following the protocol name:</p><pre><code><span class="keyword">protocol</span> Collection&lt;Value&gt; {
  <span class="keyword">associatedtype</span> Value
  <span class="keyword">associatedtype</span> Index: <span class="type">Equatable</span>
  <span class="comment">// ...</span>
}
</code></pre><p>This enables <code>any</code> types to specify the <code>Value</code> type. For example, <code>any Collection&lt;String&gt;</code> is any type that conforms to <code>Collection</code> and has <code>String</code> as its value type. A value of such a type could store a <code>[String]</code>, <code>Set&lt;String&gt;</code>, or other collection:</p><pre><code><span class="keyword">var</span> strings: any <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;
strings = [<span class="string">"Hello"</span>, <span class="string">"World"</span>]
<span class="call">print</span>(strings.<span class="property">first</span> ?? <span class="string">"Empty collection"</span>) <span class="comment">// "Hello"</span>
strings = [<span class="string">"Hello"</span>, <span class="string">"World"</span>] <span class="keyword">as</span> <span class="type">Set</span>&lt;<span class="type">String</span>&gt;
<span class="call">print</span>(strings.<span class="property">first</span> ?? <span class="string">"Empty collection"</span>) <span class="comment">// "Hello" or "World"; ordering in sets is not guaranteed</span>

strings = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// error: cannot convert value of type 'Int' to expected element type 'String'</span> 
</code></pre><p>Even when there are primary associated types, one can use <code>any</code> types without mentioning them. In such cases, the associated type will be type-erased. For example, with the above protocol, <code>any Collection</code> will have its <code>Value</code> type type-erased to <code>Any</code>.</p><p>Why did we choose to make <code>Value</code> a primary associated type and not <code>Index</code>? It's all about the use cases, and here your instincts from C++ containers will serve you well: you generally care about the value type of a container because you're operating on its elements, but its iterator type is generally not interesting except as a mechanism to get at the elements. More importantly, although you generally get to choose the value type of your container, but the iterator comes with it, so only the value type makes sense as a primary associated type.</p><h2>When to type-erase?</h2><p>Type erasure via <code>any</code> is not free: an instance of an <code>any</code> type has a fixed-sized buffer along with information about the (dynamically) stored type and each of the protocols that type conforms to. When the stored value is larger than that buffer, the <code>any</code> instance will be heap-allocated. Every operation on an instance of <code>any</code> goes through the equivalent of a <code>virtual</code> method dispatch, including copying and destruction. If you've ever looked into the implementation of <code>std::any</code> or <code>std::function</code>, you'll have a good mental model for how <code>any</code> types work under the hood in Swift, and why they aren't cheap. The Swift optimizer will do some amount of specialization of <code>any</code> types, but for it to succeed it needs to see both the creation and use of the <code>any</code> type, so it's not recommended to rely heavily on this optimization.</p><p>Use <code>any</code> types when you need to store heterogeneous data that potentially accepts any number of types. If there's a small, fixed number of types that you might store (say, a choice among a few basic types), consider using an <code>enum</code> instead:</p><pre><code><span class="keyword">enum</span> StoredValue: <span class="type">Hashable</span> {
  <span class="keyword">case</span> integer(<span class="type">Int</span>)
  <span class="keyword">case</span> floating(<span class="type">Double</span>)
  <span class="keyword">case</span> string(<span class="type">String</span>)
}
</code></pre><p>Operations on the <code>StoredValue</code> enum will be more efficient than operating on an <code>any Hashable</code> instance, because <code>StoredValue</code> is a concrete type.</p><p>More importantly, prefer generic operations to operatons on <code>any</code> values. There is no reason to have a function that accepts a single <code>any</code> value, for example:</p><pre><code><span class="keyword">func</span> operateOnAny(strings: any <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;) { ... }
</code></pre><p>because the same function can be expressed generically as follows:</p><pre><code><span class="keyword">func</span> operateOnAny&lt;C: <span class="type">Collection</span>&gt;(strings: <span class="type">C</span>) <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span> == <span class="type">String</span> { ... }
</code></pre><p>Due to opening of <code>any</code> types, which we talked about earlier, the two functions above are effectively interchangeable for callers. The generic function is better for performance, however, both because calls passing a concrete type like <code>[String]</code> avoid the formation of the <code>any Collection&lt;String&gt;</code> value and because it's easier for the compiler to specialize the generic version for <code>[String]</code> when it's profitable.</p><p>This is another place where your C++ instincts are good and you shouldn't ignore them: you wouldn't write a function to take a <code>std::any</code> parameter unless you really couldn't write it as a function template taking an arbitrary <code>T</code>, so think of <code>any</code> types the same way in Swift.</p><p>It's a <em>little</em> unfortunate that the more efficient generic function is more verbose than the less-efficient one. I've been holding off on introducing one last bit of syntactic sugar that gets rid of that advantage, because it needs a little explanation. Spoiler alter: the <code>some</code> keyword is used to introduce unnamed generic parameters with syntax parallel to that of <code>any</code> types, so the second function can be written as:</p><pre><code><span class="keyword">func</span> operateOnAny(strings: <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">String</span>&gt;) { ... }
</code></pre><p>Each <code>some</code> type introduces an unnamed generic parameter whose constraints are listed after the <code>some</code>. Swift <code>some</code> types are also called <em>opaque</em> types, because they hide the name of the underlying type: an unnamed generic parameter can't be named (duh), so the actual collection type based into <code>operateOnAny(strings:)</code> is hidden from the function body. Opaque types are also useful in the return type of a function to hide the specific return type from the caller.</p><h2>Implementation hiding with opaque types</h2><p><code>any</code> types effectively hide the underlying type from clients, allowing it to change dynamically at run time. These are two different things: the first is about hiding implementation details behind an abstraction barrier (e.g., we know that we have a <code>Collection</code> of <code>String</code>s, but not the specific type of the collection itself) and the other is about allowing the underlying representation to change dynamically (e.g., we can choose <code>Set&lt;String&gt;</code> or <code>[String]</code> depending on what's best for the problem at hand).</p><p>Opaque types allow a function to describe Swift has a notion of <em>opaque</em> types that let you hide the implementation type behind an abstraction barrier without allowing it to change dynamically at runtime. This gives you, as the implementer, the freedom to limit your API surface area (by not exposing some types) and evolve your implementations over time, without breaking clients. For example, let's consider implementing a generic function <code>uniqued</code> on a <code>Collection</code> that produces a new collection with duplicates removed. We could have such a function return a <code>Set</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">func</span> uniqued() -&gt; <span class="type">Set</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>)
  }
}
</code></pre><p>That implementation was easy, but it's perhaps not the best one. It might be better to unique into an array and return that, or return some different type entirely. The problem is that we have to decide right at the point where we create this function what the act type will be, and assess all of the tradeoffs.</p><p>We could introduce a special type to capture the "uniqued collection", like <code>UniquedCollection&lt;Self&gt;</code>. That's probably what we would do in C++, perhaps burying it in an <code>impl</code> or <code>detail</code> namespace to discourage users from depending on it.</p><p>Opaque types let us describe the result type based on its capabilities (in terms of protocols) without stating its identity:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>) <span class="comment">// okay, Set&lt;Value&gt; is a Collection&lt;Value&gt;</span>
  }
}
</code></pre><p>A user that calls <code>uniqued()</code> can't spell the type of the result, but it can be inferred and is known to be a collection containing the same value type as the collection it was applied to:</p><pre><code><span class="keyword">let</span> uniquedNumbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>].<span class="call">uniqued</span>()   <span class="comment">// okay, type is opaque to the user</span>
<span class="call">print</span>(uniquedNumbers.<span class="property">first</span>)                         <span class="comment">// prints the (1)</span>
</code></pre><p>If we later decide to change the type returned by <code>unique()</code>, we can, because we never exposed the type to the user. So we can change our implementation to produce an array:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">Array</span>(<span class="type">Set</span>&lt;<span class="type">Value</span>&gt;(<span class="keyword">self</span>)) <span class="comment">// okay, unique via a set but return an array</span>
  }
}
</code></pre><p>or a private type of some sort:</p><pre><code><span class="keyword">private struct</span> UniquedCollection&lt;C: <span class="type">Collection</span>&gt;: <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span>: <span class="type">Hashable</span> {
  ...
}

<span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
  <span class="keyword">public func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
    <span class="keyword">return</span> <span class="type">UniquedCollection</span>(<span class="keyword">self</span>) <span class="comment">// okay, unique via a set but return an array</span>
  }
}
</code></pre><p>Because the type is opaque to clients, these implementation changes won't affect them at all: they're under-the-hood improvements made by the author of <code>uniqued()</code>.</p><h3><code>some</code> vs. <code>any</code></h3><p>In Swift, <code>any</code> types can be read to mean "any type that satisfies these requirements" whereas <code>some</code> types are read to mean "some specific type that satisfied these requirements". The key point here is that <code>some</code> types maintain identity whereas <code>any</code> types do not: if I take that <code>uniquedNumbers</code> type from above, I can iterate over it directly:</p><pre><code><span class="keyword">let</span> uniquedNumbers = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>].<span class="call">uniqued</span>()
<span class="keyword">var</span> ci = uniquedNumbers.<span class="property">startIndex</span>
<span class="keyword">let</span> ei = uniquedNumbers.<span class="property">endIndex</span>
<span class="keyword">while</span> ci != <span class="call">ei</span> { <span class="comment">// okay, Index type of the opaque type of uniquedNumbers</span>
  <span class="call">print</span>(uniquedNumbers[ci])
  ci = uniquedNumbers.<span class="call">index</span>(after: ci)
}
</code></pre><p>This puts some restrictions on the body of functions returning <code>some</code> types. Specifically, every <code>return</code> statement must produce a value of the same type. This is called the <em>underlying type</em>, and the Swift compiler will detect a mismatch:</p><pre><code><span class="number">66</span> | <span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Hashable</span> {
<span class="number">67</span> |   <span class="keyword">func</span> uniqued() -&gt; <span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt; {
   |        `- error: function declares an opaque <span class="keyword">return</span> type '<span class="keyword">some</span> <span class="type">Collection</span>&lt;<span class="type">Value</span>&gt;', but the <span class="keyword">return</span> 
   |           statements <span class="keyword">in</span> its body <span class="keyword">do</span> not have matching underlying types
<span class="number">68</span> |     <span class="keyword">if</span> isEmpty {
<span class="number">69</span> |       <span class="keyword">return</span> [<span class="type">Element</span>]()
   |                      `- note: <span class="keyword">return</span> statement has underlying type '[<span class="type">Self</span>.<span class="type">Value</span>]'
<span class="number">70</span> |     }
<span class="number">71</span> | 
<span class="number">72</span> |     <span class="keyword">return</span> <span class="type">Set</span>&lt;<span class="type">Element</span>&gt;(<span class="keyword">self</span>)
   |                       `- note: <span class="keyword">return</span> statement has underlying type '<span class="type">Set</span>&lt;<span class="type">Self</span>.<span class="type">Value</span>&gt;'
<span class="number">73</span> |   }
<span class="number">74</span> | }
</code></pre><p>Note that the identity of the underlying type is hidden from clients of the function, but it is known to the compiler, so hiding a type via an opaque type isn't a performance pessimization the way an <code>any</code> type is.</p><h3>Hiding complicated result types</h3><p>Opaque result types really shine when they're used to hide unnecessary implementation details. To see what I mean, think about the types that are produced from a C++ library that uses <a href="https://en.wikipedia.org/wiki/Expression_templates">expression templates</a>: every single operator introduces another wrapper type (often two of them), producing a final result whose type encodes the entire operation. For example, one might have a <code>parallel_array</code> type that uses expression templates, and an expression like:</p><pre><code>auto result = a * x + b
</code></pre><p>would produce a type such as <code>expr&lt;add_expr&lt;expr&lt;mul_expr&lt;expr&lt;parallel_array&lt;double&gt;&gt;, expr&lt;double&gt;&gt;&gt;, expr&lt;parallel_array&lt;double&gt;&gt;&gt;</code>. Add some namespace qualifiers in there and it gets overwhelming, fast.</p><p>It gets particularly bad when you have to name the result type for some reason, e.g.,</p><pre><code>template&lt;typename <span class="type">A</span>, typename <span class="type">X</span>, typename <span class="type">B</span>&gt;
expr&lt;add_expr&lt;expr&lt;mul_expr&lt;<span class="type">A</span>, <span class="type">X</span>&gt;&gt;, <span class="type">Y</span>&gt; <span class="call">mul_add</span>(<span class="type">A</span> a, <span class="type">X</span> x, <span class="type">B</span> b) {
  <span class="keyword">return</span> a * x + b;
}
</code></pre><p>Expression templates can be a useful tool in Swift for the same reasons they're useful in C++, and Swift would have exactly the same issue with an explosion in user-facing types from simple uses. However, opaque result types let us hide the information behind a <code>some</code> type. For example,</p><pre><code><span class="keyword">protocol</span> ArrayExpr&lt;Value&gt; {
  <span class="keyword">associatedtype</span> Value: <span class="type">Numeric</span>
}

<span class="keyword">private struct</span> MulScalarOp&lt;LHS: <span class="type">ArrayExpr</span>&gt;: <span class="type">ArrayExpr</span> {
  <span class="keyword">typealias</span> Value = <span class="type">LHS</span>.<span class="type">Value</span>

  <span class="keyword">init</span>(lhs: <span class="type">LHS</span>, rhs: <span class="type">LHS</span>.<span class="type">Value</span>) { ... }
}

<span class="keyword">func</span> *&lt;<span class="type">Value</span>&gt;(lhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, rhs: <span class="type">Value</span>) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; { 
  <span class="type">MulScalarOp</span>(lhs: lhs, rhs: value)
}

<span class="keyword">private struct</span> AddArrayOp&lt;LHS: <span class="type">ArrayExpr</span>, RHS: <span class="type">ArrayExpr</span>&gt; <span class="keyword">where</span> <span class="type">LHS</span>.<span class="type">Value</span> == <span class="type">RHS</span>.<span class="type">Value</span> {
  <span class="keyword">typealias</span> Value = <span class="type">LHS</span>.<span class="type">Value</span>

  <span class="keyword">init</span>(lhs: <span class="type">LHS</span>, rhs: <span class="type">RHS</span>) { ... }
}

<span class="keyword">func</span> +&lt;<span class="type">Value</span>&gt;(lhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, rhs: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; { 
  <span class="type">AddArrayOp</span>(lhs: lhs, rhs: rhs)
}
</code></pre><p>Now, code like this:</p><pre><code><span class="keyword">let</span> result = a * x + b
</code></pre><p>produces an opaque type like <code>some ArrayExpr&lt;Double&gt;</code> that avoids exposing all of the implementation details of the expression templates. Add operation like the C++ <code>mul_add</code> earlier can be expressed in terms of opaque types so one never has to name the complicated types:</p><pre><code><span class="keyword">func</span> mulAdd&lt;Value&gt;(<span class="keyword">_</span> a: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;, <span class="keyword">_</span> x: <span class="type">Value</span>, <span class="keyword">_</span> b: <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt;) -&gt; <span class="keyword">some</span> <span class="type">ArrayExpr</span>&lt;<span class="type">Value</span>&gt; {
  a * x + b
}
</code></pre><p>We're still expressing the fundamental type constraints here: both <code>a</code> and <code>b</code> are array expressions of some type, whose underlying value type is <code>Value</code>, and <code>x</code> is a scalar of type <code>Value</code>. But we've abstracted away the actual array expression types so they can be propagated behind-the-scenes.</p><p>However, the compiler can still see the underlying types, so it can optimize the expression templates in the same manner one would expect.</p><h2>Wrap up</h2><p>Type erasure in Swift leverages the same notion of protocols and constraints as generics, but moves from the realm of static polymorphism (concrete types known at compile time) to runtime polymorphism (types only known at runtime). Type erasure makes it easy to create heterogeneous data structures, which contain values of types not known until runtime.</p><p>Because of Swift's model of separate compilation, one can move easily between static and dynamic polymorphism: a value that conforms to a protocol <code>P</code> can be type-erased into a value of type <code>any P</code>, moving from static to dynamic polymorphism. Conversely, a value of type <code>any P</code> can be passed to a generic function requiring a type conforming to <code>P</code>, moving from dynamic back to static polymorphism. So while most of the time you should probably be using generics for abstraction, because they maintain more type information and are therefore easier to optimize, you can use type erasure locally in those places where you need the runtime polymorphism.</p><p>We also discussed metatypes. Metatypes are first-class values in Swift, and are the answer to the question "what's the type of this value?". Metatypes can be used to identify the types of values, construct new instances of the identified type (when there is a suitable <code>init</code> requirement), and dynamically query the capabilities of a given type with queries such as "does this type conform to the protocol <code>Decodable</code>?".</p><p>Next up, we'll explore Swift's take on error handling, comparing against C++'s model of exceptions.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-generics</guid><title>Swift for C++ Practitioners, Part 4: Generics</title><description>Swift for C++ Practitioners, Part 4: Generics</description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-generics</link><pubDate>Sat, 6 Apr 2024 10:14:00 -0400</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 4: Generics</h1><p>Swift's generics system is, on its surface, similar to C++ templates: functions and types can be parameterized (e.g., a <code>Set</code> type has a parameter <code>T</code>) and can be used with any suitable generic arguments (e.g., <code>Set&lt;Int&gt;</code>). One can use these features to implement generic algorithms and data structures that work with a wide variety of concrete types.</p><p>Swift's generics system was designed with the goal of making <a href="https://en.wikipedia.org/wiki/Generic_programming">Generic Programming</a> easy and fun. Generic functions and types are <em>constrained</em> by a set of requirements on the type parameters, akin to the <a href="https://en.cppreference.com/w/cpp/language/requires"><code>requires</code> clause</a> provided by <a href="https://en.cppreference.com/w/cpp/language/constraints">C++20 Concepts</a>. However, Swift's generics are <em>separately type checked</em>, so there is no such thing as an instantiation-time error: if the Swift type checker accepts the generic function or type you write, it will work with any arguments that meet those same requirements.</p><p>Swift generics are also <em>separately compiled</em>, meaning that you can have a generic function or type within one shared library, and use it from other code, without requiring explicit instantiation or manual indirection. This means that Swift can provide some language features that aren't possible in C++. For example, C++ doesn't allow you to have a <code>virtual</code> function template, because the dynamic dispatch (<code>virtual</code>) is in conflict with the need to instantiate the function template for each set of generic arguments; in contrast, Swift allows generic functions that can be overridden in subclasses. Similarly, <a href="https://davekilian.com/cpp-type-erasure.html">type erasure in C++</a> is a mechanism for runtime polymorphism in C++ that allows one to hide the type used at runtime behind another instance, and is used in library components such as <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a> and <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>. Swift's <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/opaquetypes#Boxed-Protocol-Types"><code>any</code> types</a> provide the same functionality as part of the language, using the same mechanism that underlies its generics system, making it easy to bridge the compile-time/runtime polymorphism divide. There are some downsides to separate compilation of generics, and we'll get back to those later in the post.</p><p>Before elaborating on the above, it's important to understand what Swift's generics system <em>cannot</em> do that one might expect when coming from C++ templates. Swift generics have no notion of <em>specialization</em>, so you can't (say) customize the representation of a generic type based on its type arguments. For example, the equivalent of <a href="https://en.cppreference.com/w/cpp/container/vector_bool"><code>std::vector&lt;bool&gt;</code></a> is inexpressible in the Swift generics system. This limitation is necessary for separate type checking and compilation to work, and it simplifies the mental model for working with generics, but it has significant implications: <em>there is no template metaprogramming</em> in Swift. So while the canonical use of <a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> is effectively built into the Swift language (it's just part of type checking), there's no way to express <a href="https://en.cppreference.com/w/cpp/types/conditional"><code>std::conditional</code></a> or similar. If you're an expert in C++ templates, this can be hard to stomach, because the tools you're accustomed to just aren't there in Swift. However, separate type checking is <em>totally worth it</em>, and something you sort of have to experience to understand why. I'll try to make the case as obvious as I can throughout this post.</p><p>Enough introduction, let's write some generics!</p><h2>The basics</h2><p>Generics in Swift use angle brackets, just like in C++. Instead of a template header, the angle brackets go after the name of the entity. Here's the Swift equivalent to <a href="https://en.cppreference.com/w/cpp/utility/pair"><code>std::pair</code></a>:</p><pre><code><span class="keyword">struct</span> Pair&lt;T, U&gt; {
  <span class="keyword">var</span> first: <span class="type">T</span>
  <span class="keyword">var</span> second: <span class="type">U</span>
}
</code></pre><p>Now, we can go ahead and form a pair of an <code>Int</code> and a <code>String</code>, e.g.,</p><pre><code><span class="keyword">let</span> intAndString = <span class="type">Pair</span>&lt;<span class="type">Int</span>, <span class="type">String</span>&gt;(first: <span class="number">42</span>, second: <span class="string">"Answer"</span>)
</code></pre><p>We've explicitly written out the generic arguments, but we didn't have to, because Swift's type inference can handle that for us. The above can be written equivalently as:</p><pre><code><span class="keyword">let</span> intAndString = <span class="type">Pair</span>(first: <span class="number">42</span>, second: <span class="string">"Answer"</span>)
</code></pre><p>You can think of this as being essentially equivalent to C++17 <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">class template argument deduction</a>, but uniform in the language and without an explicit notion of deduction guides.</p><p>Generic functions are similar. For example, we could write the identity function like this:</p><pre><code><span class="keyword">func</span> identity&lt;T&gt;(<span class="keyword">_</span> value: <span class="type">T</span>) -&gt; <span class="type">T</span> {
  <span class="keyword">return</span> value
}
</code></pre><h3>Extending generic types</h3><p>That's not very interesting, so let's write an operation that returns a new pair with the <code>first</code> and <code>second</code> fields swapped:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> {
  <span class="keyword">func</span> swapped() -&gt; <span class="type">Pair</span>&lt;<span class="type">U</span>, <span class="type">T</span>&gt; {
    <span class="keyword">return</span> .<span class="keyword">init</span>(first: second, second: first)
  }
}
</code></pre><p>Neat! We've extended our generic <code>Pair</code> type in the same way we might extend any other type in Swift. One important thing to note here is that the names of generic parameters are significant in Swift, unlike in C++, because extensions of a type automatically have access to the generic parameters of that type. So <strong>don't be like me</strong> and use names like <code>T</code> and <code>U</code>: pick more meaningful names (e.g., <code>First</code> and <code>Second</code> for our little <code>Pair</code> type).</p><p>Just to close the loop, let's call this new function:</p><pre><code><span class="keyword">let</span> stringAndInt = intAndString.<span class="call">swapped</span>() <span class="comment">// returns Pair&lt;String, Int&gt; containing (first: "Answer", second: 42)</span>
</code></pre><h3>Separate type checking</h3><p>Now, all of the code above is correct code. What if we made a mistake, and got our types mixed up due to the badly-named <code>T</code> and <code>U</code>?</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> {
  <span class="keyword">func</span> swappedBad() -&gt; <span class="type">Pair</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; {
    <span class="keyword">return</span> .<span class="keyword">init</span>(first: second, second: first)
  }
}
</code></pre><p>The Swift compiler will inform us of our error in the definition of the generic function:</p><pre><code>pair.<span class="property">swift</span>:<span class="number">8</span>:<span class="number">25</span>: error: cannot convert value of type '<span class="type">U</span>' to expected argument type '<span class="type">T</span>'
 <span class="number">6</span> │ <span class="keyword">extension</span> <span class="type">Pair</span> {
 <span class="number">7</span> │   <span class="keyword">func</span> swappedBad() -&gt; <span class="type">Pair</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; {
 <span class="number">8</span> │     <span class="keyword">return</span> .<span class="keyword">init</span>(first: second, second: first)
   │                         ╰─ error: cannot convert value of type '<span class="type">U</span>' to expected argument type '<span class="type">T</span>'
 <span class="number">9</span> │   }
<span class="number">10</span> │ }

pair.<span class="property">swift</span>:<span class="number">8</span>:<span class="number">41</span>: error: cannot convert value of type '<span class="type">T</span>' to expected argument type '<span class="type">U</span>'
 <span class="number">6</span> │ <span class="keyword">extension</span> <span class="type">Pair</span> {
 <span class="number">7</span> │   <span class="keyword">func</span> swappedBad() -&gt; <span class="type">Pair</span>&lt;<span class="type">T</span>, <span class="type">U</span>&gt; {
 <span class="number">8</span> │     <span class="keyword">return</span> .<span class="keyword">init</span>(first: second, second: first)
   │                                         ╰─ error: cannot convert value of type '<span class="type">T</span>' to expected argument type '<span class="type">U</span>'
 <span class="number">9</span> │   }
<span class="number">10</span> │ }
</code></pre><p>Note that we don't have any caller of this function, yet we got a type error. A generic function's body is type-checked against the constraints it places on its generic parameters. It cannot use those types in ways that aren't covered by the constraints. This is a very different starting point than C++ templates, where the template itself is only partially checked at the point of definition: anything that involves a C++ template parameter (i.e., is <em>dependent</em> on a template parameter) must be deferred until template instantiation time.</p><p>The other piece of separate type checking occurs at uses of a generic type or function. If the generic arguments supplied to the generic type or function don't satisfy the constraints, the compiler will reject that use of the generic type or function. This part should feel more familiar when coming from C++, because this is what <a href="https://en.cppreference.com/w/cpp/types/enable_if"><code>std::enable_if</code></a> and <a href="https://en.cppreference.com/w/cpp/language/constraints">C++20 <code>requires</code> clauses</a> do: prevent the user from instantiating a template with arguments that won't work, like passing bidirectional iterators to <a href="https://en.cppreference.com/w/cpp/algorithm/sort"><code>std::sort</code></a>.</p><p>The "separate" in separate type checking refers to the fact that we can type-check the definition of a generic separaterly from its use, and so long as both type-checks succeed, you know that there will be no further type errors. There is no need to type-check the "instantiation" that substitutes the generic arguments into the definition of the generic function, because it can never fail.</p><p>Separate type checking is a fairly core notion in C++, too! But in C++ it only applies to non-template code. For example, say you have some function:</p><pre><code>std::vector&lt;std::string&gt; <span class="call">selectRandomWords</span>(const std::string &amp;input, int num_words);
</code></pre><p>The definition of that function knows that the <code>input</code> argument will be a <code>std::string</code>, and <code>num_words</code> will be an <code>int</code>. A call to that function must provide values that can be converted to those parameter types. The two sides of the interface are checked separately, and we know there will be no type errors later on.</p><p>The practical impact of having separate type checking for generics is that it makes everything <em>simpler</em>. There are no <em>template instantiation backtraces</em> exposing the implementations of the generics you've used. Rather, if you fail to meet the requirements of a generic function or type, you'll get an error message right at that use. Moreover, <em>writing</em> generic types and functions is a whole lot easier, because the type checker helps you get the constraints right and stay within those bounds.</p><p>If you're thinking that all of this talk about constraints sounds a whole lot like <a href="https://en.wikipedia.org/wiki/Concept_(generic_programming)">C++ concepts</a>, you're right! In Swift, we call them <em>protocols</em>.</p><h2>Protocols</h2><p>Protocols describe an abstract interface on a type. They are introduced with the <code>protocol</code> keyword, have a name, and can have various members including functions, properties, initializers, and subscripts. Protocols can be used as generic constraints, and a protocol constraint can only be satisfied by a type that <em>conforms to</em> the protocol.</p><p>Let's start with a simple protocol that provides a cost function; we'll call it <code>Quantifiable</code>:</p><pre><code><span class="keyword">protocol</span> Quantifiable {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span>
}
</code></pre><p>Note that the <code>cost</code> function has no definition. That's because it's an abstract interface, which must be implemented by every conforming type, somewhat like a pure virtual function in C++. In generic programming, we often call these <a href="https://ericniebler.com/2014/10/21/customization-point-design-in-c11-and-beyond/"><em>customization points</em></a>: places where a given concrete type can (or must) provide its own implementation. In Swift, we usually call them the <em>requirements</em> of a protocol.</p><p>We can now write a generic function that retrieves the cost of a particular value, like this:</p><pre><code><span class="keyword">func</span> getCost&lt;T: <span class="type">Quantifiable</span>&gt;(value: <span class="type">T</span>) -&gt; <span class="type">Double</span> {
  <span class="keyword">return</span> value.<span class="call">cost</span>()
}
</code></pre><p>If we had forgotten the constraint <code>T: Quantifiable</code>, the compiler would have complained that <code>value of type 'T' has no member 'cost'</code>. If we call <code>getCost</code> with a value of a type that isn't quantifiable (no types are, yet), we'll get an error like this:</p><pre><code><span class="number">20</span> │ <span class="call">getCost</span>(value: <span class="number">42</span>)
   │ ╰─ error: global function '<span class="call">getCost</span>(value:)' requires that '<span class="type">Int</span>' conform to '<span class="type">Quantifiable</span>'
</code></pre><p>There's much more to protocols, but first let's put things together to create a complete example.</p><h3>Conformances</h3><p>To satisfy a protocol constraint like <code>T: Quantifiable</code>, the generic argument for <code>T</code> must conform to <code>Quantifiable</code>. We can state such a conformance for a given type by extending that type and specifying the conformance. For example, we can make <code>Int</code> quantifiable like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Int</span>: <span class="type">Quantifiable</span> {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span> { <span class="keyword">return</span> <span class="number">1</span> }
}
</code></pre><p>The <code>: Quantifiable</code> states the conformance, and the type checker will make sure that every member from the protocol (in this case, <code>cost</code>) has a corresponding member in the type, with a compatible type signature. If we were to forget an operation, or have a type mismatch between what's in the protocol and what's in the type...</p><pre><code><span class="keyword">extension</span> <span class="type">String</span>: <span class="type">Quantifiable</span> {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Int</span> { <span class="keyword">return</span> count } <span class="comment">// error: see below</span>
}
</code></pre><p>we'll get an error like this:</p><pre><code><span class="number">22</span> │ <span class="keyword">extension</span> <span class="type">String</span>: <span class="type">Quantifiable</span> {
   │ ╰─ error: type '<span class="type">String</span>' does not conform to <span class="keyword">protocol</span> '<span class="type">Quantifiable</span>'
<span class="number">23</span> │   <span class="keyword">func</span> cost() -&gt; <span class="type">Int</span> { <span class="keyword">return</span> count } <span class="comment">// error</span>
   │        ╰─ note: candidate has non-matching type '() -&gt; <span class="type">Int</span>'
<span class="number">24</span> │ }
</code></pre><p>This kind of checking is available with C++20 concepts, but you must opt in to it with something like a <code>static_assert</code>:</p><pre><code><span class="call">static_assert</span>(<span class="type">Quantifiable</span>&lt;<span class="type">String</span>&gt;); <span class="comment">// C++20 approximation of Swift "conformance checking"</span>
</code></pre><p>Checking the conformance is another important piece of separate type checking: it makes sure that the type fully implements the abstract interface described by the protocol, so that a generic function or type written to that abstract interface will succeed with any type that implements it.</p><h3>Where clauses</h3><p>The <code>&lt;T: Quantifiable&gt;</code> syntax I used in the <code>getCost</code> function is actually shorthand for the more general <code>where</code> clause. A <code>where</code> clause specifies the constraints on a generic function or type, much like a C++20 <code>requires</code> clause. The <code>getCost</code> function could be equivalently written with a <code>where</code> clause like this:</p><pre><code><span class="keyword">func</span> getCost&lt;T&gt;(value: <span class="type">T</span>) -&gt; <span class="type">Double</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Quantifiable</span> {
  <span class="keyword">return</span> value.<span class="call">cost</span>()
}
</code></pre><p><code>where</code> clauses can go on any generic entity, including on members of generic types. For example, let's go ahead and add a <code>cost()</code> method to our <code>Pair</code> type:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Quantifiable</span>, <span class="type">U</span>: <span class="type">Quantifiable</span> {
    <span class="keyword">return</span> first.<span class="call">cost</span>() + second.<span class="call">cost</span>()
  }
}
</code></pre><p>This <code>cost()</code> function can only be called on an instance of <code>Pair</code> where both <code>T</code> and <code>U</code> conform to <code>Quantifiable</code>. However, that's probably not how a Swift programmer would write this function. Rather, they'd put the <code>where</code> clause up on the extension itself, to highlight that all of the API of the extension only applies when <code>T</code> and <code>U</code> satisfy these extra constraints. Like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Quantifiable</span>, <span class="type">U</span>: <span class="type">Quantifiable</span> {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span> {
    <span class="keyword">return</span> first.<span class="call">cost</span>() + second.<span class="call">cost</span>()
  }
}
</code></pre><p>In Swift, we refer to extensions like these as <em>constrained extensions</em>, because they extend the functionality of a type when the arguments meet some additional set of constraints. An extension without an additional <code>where</code> clause is, therefore, an <em>unconstrained extension</em>.</p><h3>Conditional conformances</h3><p>Notice how <code>Pair</code> now seems to match the interface of <code>Quantifiable</code> itself? We can make it official by declaring this extension as <code>Pair</code>'s conformance to <code>Quantifiable</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Pair</span>: <span class="type">Quantifiable</span> <span class="keyword">where</span> <span class="type">T</span>: <span class="type">Quantifiable</span>, <span class="type">U</span>: <span class="type">Quantifiable</span> {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span> {
    <span class="keyword">return</span> first.<span class="call">cost</span>() + second.<span class="call">cost</span>()
  }
}
</code></pre><p>This is called a <em>conditional conformance</em> in Swift. Essentially, that means <code>Pair</code> only conforms to the <code>Quantifiable</code> protocol when certain other constraints are satisfied, and it allows generic types to compose well with the generics system: <code>Pair</code> conforms when its component values conform. A protocol conformance declared via constrained extension is a conditional conformance.</p><p>We see this a lot for various collection types like <code>Array</code>, which often conform to a protocol only when the element of the array conforms to that same protocol. For example, an <code>Array</code> is <code>Equatable</code> (meaning that it can be compared for equality) when its elements are <code>Equatable</code>, like this:</p><pre><code><span class="keyword">struct</span> Array&lt;Element&gt; { ... }

<span class="keyword">extension</span> <span class="type">Array</span>: <span class="type">Equatable</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Equatable</span> {
  <span class="keyword">static func</span> ==(lhs: <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;, rhs: <span class="type">Array</span>&lt;<span class="type">Element</span>&gt;) -&gt; <span class="type">Bool</span> {
    <span class="keyword">if</span> lhs.<span class="property">count</span> != rhs.<span class="property">count</span> { 
      <span class="keyword">return false</span> 
    }
    
    <span class="keyword">for</span> index <span class="keyword">in</span> indices {
      <span class="keyword">if</span> lhs[index] != rhs[index] { 
        <span class="keyword">return false</span> 
      }
    }
    
    <span class="keyword">return true</span>
  }
}
</code></pre><p>This is common in C++ as well: a <code>std::vector&lt;T&gt;</code> will have a usable <code>==</code> when the element type <code>T</code> has a usable <code>==</code>. In C++, the relationship isn't usually expressed explicitly like this: usually, the vector's <code>==</code> will fail to instantiate if the template argument for <code>T</code> doesn't have an <code>==</code>, so you get an instantiation backtrace. C++ does allow the use of a <code>requires</code> clause or <code>enable_if</code> to get something more like what Swift is doing.</p><h3>Operators</h3><p>Operators in Swift are introduced with the <code>func</code> keyword, like all other functions. They are implemented as <code>static</code> functions within a type, or as module-scope functions, which are similar to C++. Unlike C++, they cannot be implemented as non-<code>static</code> functions (but that's kind of an anti-pattern in C++ anyway). Swift doesn't have general notion of <a href="https://en.cppreference.com/w/cpp/language/adl">Argument Dependent Lookup (ADL)</a>, because it's not really needed when most functionality is introduced via extensions anyway, but it does find operators within the types of the operands. Let's see some operators in a protocol:</p><pre><code><span class="keyword">protocol</span> Equatable {
  <span class="keyword">static func</span> ==(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
  <span class="keyword">static func</span> !=(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
}
</code></pre><p>Note that the parameter types are all <code>Self</code>, which means "the type that conforms to this protocol". When we make <code>Array&lt;Element&gt;</code> conform to <code>Equatable</code>, the <code>Self</code> type is <code>Array&lt;Element&gt;</code>. This is effectively how <code>Self</code> is used everywhere else in types, because it's the name for the implicit <code>self</code> parameter for non-static methods.</p><p>Armed with protocols and generic constraints, let's dive deeper into generic programming by looking at how Swift tackles the fundamental problems solved by the C++ <a href="https://en.wikipedia.org/wiki/Standard_Template_Library">Standard Template Library (STL)</a>: collections (containers, in C++ speak) and algorithms.</p><h2>Exploring protocols</h2><p>Let's consider an algorithm that sums up the elements in an array of <code>Double</code> values. Then, we're going to <em>lift</em> this algorithm to make it more generic, discovering more protocols along the way. We can write our function like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span>&lt;<span class="type">Double</span>&gt; {
  <span class="keyword">func</span> sum() -&gt; <span class="type">Double</span> {
    <span class="keyword">var</span> result = <span class="number">0.0</span>
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;count {
      result = result + <span class="keyword">self</span>[index]
    }
    <span class="keyword">return</span> result
  }
}
</code></pre><p>In the implementation of this function, <code>0..&lt;count</code> is Swift syntax for a range of integer values from 0 up to (but not including) <code>count</code>, which lets us easily iterate over all of the value indices in the array.</p><p>The extension of <code>Array&lt;Double&gt;</code> is actually a short-hand syntax for something that goes into a <code>where</code> clause: a <em>same-type constraint</em>. We could, equivalently, have written the above as:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span> <span class="keyword">where</span> <span class="type">Element</span> == <span class="type">Double</span> { ... }
</code></pre><p>That's a little bit silly here, but I promise that same-type constraints will become much more useful soon, and they fulfill roughly the same role as <a href="https://en.cppreference.com/w/cpp/types/is_same"><code>std::is_same</code></a> in C++.</p><p>Now, the most obvious next step to "lift" this algorithm is to make it work on element types other than <code>Double</code>. That requires us to create a protocol to cover the <code>+</code> operation and a zero element. Let's call it <code>AddableWithZero</code>:</p><pre><code><span class="keyword">protocol</span> AddableWithZero {
  <span class="keyword">static func</span> +(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Self</span>
  <span class="keyword">static var</span> zero: <span class="type">Self</span> { <span class="keyword">get</span> }
}
</code></pre><p>This happens to be the first property we've seen in a protocol. Note that we use <code>get</code> (without a definition) here to say that it's a readable property. If we wanted it to allow both reads and writes, the property would be written as <code>{ get set }</code>. Using <code>AddableWithZero</code>, we can lift our <code>sum</code> function like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">AddableWithZero</span> {
  <span class="keyword">func</span> sum() -&gt; <span class="type">Element</span> {
    <span class="keyword">var</span> result = <span class="type">Element</span>.<span class="property">zero</span>
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;count {
      result = result + <span class="keyword">self</span>[index]
    }
    <span class="keyword">return</span> result
  }
}
</code></pre><h3>Protocol refinement</h3><p>Our new <code>sum</code> function is pretty general, but it requires you to have both a <code>+</code> and a "zero" element. We could make this <code>sum</code> a bit more general by taking an initial value, so we don't need <code>zero</code> as part of the protocol. But we don't want to lose out on the convenience of zero as the right default for most cases. So, let's revise our protocol a bit to separate out the "addable" part from the "zero" part, introducing two protocols that are related:</p><pre><code><span class="keyword">protocol</span> Addable {
  <span class="keyword">static func</span> +(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Self</span>
}

<span class="keyword">protocol</span> AddableWithZero: <span class="type">Addable</span> {
  <span class="keyword">static var</span> zero: <span class="type">Self</span> { <span class="keyword">get</span> }  
}
</code></pre><p>Here, we say that <code>AddableWithZero</code> <em>refines</em> <code>Addable</code>. The key property is that every type that conforms to <code>AddableWithZero</code> must <em>also</em> conform to <code>Addable</code>. This lets us introduce two variants of <code>sum</code> built on each other: one with the lesser <code>Addable</code> constraint that requires an initial value, and one that uses <code>AddableWithZero</code> and supplies the zero value:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">Addable</span> {
  <span class="keyword">func</span> sum(initialValue: <span class="type">Element</span>) -&gt; <span class="type">Element</span> {
    <span class="keyword">var</span> result = initialValue
    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;count {
      result = result + <span class="keyword">self</span>[index]
    }
    <span class="keyword">return</span> result
  }
  
  <span class="keyword">func</span> sum() -&gt; <span class="type">Element</span> <span class="keyword">where</span> <span class="type">Element</span>: <span class="type">AddableWithZero</span> {
    <span class="keyword">return</span> <span class="call">sum</span>(initialValue: .<span class="dotAccess">zero</span>)
  }
}
</code></pre><p>Protocol refinement lets us add structure to our protocol hierarchies. The same notion exists with C++ concepts, where <a href="https://en.cppreference.com/w/cpp/iterator/random_access_iterator"><code>random_access_iterator</code></a> refines <a href="https://en.cppreference.com/w/cpp/iterator/bidirectional_iterator"><code>bidirectional_iterator</code></a>. A given protocol can refine zero or more other protocols, and it's okay if the same protocol shows up at multiple places in the protocol hierarchy.</p><h3>Associated types</h3><p>Now that we've lifted a generic algorithm on arrays, it's time to handle other kinds of collections, such as sets or ring buffers. Looking back at the <code>sum</code> method, it only accesses the array in two ways: a <code>count</code> value that defines the upper bound, and a <code>subscript</code> to access an element. That's starting to sound like a protocol!</p><pre><code><span class="keyword">protocol</span> Collection {
  <span class="keyword">var</span> count: <span class="type">Int</span> { <span class="keyword">get</span> }
  <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; ??? { <span class="keyword">get</span> }
}
</code></pre><p>This is <em>almost</em> complete, but what type is produced by the subscript operation? It's going to differ from one collection to the next... an <code>Array&lt;Double&gt;</code> would produce <code>Double</code>s here, a set of <code>String</code> would produce <code>String</code>s here, and so on. To express "the element type of the collection", we introduce an <em>associated type</em>, like this:</p><pre><code><span class="keyword">protocol</span> Collection {
  <span class="keyword">associatedtype</span> Value
  
  <span class="keyword">var</span> count: <span class="type">Int</span> { <span class="keyword">get</span> }
  <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Value</span> { <span class="keyword">get</span> }
}
</code></pre><p>Now, every type that conforms to <code>Collection</code> must provide a <code>Value</code> type that specifies its element type. One can do this with a type alias, e.g.,</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span>: <span class="type">Collection</span> {
  <span class="keyword">typealias</span> Value = <span class="type">Element</span>
  <span class="comment">// count and subscript come from the primary definition of Array</span>
}
</code></pre><p>You can think of associated types like individual type traits; this <code>Value</code> associated type is what we would use <code>std::iterator_traits&lt;Iter&gt;::value_type</code> for in C++.</p><p>Now, whenever we have a type <code>T</code> that conforms to <code>Collection</code>, we can refer to its element type as <code>T.Value</code>. For example, let's write a module-scope function that sums up the elements of an arbitrary collection:</p><pre><code><span class="keyword">func</span> sum&lt;C: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> collection: <span class="type">C</span>, initialValue: <span class="type">C</span>.<span class="type">Value</span>) -&gt; <span class="type">C</span>.<span class="type">Value</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span>: <span class="type">Addable</span> {
  <span class="keyword">var</span> result = initialValue
  <span class="keyword">for</span> index <span class="keyword">in</span> <span class="number">0</span>..&lt;collection.<span class="property">count</span> {
    result = result + collection[index]
  }
  <span class="keyword">return</span> result
}
</code></pre><p>The type <code>C</code> conforms to <code>Collection</code>, which means it has an element type (<code>C.Value</code>), <code>count</code>, and subscript to access elements. The <code>where</code> clause specifies that its element type must conform to <code>Addable</code>, which allows us to use the <code>+</code> operation. It's all type-checked at the point of definition so we know that the set of constraints is complete.</p><p>Now, not every kind of data structure can meaningfully provide integer-based subscripting, so let's revise our <code>Collection</code> protocol to make it more general:</p><pre><code><span class="keyword">protocol</span> Collection {
  <span class="keyword">associatedtype</span> Value
  <span class="keyword">associatedtype</span> Index: <span class="type">Equatable</span>

  <span class="keyword">var</span> startIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">var</span> endIndex: <span class="type">Index</span> { <span class="keyword">get</span> }
  <span class="keyword">func</span> index(after index: <span class="type">Index</span>) -&gt; <span class="type">Index</span>
  
  <span class="keyword">subscript</span>(index: <span class="type">Index</span>) -&gt; <span class="type">Value</span> { <span class="keyword">get</span> }
}
</code></pre><p>The new associated type, <code>Index</code>, refers to an element within the collection. It's a <em>little</em> bit like a C++ iterator, except that it doesn't necessarily carry all of the information needed to access the element or move through the collection. Rather, the <code>subscript</code> accesses an element refered to by the <code>index</code> (as we saw before, where the index type was effectively <code>Int</code>), and the new <code>index(after:)</code> operation returns the index of the element after the given <code>index</code>. The <code>startIndex</code> and <code>endIndex</code> properties complete the set, providing the index of the first element and an index one-past-the-last element (just like C++ <code>begin</code> and <code>end</code> iterators).</p><p>Note that the <code>Index</code> associated type specifies that it must be <code>Equatable</code>. Associated types can have constraints placed on them, just like generic parameters can. They can even have <code>where</code> clauses, so the associated type declaration above is equivalent to</p><pre><code><span class="keyword">associatedtype</span> Index <span class="keyword">where</span> <span class="type">Index</span>: <span class="type">Equatable</span>
</code></pre><p>By making the <code>Index</code> types <code>Equatable</code>, we can check when we a particular index hits the last index in the collection. That's enough to implement <code>sum</code>, based on our shiny new <code>Collection</code> protocol:</p><pre><code><span class="keyword">func</span> sum&lt;C: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> collection: <span class="type">C</span>, initialValue: <span class="type">C</span>.<span class="type">Value</span>) -&gt; <span class="type">C</span>.<span class="type">Value</span> <span class="keyword">where</span> <span class="type">C</span>.<span class="type">Value</span>: <span class="type">Addable</span> {
  <span class="keyword">var</span> result = initialValue
  <span class="keyword">var</span> currentIndex = collection.<span class="property">startIndex</span>
  <span class="keyword">let</span> endIndex = collection.<span class="property">endIndex</span>
  
  <span class="keyword">while</span> currentIndex != <span class="call">endIndex</span> {
    result = result + collection[currentIndex]
    currentIndex = collection.<span class="call">index</span>(after: currentIndex)
  }
  <span class="keyword">return</span> result
}
</code></pre><p>And then the <code>Array</code> type can directly conform to this new version of the protocol with only a few modifications:</p><pre><code><span class="keyword">extension</span> <span class="type">Array</span>: <span class="type">Collection</span> {
  <span class="comment">// Swift will infer the typealiases below for you, or you can write them out like we did here</span>
  <span class="keyword">typealias</span> Value = <span class="type">Element</span>
  <span class="keyword">typealias</span> Index = <span class="type">Int</span>
  
  <span class="keyword">var</span> startIndex: <span class="type">Int</span> { <span class="number">0</span> }
  <span class="keyword">var</span> endIndex: <span class="type">Int</span> { count }
  <span class="keyword">func</span> index(after index: <span class="type">Int</span>) -&gt; <span class="type">Element</span> { index + <span class="number">1</span> }
}
</code></pre><p>Other data structures could introduce their own <code>Index</code> types to store whatever state is needed to identify an element, whether it's the node itself (say, in a linked list), an abstract position into the sequence of values, or some path encoding for indicating a location in a tree, just like you could with a C++ iterator. The main difference is that <code>Index</code> types can often be smaller or simpler than the equivalent C++ iterator, because the primary operations on them (movement and element access) are operations on the collection. This also means that the operations on an <code>Index</code> can be properly checked: <code>Array</code> uses <code>Int</code> for its index, but all operations on that index will bounds-check the given index value, so you won't hit undefined behavior during iteration.</p><p>Feel free to hack up your favorite data structure and make it a <code>Collection</code> if you'd like, because now we're doing some real generic programming, baby!</p><h3>Protocol extensions</h3><p>As you might recall, I previously made a <a href="../swift-for-cxx-practitioners-extensions/">very big deal</a> out of the fact that extensions were <em>so much better</em> than free functions, and now here I am writing <code>sum</code> as a free function. That's just for exposition, so we can see all of the constraints written out in a form that looks a lot like a C++ template with concept constraints. But the thing is, extensions really <em>are</em> the best answer, and you can use them to write generic algorithms.</p><p>Most generic algorithms are written in an extension on a protocol. Extending a protocol adds the new members to <em>every</em> type that conforms that protocol. Let's put <code>sum</code> on all collections whose <code>Value</code> type is <code>Addable</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">Addable</span> {
  <span class="keyword">func</span> sum(initialValue: <span class="type">Value</span>) -&gt; <span class="type">Value</span> {
    <span class="keyword">var</span> result = initialValue
    <span class="keyword">var</span> currentIndex = <span class="keyword">self</span>.<span class="property">startIndex</span>
    <span class="keyword">let</span> endIndex = <span class="keyword">self</span>.<span class="property">endIndex</span>
  
    <span class="keyword">while</span> currentIndex != <span class="call">endIndex</span> {
      result = result + <span class="keyword">self</span>[currentIndex]
      currentIndex = <span class="call">index</span>(after: currentIndex)
    }
    
    <span class="keyword">return</span> result
  }
  
  <span class="keyword">func</span> sum() -&gt; <span class="type">Value</span> <span class="keyword">where</span> <span class="type">Value</span>: <span class="type">AddableWithZero</span> {
    <span class="keyword">return</span> <span class="call">sum</span>(initialValue: .<span class="dotAccess">zero</span>)
  }  
}
</code></pre><p>The <code>sum</code> methods here and the free functions defined earlier are semantically the same, but making it a method within a protocol extension is nicer in a couple of ways. Of course, it means that you can access this with normal member syntax, e.g., <code>myArrayOfNumbers.sum()</code>. But more importantly, it's easier to write and read the implementation of these methods, because the generic parameter for the <code>Collection</code> itself doesn't need to be spelled out: it's just the <code>Self</code> of the collection, and so it's implicit and in context. It's also full type-checked at definition time (of course), so the process of writing a generic algorithm like this one is practically the same as writing a non-generic algorithm.</p><p>The entire <a href="https://developer.apple.com/documentation/swift/collection"><code>Collection</code> protocol hierarchy</a> in Swift is built in this manner, with the standard collection algorithms for searching, sorting, and so on implemented as members in protocol extensions. The design of the <code>Collection</code> hierarchy itself could fill an entire blog post. Feel free to dive in to Swift collections via the link above. Or, keep reading to learn more about the Swift generics system...</p><h3>Default implementations</h3><p>A while ago, we defined the <code>Equatable</code> protocol with both <code>==</code> and <code>!=</code>, like this:</p><pre><code><span class="keyword">protocol</span> Equatable {
  <span class="keyword">static func</span> ==(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
  <span class="keyword">static func</span> !=(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span>
}
</code></pre><p>Strictly speaking, we don't <em>need</em> to have <code>!=</code> in this protocol, because <code>x != y</code> can be written equivalently as <code>!(x == y)</code> for any sensible type. Generic algorithms can just use <code>==</code>, and it's less work for authors of the conformances of concrete types to the <code>Equatable</code> protocol. Good enough, right?</p><p>Or is it?</p><p>It turns out that protocol extensions have another use: they can provide default implementations for requirements of the protocol, written in terms of other requirements. So we can provide a default implementation for <code>!=</code> in terms of <code>==</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Equatable</span> {
  <span class="keyword">static func</span> !=(lhs: <span class="type">Self</span>, rhs: <span class="type">Self</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">return</span> !(lhs == rhs)
  }
}
</code></pre><p>Default implementations are "just" syntactic sugar, but they make it reasonable to add the full suite of related operations into a protocol without requiring every conforming type to implement them. Conforming types still <em>can</em> implement them, for example if the type can provide a faster implementation than the default one, but they don't have to. It's like getting <a href="https://www.boost.org/doc/libs/1_84_0/libs/utility/doc/html/utility/utilities/operators.html">Boost.Operators</a> for free.</p><p>Default implementations also let you evolve protocols over time without breaking existing conformances: you can add a new requirement to the protocol so long as you also add a default implementation via a protocol extension. For example, imagine that the original <code>Equatable</code> protocol only had <code>==</code>. You could add <code>!=</code> to the protocol along with its default implementation in a protocol extension, and now <code>!=</code> is available to your generic algorithms on <code>Equatable</code> and all types that are <code>Equatable</code>.</p><h3>Stronger constraints for better algorithms</h3><p>One of the tenets of generic programming is that there are often several algorithms to provide the same result, but they differ in what constraints they place on their generic arguments. For example, let's say we had an operation to get the last element of a <code>Collection</code>, like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Collection</span> {
  <span class="keyword">var</span> last: <span class="type">Element</span>? {
    <span class="keyword">var</span> currentIndex = startIndex
    <span class="keyword">var</span> priorIndex: <span class="type">Index</span>? = <span class="keyword">nil
    while</span> currentIndex != <span class="call">endIndex</span> {
      priorIndex = currentIndex
      currentIndex = <span class="call">index</span>(after: currentIndex)
    }
    
    <span class="keyword">guard let</span> priorIndex <span class="keyword">else</span> {
      <span class="keyword">return nil</span>
    }
    
    <span class="keyword">return self</span>[priorIndex]
  }
}
</code></pre><p>That's the best you can do with <code>Collection</code> indices, because they only go forward. That's reasonable for a singly linked list, but awful for something like an array. So, just like C++ has bidirectional iterators, we can <code>BidirectionalCollection</code> in Swift:</p><pre><code><span class="keyword">protocol</span> BidirectionalCollection: <span class="type">Collection</span> {
  <span class="keyword">func</span> index(before index: <span class="type">Index</span>) -&gt; <span class="type">Index</span>
}
</code></pre><p>And we can provide a better implementation of <code>last</code> for bidirectional collections:</p><pre><code><span class="keyword">extension</span> <span class="type">BidirectionalCollection</span> {
  <span class="keyword">var</span> last: <span class="type">Element</span>? {
    <span class="keyword">let</span> index = endIndex
    <span class="keyword">if</span> startIndex == endIndex { <span class="keyword">return nil</span> }
    <span class="keyword">return self</span>[<span class="call">index</span>(before: endIndex)]
  }
}
</code></pre><p>Now, for a given collection instance (like an array), Swift will choose between the two <code>last</code> implementations-, and assuming that the collection instance is known to be a <code>BidirectionalCollection</code>, it will chose that <code>last</code> implementation as the better one. We can even go further by making it a customization point, i.e., adding it to the protocol:</p><pre><code><span class="keyword">protocol</span> Collection {}
  <span class="comment">// ...</span>
  <span class="keyword">var</span> last: <span class="type">Element</span>? <span class="comment">// default implementation will be chosen from the two `last` protocol extensions</span>
}
</code></pre><p>This way, every collection has an efficient <code>last</code> operation, which is chosen based on the capabilities of the conforming type. It's generally good practice to implement generic algorithms in protocol extensions. Then, when you find that they can have better implementations for some data types, also make it customization point by adding the requirement. This change is backward-compatible, and can unlock better performance from the generics system.</p><h2>Variadic generics</h2><p>C++ has <a href="https://en.cppreference.com/w/cpp/language/parameter_pack">variadic templates</a> to abstract over the number of template arguments. The basic model of C++ variadic templates is that one declares <em>parameter packs</em> that can take any number of arguments, and then <em>pack expansions</em> to process all of the arguments in one or more parameter packs. For example, let's say we had a <code>describe</code> function in C++ that takes any number of arguments:</p><pre><code><span class="comment">// C++</span>
template&lt;typename ...<span class="type">Args</span>&gt;
void <span class="call">describe</span>(const <span class="type">Args</span> &amp;...args) {
  <span class="comment">// ...</span> 
}
</code></pre><p>Swift's <em>variadic generics</em> use the same underlying conceptual model, although the syntax is a bit different. In C++, both parameter pack declarations and pack expansions use the ellipsis (<code>...</code>). In Swift, we use the <code>each</code> keyword to denote a parameter pack (both at the declaration and the use), and the <code>repeat</code> keyword to identify pack expansions. The <code>describe</code> function above would look like this in Swift:</p><pre><code><span class="comment">// Swift</span>
<span class="keyword">func</span> describe&lt;each <span class="type">Arg</span>: <span class="type">Describable</span>&gt;(arg: <span class="keyword">repeat</span> each <span class="type">Arg</span>) {
  <span class="comment">// ...</span>
}
</code></pre><p>Note that <code>each</code> is used both when declaring <code>Arg</code> (in the angle brackets) and when referring to it is part of the type of the <code>arg</code> parameter. The type of the <code>arg</code> parameter is a pack expansion (introduced by <code>repeat</code>) where each element in the expansion pulled from the parameter pack (via <code>each Arg</code>). Note that we're also placing a constraint on the arguments: each argument must conform to the <code>Describable</code> protocol.</p><p>As with C++, a pack expansion can have an arbitrarily-complicated pattern. For example, we can introduce an operation to describe tuples of arbitrary size, like this:</p><pre><code><span class="keyword">func</span> describeTuple&lt;each <span class="type">Arg</span>: <span class="type">Describable</span>&gt;(arg: (repeat each <span class="type">Arg</span>)) {
  <span class="comment">// ...</span>
}
</code></pre><p>The parentheses indicate that we have a tuple. The <code>repeat</code> is inside the parentheses because we are expanding the pattern into separate elements in the tuple. The C++ equivalent would be <code>std::tuple&lt;Args...&gt;</code>.</p><p>Let's take this a little further and use some associated types. Here's a function that takes a set of collections and produces a tuple containing the first elements of each collection:</p><pre><code><span class="comment">// Swift</span>
<span class="keyword">func</span> firsts&lt;each <span class="type">C</span>: <span class="type">Collection</span>&gt;(<span class="keyword">_</span> collection: <span class="keyword">repeat</span> each <span class="type">C</span>) -&gt; (repeat (each <span class="type">C</span>).<span class="type">Element</span>?) {
  <span class="keyword">return</span> (repeat (each collection).<span class="property">first</span>)
}
</code></pre><p>The function takes in an arbitrary number of collections. It returns a tuple containing optional element values of each of the collections (which is what <code>first</code> produces). It produces that those values by forming a tuple <code>(repeat ...)</code> where each element is the result of accessing <code>first</code> on one of the collections (<code>each collection</code>). The C++ with tuples would be much the same, assuming we have some kind of <code>front_opt</code> that returned a <code>std:optional</code> and a <code>container_traits</code> to get the value type of a container:</p><pre><code><span class="comment">// C++</span>
template&lt;typename ...<span class="type">C</span>&gt;
std::tuple&lt;std::optional&lt;typename container_traits&lt;<span class="type">C</span>&gt;::value_type&gt;...&gt;
<span class="call">firsts</span>(const <span class="type">C</span>&amp; ...collection) {
  <span class="keyword">return</span> std::<span class="call">make_tuple</span>(<span class="call">front_opt</span>(collection)...);
}
</code></pre><p>When dealing entirely in parameter packs and pack expansions, C++ and Swift are quite similar. Swift is using keywords <code>repeat</code> and <code>each</code> to distinguish pack expansions from parameter packs, whereas C++ uses <code>...</code> for both, but the model and usage patterns are effectively the same.</p><h3>(No) recursive decomposition</h3><p>With C++ variadic templates, one sometimes needs to step outside of pack expansions and do some template metaprogramming. I didn't actually provide a function body for <code>describe</code> function template we started this section with it, but it's likely that it would look something like this:</p><pre><code>template&lt;typename <span class="type">T</span>&gt;
void <span class="call">describeSingle</span>(bool isFirst, const <span class="type">T</span> &amp;value) {
  <span class="keyword">if</span> (!isFirst) { 
    std::cout &lt;&lt; <span class="string">", "</span>;
  }
  std::cout &lt;&lt; value;  
}

void <span class="call">describeImpl</span>(bool isFirst) {
  std::cout &lt;&lt; std::endl;
}

template&lt;typename <span class="type">Head</span>, typename ...<span class="type">Tail</span>&gt;
void <span class="call">describeImpl</span>(bool isFirst, const <span class="type">Head</span> &amp;head, const <span class="type">Tail</span> &amp;...tail) {
  <span class="call">describeSingle</span>(isFirst, head)  
  <span class="call">describeImpl</span>(<span class="comment">/*isFirst=*/false, tail...);
}

template&lt;typename ...Args&gt;
void describe(const Args &amp;...args) {
  describeImpl(/*isFirst=*/true, args...);
}</span>
</code></pre><p>The two <code>describeImpl</code> functions together form a recursive algorithm: the first one is the basis case of the recursion, printing a newline at the end. The second one is the recursive case: it peels off the first element of the parameter pack (into <code>head</code>) and prints it, then recurses by passing the remaining elements of the parameter pack (<code>tail</code>) along. This "recursive decomposition" of parameter packs a fairly common way to implement operations with C++ variadic templates.</p><p><strong>There is no recursive decomposition of parameter packs in Swift</strong>, because it doesn't work with separate type checking. The Swift equivalent to the above would produce errors on each call to <code>describeImpl</code>, because there's no single function <code>describeImpl</code> that handles an arbitrary number of arguments. The error would look something like this:</p><pre><code>describe.<span class="property">swift</span>:<span class="number">13</span>:<span class="number">32</span>: error: cannot pass value pack expansion to non-pack parameter of type '<span class="type">Head</span>'
<span class="number">11</span> |   head.<span class="call">describe</span>()
<span class="number">12</span> |   
<span class="number">13</span> |   <span class="call">describeImpl</span>(isFirst: <span class="keyword">false</span>, repeat each tail)
   |                                `- error: cannot pass value pack expansion to non-pack parameter of type '<span class="type">Head</span>'
<span class="number">14</span> | }
<span class="number">15</span> | 
</code></pre><p>In Swift, one must <em>always</em> operate on parameter packs via pack expansions, because there's no template metaprogramming to fall back on. Fortunately, it's fairly easy to iterate over all of the elements in a parameter pack with Swift 6.0, because it's the same <code>for..in</code> loop one can use with sequences. That brings us to our actual implementation of <code>describe</code> in Swift:</p><pre><code><span class="keyword">protocol</span> Describable {
  <span class="keyword">func</span> describe()
}

<span class="keyword">func</span> describe&lt;each <span class="type">Arg</span>: <span class="type">Describable</span>&gt;(
  <span class="keyword">_</span> arg: <span class="keyword">repeat</span> each <span class="type">Arg</span>
) {
  <span class="keyword">var</span> isFirst = <span class="keyword">true
  for</span> current <span class="keyword">in repeat</span> each arg {
    <span class="keyword">if</span> isFirst {
      isFirst = <span class="keyword">false</span>
    } <span class="keyword">else</span> {
      <span class="call">print</span>(<span class="string">","</span>, separator: <span class="string">""</span>, terminator: <span class="string">""</span>)
    }
    current.<span class="call">describe</span>()
  }
   <span class="call">print</span>(<span class="string">"\n"</span>, separator: <span class="string">""</span>, terminator: <span class="string">""</span>)
}
</code></pre><p>Everything above feels rather straightforward: we iterate through the parameter pack, where <code>current</code> takes on each value in the parameter pack, and do what's appropriate for that value. It's certainly more straightforward than the recursive decomposition, and has the added benefit that is separately type-checked.</p><h3>Hidden types</h3><p>Now, if you think about it a little <em>too</em> deeply, it starts to feel a little murky: what <em>is</em> <code>current</code> anyway? In each iteration, it is a different value plucked from the parameter pack <code>arg</code>. So in each iteration, <code>current</code> effectively has a different type! In fact, you can't specifically write out what the type of <code>current</code>: it has to be inferred and is a hidden type that means "the current element in the parameter pack". However, you do know that <code>current</code> is <code>Describable</code>, so you can call <code>describe()</code> on it.</p><p>You might find that you need a name for the type of <code>current</code>. Swift doesn't have a direct way to ask for the type of a value (i.e., there's no equivalent to <code>decltype</code>), but you can write a generic function to pass <code>current</code> to:</p><pre><code><span class="keyword">func</span> describeSingle&lt;T: <span class="type">Describable</span>&gt;(isFirst: <span class="keyword">inout</span> <span class="type">Bool</span>, <span class="keyword">_</span> value: <span class="type">T</span>) {
  <span class="keyword">if</span> isFirst {
    isFirst = <span class="keyword">false</span>
  } <span class="keyword">else</span> {
    <span class="call">print</span>(<span class="string">","</span>, separator: <span class="string">""</span>, terminator: <span class="string">""</span>)
  }
  value.<span class="call">describe</span>()
}
</code></pre><p>and then call it from <code>describe</code> with <code>describeSingle(isFirst: &amp;first, current)</code>.</p><p>This same idea of "hidden" types will come up again later when we talk about <em>type erasure</em>. But first, let's talk about separate compilation.</p><h2>Separate compilation</h2><p>Early on in this post, I noted that Swift's generics support separate compilation. We've mostly focused on separate type checking so far, because that's the most impactful on the programmer: it's what eliminates instantiation-time failures and generally makes it a whole lot easier to work with generic code.</p><p>Separate type checking is necessary for separate compilation of generics, but it's not sufficient. Let's step back and consider how C++ compiles templates: when you use a template with some template arguments, the compiler will <em>instantiate</em> the template's definition by substituting in the concrete template arguments (<code>int</code>, <code>std::string</code>, etc.) for the corresponding template parameters (<code>T</code>, <code>U</code>). Template instantiation is a recursive process, and in the end you'll have code that only contains concrete types: the templates have all been substituted away. This is an important part of both the mental model and the performance model of C++ templates.</p><p>In more formal programming-language terms, the "instantiation" process is called "monomorphization". When you have separate type checking, monomorphization never fails, so it can be thought of as just an implementation detail. You can treat generic functions as generic, and the compiler will monomorphize based on the generic arguments you provide. A number of programming languages that have separately type-checked generics work this way.</p><p>With separate compilation of generics, you don't need monomorphization. Instead, you compile a generic function or type into a single implementation that can work with any generic argument. Imagine having all of your template definitions in a <code>.cpp</code> file rather than in the header, and distributing the compiled object files (say, in a shared library) so clients can use your templates with their own types: that's separate compilation of generics. It also opens up some language features that you might not have realized you were missing, which I'll talk about in the next section.</p><p>With Swift's separate compilation of generics, <strong>monomorphization is an optimization</strong>: the compiler can choose to monomorphize uses of generics when it can see both the use and the definition, and it appears profitible. This effectively lets the optimizer decide between having a single implementation (slower due to dynamic dispatch, but shared) and having many monomorphized implementations (faster because each is specialized for a type, but can lead to "template bloat"). Separate compilation of generics provides more language functionality and more options for distribution, but nothing is free. Let's dive in.</p><h3>The joys</h3><p>Separate compilation of generics means that you can distribute implementations of generic functions and types as part of compiled libraries, without having to also ship the source code. Along with the fact that Swift has a stable ABI, this means that you can ship library binaries that make use of the whole language.</p><p>Even if you never intent to ship a library without source code, separate compilation allows dynamic dispatch on generic functions. For example, C++ prohibits the definition of a <code>virtual</code> function template:</p><pre><code>virtual.<span class="property">cpp</span>:<span class="number">3</span>:<span class="number">24</span>: error: 'virtual' cannot be specified on member function templates
    <span class="number">3</span> |   template&lt;typename <span class="type">T</span>&gt; virtual void <span class="call">doSomething</span>() { }
      |    
</code></pre><p>Have you ever thought about <em>why</em> this doesn't work in C++? It's because a <code>virtual</code> function introduces dynamic dispatch, and for dynamic dispatch to work you need a single place to jump through---say, a single function pointer. But a function template can have any number of template instantiations, and you don't know what they are ahead of time, so there's no way to record all of the function pointers you might ever need.</p><p>With separate compilation of generics in Swift, class methods can be generic and overridden:</p><pre><code><span class="keyword">class</span> DataManager {
  <span class="keyword">func</span> merge&lt;Elements: <span class="type">Collection</span>&gt;(elementsOf collection: <span class="type">Elements</span>) {
    <span class="comment">// merge all of the elements of the collection</span>
  }
}

<span class="keyword">class</span> DistributedDataManager: <span class="type">DataManager</span> {
  <span class="keyword">override func</span> merge&lt;Elements: <span class="type">Collection</span>&gt;(elementsOf collection: <span class="type">Elements</span>) {
    <span class="comment">// merge all of the elements of the collection.</span>
  }
}
</code></pre><p>Separate compilation of generics also allows one to move between static and dynamic polymorphism fluidly in Swift. We'll explore <em>type erasure</em> more in the next post, but let's give a taste of it here. Any time you have a protocol, you can create a type-erased instance of it using the <code>any</code> keyword. An instance of the type <code>any Describable</code> can store a a value of any type, so long as that type conforms to <code>Describable</code>. If the instance is mutable, it can be re-assigned to a value of another type. Think of a <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a> or <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a> and you'll have the right idea. This lets us easily form (and work with) heterogeneous collections, for example, an array of <code>Describable</code> entities where each has a different type:</p><pre><code><span class="keyword">var</span> describibles: [any <span class="type">Describable</span>] = []
describibles.<span class="call">append</span>(<span class="number">17</span>)      <span class="comment">// okay assuming Int is Describable</span>
describibles.<span class="call">append</span>(<span class="string">"hello"</span>) <span class="comment">// okay assuming String is Describable</span>
</code></pre><p>This is runtime polymorphism, because each element in <code>describables</code> can have a different type, and we might not know what the type is until runtime. However, we know that each element is <code>Describable</code>, so we can operate on them directly. Let's loop over all of the elements in <code>describables</code> with a <code>for..in</code> loop to "describe" them all in the same way we did with the parameter pack:</p><pre><code><span class="keyword">var</span> isFirst = <span class="keyword">true
for</span> current <span class="keyword">in</span> describibles {
  <span class="call">describeSingle</span>(isFirst: &amp;first, current)  <span class="comment">// okay, each element in 'current' is Describable</span>
}
</code></pre><p>There's a lot of power here in Swift's ability to move between static polymorphism (generics) and dynamic polymorphism (<code>any</code>), which is great for expressing your ideas.</p><p>But we all know that with great power, comes great responsibility.</p><h3>The sorrows</h3><p>The main downside of Swift's separate compilation model is that you need to keep the performance model in mind. Using generics from a shared library or using <code>any</code> types to introduce runtime polymorphism means additional overhead including more memory allocation (<code>any</code> types often need to use heap allocation) and slower execution time (due to indirection through what are effectively vtables). Use these features when it's the right way to solve your problem---runtime polymorphism is <em>great</em> when you need it---but don't develop the habit of reaching for them.</p><p>In Swift, you're a bit more dependent on the optimizer to eliminate the overhead of generic abstractions. C++ compilers pride themselves on having "zero abstraction penalty", meaning that one can template things to their heart's delight and the runtime code will be as efficient as if the code had been concrete (well, usually, and you do pay dearly in compile times for this privilege).</p><p>Swift's optimizer does a lot of monomorphization and inlining, and is improving with every release, so you certainly can get to zero abstraction penality when working with Swift generics and concrete types. However, if you're building massive towers of protocol abstractions, it's going to a lot harder for the compiler to eliminate all of the abstractions, and you'll end up paying for the abstraction either in compile times (as we do in C++) or in runtime performance (also happens in C++, but moreso in Swift).</p><p>One thing I've seen play out many times with C++ programmers coming to Swift is that they discover Swift generics and go <em>wild</em> with protocols, building massive and intricate protocol hierarchies. I suspect that this is a combination of having the runtime expectations of C++ (abstraction is free at runtime) along with the newly-discovered benefits of separate type checking (abstraction is free at design time) that leads them here. C++ gives you free-at-runtime abstraction but makes it very hard to debug when complicated templates go wrong, so I expect we unconsciously limit ourselves to fewer templates if we can get away with it. With Swift, it's so much easier to build these towers of abstraction that the abstracting itself becomes fun (generic programming is <em>fun</em>), and we only realize the pain later on in slower compile times or execution time. Programmers coming to Swift from other languages don't seem as susciptible to this, so dear C++ aficionado---have fun, but exercise <em>some</em> restraint.</p><h3>Some advice</h3><p>My main advice is to keep things simple---build the abstractions you need to get useful, reusable generic implementations, but don't get lost in towers of abstraction. Whenever possible, use static polymorphism (generics), and fall back to runtime polymorphism (<code>any</code>) when you actually need to vary the types at runtime.</p><p>When you have something working, <em>turn on the optimizer</em> and <em>measure the performance</em> (in that order). That should go without saying, but I think a lot of us feel that we've developed a mental model for the performance of C++, and we get complacent about actually measuring it. The performance model of Swift is a bit different from C++, so it's more important to measure, and you'll develop a mental model over time. Even then, you should still measure---regardless of the language you choose.</p><h2>Wrap-up</h2><p>Swift's generics are a wonderful way to do generic programming. Protocols make it easy to describe the type abstractions, and <code>where</code> clauses let you express the constraints on a generic function or type. Extensions of protocols make it easier than ever to write generic algorithms, with nary an angle bracket in sight. Conformances make it clear which types implement which protocols, and how.</p><p>Throughout your generics journey in Swift, separate type checking has your back. It's hard to express how different it is from the experience of working with C++ templates, because this entire failure mode---instantiation backtraces---is just <em>gone</em>. For me, it makes generic programming fun, and I'm never afraid to go generalize some code. You just have to try it.</p><p>This has been a very, very long post. Thanks for reading all the way to the end! My next post is going to go further into something we touched on here: <em>type erasure</em>. There's a lot of expressivity to be gained in proper use of runtime polymorphism, and we're going to explore it all.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-extensions</guid><title>Swift for C++ Practitioners, Part 3: Extensions and Access Control</title><description>Swift for C++ Practitioners, Part 3: Extensions &amp; Access Control</description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-extensions</link><pubDate>Fri, 1 Mar 2024 10:14:00 -0500</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 3: Extensions and Access Control</h1><p>Let's take a short break from the Swift type system to talk a bit about code organization in Swift, which is quite different from how it's handled in C++. This post will cover Swift's extensions, modules, and access control. I'll throw in some other little expressivity tricks like computed properties and subscripts as well.</p><h2>Free function or member function?</h2><p>In C++, whenever we want to introduce a new function for a type <code>X</code>, we have two choices: create a "free function" (at namespace scope) or a member function (which lives inside the class). The choice impacts a number of things: the syntax you use to call the function (<code>f(x)</code> vs. <code>x.f()</code>), which header can declare the function, how access control works, and so on.</p><p>Much of the advice in the C++ community says that we should <a href="https://danielsieger.com/blog/2023/05/01/cpp-member-vs-free-functions.html">prefer free functions to member functions</a>. There are a number of very good reasons why:</p><ul><li>Free functions can be added by anyone, not just the author of the class, so they are more general.</li><li>Free functions can be kept local to a single implementation file (e.g., by making them <code>static</code> or putting them in an anonymous namespace).</li><li>Free functions make for better customization points in templates, because they can be added for any existing type, including built-in types. (This is why <a href="https://en.cppreference.com/w/cpp/iterator/begin"><code>std::begin</code></a> and <a href="https://en.cppreference.com/w/cpp/iterator/end"><code>std::end</code></a> exist, for example).</li></ul><p>The problem is that free functions are more clunky to use than member functions. Many functions naturally operate on some primary value, and writing <code>x.f()</code> or <code>x-&gt;g()</code> is clearer than <code>f(x)</code> or <code>g(*x)</code> for operating on a value of <code>x</code>. Member functions are more discoverable by documentation and tools---it's far easier to look at the documentation for members of <code>std::vector</code> than it is to look through all of the algorithms in <code>std::</code> that might apply to an instance of <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>, and code completion after <code>x.</code> or <code>x-&gt;</code> gives useful context for finding the function you're looking for while writing code. Moreover, member functions compose together nicely when you're operating on the resulting value of each function, e.g., <code>x.f().g().h()</code>. Writing that same chained operation with free functions involves inverting the logic to <code>h(g(f(x)))</code>. It's okay, but it's harder to read, and harder to write.</p><p>All of these are small things by themselves, but together they make it hard to justify following the advice to "prefer free functions to member functions." The end result of following that advice might be more flexible, but it's harder to use. So we end up not following the advice, or duplicating functionality, like how <code>std::begin</code> wraps <code>std::vector::begin</code> because the former is more general but the latter is more usable.</p><h2>Extensions</h2><p>In Swift, you can add new members to any type by writing an <em>extension</em> of that type. For example, let's say that we have a simple struct representing a point in 2-D space:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
}
</code></pre><p>And then we'd like to add some new operations to <code>Point</code>. For example, let's create some operations that can help move the point around in space: one to move it by some amount in the x or y coordinates, another to flip it over the horizontal or vertical axis. These could be free functions, but it's nicer to use an extension to make them member functions like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">func</span> translated(deltaX: <span class="type">Double</span>, deltaY: <span class="type">Double</span>) -&gt; <span class="type">Point</span> {
		<span class="type">Point</span>(x: x + deltaX, y: y + deltaY)
  }
  
  <span class="keyword">func</span> flipped(axis: <span class="type">Axis</span>) -&gt; <span class="type">Point</span> {
    <span class="keyword">switch</span> axis {
      <span class="keyword">case</span> .<span class="dotAccess">horizontal</span>: <span class="type">Point</span>(x: x, y: -y)
      <span class="keyword">case</span> .<span class="dotAccess">vertical</span>: <span class="type">Point</span>(x: -x, y: y)
    }
  }
}
</code></pre><p>Now, we can go ahead and use these member functions together:</p><pre><code><span class="keyword">let</span> p2 = p1.<span class="call">translated</span>(deltaX: <span class="number">1</span>, deltaY: -<span class="number">0.5</span>)
  .<span class="call">flipped</span>(axis: .<span class="dotAccess">horizontal</span>)
</code></pre><p>Anyone can add an extension to any type. So long as the extension is visible to you, the members added via extension are used exactly the same way as members that were defined with the original type. Extensions allow one to organize the different aspects of a type's API: the data members, initializers, primary operations, and (for a class) deinitializer and overridable methods go into the primary definition of the type, which must contain all of the information needed to determine how the type is laid out in memory. From there, any number of extensions can be used to provide different conceptual slices of the type's API. The <code>Point</code> extension above provides the APIs that move the point around in space. Another extension might provide serialization or printing support, with yet another extension containing distance computations between this point and other objects. Although we won't get to generics until the next post, I'll spoil things a little bit to say that extensions are critical there, too: they satisfy customization points and make it exceptionally easy to write generic algorithms that operate across all sets of types.</p><h3>Computed properties</h3><p>An extension can also add new properties to a type, but only if they are <em>computed</em> properties, i.e., ones whose values are computed from other existing values. For example, we could add computed property to determine the distance of a point from the origin, i.e., it's magnitude:</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">var</span> magnitude: <span class="type">Double</span> {
    <span class="call">sqrt</span>(x*x + y*y)
  }
}
</code></pre><p>The curly braces indicate that this property is a computed property, and contain the code that computes the property's value. The <code>magnitude</code> computed property works like any other property, e.g.,:</p><pre><code><span class="call">print</span>(<span class="string">"Point</span> \(p) <span class="string">has magnitude</span> \(p.<span class="property">magnitude</span>)<span class="string">"")</span>
</code></pre><p>Now, the <code>magnitude</code> property is read-only: there's no way to assign to it, or pass it <code>inout</code>, because it doesn't make sense to modify the magnitude of a point. However, we can define some read/write computed properties by writing out explicit <code>get</code> and <code>set</code> functions within the curly braces. Let's do it for one of our standard examples, a view on the point using polar coordinates (angle and radius):</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">var</span> angle: <span class="type">Double</span> {
    <span class="keyword">get</span> { <span class="call">atan2</span>(y, x) }
    <span class="keyword">set</span> { 
      <span class="keyword">self</span> = .<span class="keyword">init</span>(angle: newValue, radius: radius)
    }
  }
  
  <span class="keyword">var</span> radius: <span class="type">Double</span> {
    <span class="keyword">get</span> { magnitude }
    <span class="keyword">set</span> { 
      <span class="keyword">self</span> = .<span class="keyword">init</span>(angle: angle, radius: newRadius)
    }
  }

  <span class="keyword">init</span>(angle: <span class="type">Double</span>, radius: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(x: radius * <span class="call">cos</span>(angle), y: radius * <span class="call">sin</span>(theta))
  }
}
</code></pre><p>This extension has provided a fairly complete API for <code>Point</code> with polar coordinates: you can read or write <code>angle</code> and <code>radius</code> to manipulate the point's location via polar coordinates, or create a new <code>Point</code> instance from polar coordinates with the given initializer. Within the <code>set</code> functions, <code>newValue</code> is the name of an implement parameter containing new value to which the property is being set. If you want, you can rename it by providing a different name, e.g., <code>set(newAngle) { ... }</code>), but folks don't tend to do this often.</p><p>When manipulating a <code>Point</code> via the Polar APIs, the result is still always stored in terms of the Cartesian coordinates <code>x</code> and <code>y</code>. Indeed, without looking at the implementation of the <code>Point</code> type, you can't even necessarily tell whether you're dealing with a computed property or a stored property. This is generally a good thing, because it means that the type can be refactored to change the way it stores its data (say, to provide indirection or add a caching layer) without requiring that clients change their code at all. It's another small thing, but in Swift you choose between a function or a property based on the syntax you want for your API, not based on the implementation details. And you won't have to write spurious getter/setter functions for every single non-static data member "just in case" you need them later.</p><p>However, this abstraction from the actual storage can also be a bit unsettling as a user if you don't have a good mental model of how the types will perform, especially coming from C++ where you expect to be close to the machine model. The <a href="https://www.swift.org/documentation/api-design-guidelines/#naming">Swift API design guidelines</a> have something to say about this: computed properties should generally be cheap to compute (i.e., amortized constant time), and should refer to some aspect of the part of the type's state. If you have something that's expensive to compute (say, the smallest element in an array) or represents a transformation of the whole value (say, a view of an array with the elements reversed), it should be a function.</p><h3>Extending "standard" types</h3><p>Early in this post, I pointed out that free functions in C++ are used in templates because they can be implemented for built-in types. For example, there's no way to add a member function named <code>begin</code> to a C++ pointer or array type, but you can implement a <code>begin</code> operation as a free function on an array of fixed size:</p><pre><code>template&lt;typename <span class="type">T</span>, std::size_t <span class="type">N</span>&gt;
<span class="type">T</span>* <span class="call">begin</span>(<span class="type">T</span> (&amp;array)[<span class="type">N</span>]) {
  <span class="keyword">return</span> array;
}
</code></pre><p>In Swift, most of the types one thinks of as built-in---integers, floating point numbers, Booleans, optionals, arrays, etc.---are actually structs or enums provided by the standard library. Therefore, you can extend them with new functionality. For example, maybe we want to add a property that determines whether a given integer is prime. We can do so by extending <code>Int</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Int</span> {
  <span class="keyword">var</span> isPrime: <span class="type">Bool</span> {
    <span class="keyword">switch</span> i {
      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return false
      case</span> <span class="number">1</span>: <span class="keyword">return true
      default</span>: <span class="keyword">break</span>
    }
    
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="call">abs</span>(<span class="keyword">self</span>) {
      <span class="keyword">if self</span> % i == <span class="number">0</span> {
        <span class="keyword">return true</span>
      }
    }
    
    <span class="keyword">return false</span>
  }
}
</code></pre><p>This is where extensions show their value: you can extend any type, from anywhere, with new functionality without paying a "syntax penalty" (shall we call it a "<em>syn</em> tax"?) for being outside of the definition of the type or its enclosing module. "Free function or member function?" is a matter of API design, not a decision forced on you by the language. Once you get used to these in Swift, you'll really start to miss them in C++. I certainly do.</p><h3>Subscripts</h3><p>One of my favorite parlor tricks is to add support for manipulating specific bits within an integer by treating it like an array of <code>Bool</code> values, e.g.,</p><pre><code><span class="keyword">var</span> flags: <span class="type">UInt32</span> = 0b1001
flags[<span class="number">2</span>] = <span class="keyword">true</span>  <span class="comment">// set bit #2</span>
flags[<span class="number">0</span>] = <span class="keyword">false</span> <span class="comment">// clear bit #0</span>
</code></pre><p>The code is a straightforward extension of the <code>UInt32</code> type from the standard library, but it also requires that we introduce one more feature: the use of <code>subscript</code> to define a new subscript, which is the Swift equivalent of the C++ <code>operator[]</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">UInt32</span> {
  <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">get</span> {
			(<span class="keyword">self</span> &amp; <span class="type">UInt32</span>(<span class="number">1</span>) &lt;&lt; index) != <span class="number">0</span>
    }
    
    <span class="keyword">set</span> {
      <span class="keyword">let</span> mask = <span class="type">UInt32</span>(<span class="number">1</span>) &lt;&lt; index
			<span class="keyword">self</span> = (<span class="keyword">self</span> &amp; ~mask) | (newValue ? mask : <span class="number">0</span>)
    }
  }
}
</code></pre><p>Note that subscripts in Swift are property-like: they can be read-only (just a <code>get</code>, optionally with the <code>get { ... }</code> elided) or read-write (if they also have a <code>set</code>). The subscript parameters are written in parentheses, like a function, and there can be any number of parameters. For example, a 2-D matrix type might take both the row and column:</p><pre><code><span class="keyword">extension</span> <span class="type">Matrix2D</span> {
  <span class="keyword">subscript</span>(i: <span class="type">Int</span>, j: <span class="type">Int</span>) -&gt; <span class="type">Double</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
}

<span class="call">print</span>(<span class="string">"Top level corner is</span> \(matrix[<span class="number">0</span>, <span class="number">0</span>])<span class="string">"</span>)
</code></pre><p>Subscripts can also have labeled arguments. For example, our same matrix type might want to provide subscript operations that provide access to an entire row or column as a vector:</p><pre><code><span class="keyword">extension</span> <span class="type">Matrix2D</span> {
  <span class="keyword">subscript</span>(row row: <span class="type">Int</span>) -&gt; <span class="type">Vector</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
  
  <span class="keyword">subscript</span>(column column: <span class="type">Int</span>) -&gt; <span class="type">Vector</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
}

<span class="call">print</span>(<span class="string">"First row is</span> \(matrix[row: <span class="number">0</span>])<span class="string">"</span>)
</code></pre><p>The <code>row row</code> bit is a little weird, and might cause you to start humming a nursery rhyme. It's a bit of an inconsistency in Swift that for functions and initializers, arguments are labeled by default (you would only write <code>row: Int</code>) whereas in subscripts the arguments are unlabeled by default (so you have to write <code>row row: Int</code> so that the caller will need to provide <code>row:</code>). When we made this choice, we opted to align with common usage (very few subscripts <em>want</em> labeled arguments) rather than overall consistency. Now, it feels like a wart. Either way, you still get to choose when you define the <code>subscript</code> what the argument labels will be.</p><p>Extensions let you go ahead and add members to any type, from anywhere. That sounds a little cool, but also a little scary: how does this not break encapsulation? To understand that, we need to dive into how code is organized in Swift, along with its access control model.</p><h2>Code organization</h2><p>In C++, code is organized into header files and implementation files. Header files (<code>.h</code>, <code>.hpp</code>, etc.) are generally for the interfaces to things---function declarations, type definitions, and so on---whereas implementation files (<code>.cpp</code>, <code>.cxx</code>, etc.) are generally for the code that implements those interfaces. Implementation files are generally compiled once and linked into the program, whereas header files will be included in many different implementation files and potentially vended to other clients.</p><p>Now, these are somewhat purist definitions that don't really match reality, because C++ header files actually contain a lot more than just the interface: they also need to have a lot of implementation details that are necessary to make the interfaces usable. For example, you need the declarations of all of the members of your C++ classes (even the <code>private</code> ones!) because they can only be declared in the header. You also need the definitions of any templates or macros that are part of the interface, because otherwise clients can't instantiate the template or expand the macro. (No, don't talk to me about <code>export</code>, I don't want to hear it). Indeed, the desire to hide away the private details of a C++ class from clients is why we have the <a href="https://en.cppreference.com/w/cpp/language/pimpl">pImpl idiom</a>, and various other techniques to keep implementation details in the implementation files and out of headers.</p><p>Swift takes a different approach to code organization and access control.</p><h3>Modules</h3><p>A Swift program is comprised of a number of modules. A module is a collection of APIs, such as functions and types, along with their implementations. Each module has a name (e.g., <code>Geometry</code>) that can be used to reference it, and access its public APIs. To access the public APIs of the <code>Geometry</code> module from another module, one must import it:</p><pre><code><span class="keyword">import</span> Geometry
</code></pre><p>Once that's done, all of the public APIs in the <code>Geometry</code> module are now available to you.</p><p>The actual creation of a module exists somewhat outside the Swift language: your build system will say what source files are part of a given module, and the name of that module, and all of those source files will be compiled together. Groups of modules can be organized into <a href="https://www.swift.org/packages/">packages</a>.</p><p>The import relationships amongst the modules in a program must form a Directed Acyclic Graph, or DAG: there cannot be any cycles where module <code>A</code> imports module <code>B</code> imports module <code>A</code>. C++ headers let you get away with such tricks, if your linker cooperates, but it's generally a bad idea that will come back to bite you later. With Swift, it'll bite you sooner, but it's predictable.</p><h3>Going <code>public</code></h3><p>By default, any code within a module can access any other code within that module. One nice aspect of this is that, when your program is a single module, you don't have to think about modules or access control at all: just write your code and ignore this feature of the language. We call this <em>progressive disclosure</em>, the idea that one can ignore certain aspects of the language when starting out, and then learn about them only at the time when you need them, without invalidating any of your prior understanding of the language.</p><p>You need access control when your program gets big enough that you want to split it into modules, or when you want to start providing your modules for someone else to use. If you haven't used any access control in your module, it's public interface is empty. <em>All</em> promises made by a Swift module to outside clients are explicit, so if you want to make a type available to clients, you have to say so by marking it <code>public</code>. Perhaps we want to make the <code>Point</code> type available to clients, which we could do like so:</p><pre><code><span class="keyword">public struct</span> Point {
  <span class="keyword">public var</span> x: <span class="type">Double</span>
  <span class="keyword">public var</span> y: <span class="type">Double</span>
}
</code></pre><p>Now, a client that imports our module (let's keep calling it <code>Geometry</code>) can access the <code>Point</code> type and both its <code>x</code> and <code>y</code> values. However, the client cannot create an instance of the <code>Point</code> type, because we haven't explicitly provided a <code>public</code> initializer. Let's revise our type to do so:</p><pre><code><span class="keyword">public struct</span> Point {
  <span class="keyword">public var</span> x: <span class="type">Double</span>
  <span class="keyword">public var</span> y: <span class="type">Double</span>
  
  <span class="keyword">public init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="property">x</span> = x
    <span class="keyword">self</span>.<span class="property">y</span> = y
  }
}
</code></pre><p>That's it! We've exposed the API we wanted public, and anything we didn't explicitly promise is an implementation detail. For example, the <code>translated(deltaX:deltaY:)</code>, <code>flipped(axis:)</code>, and <code>magnitude</code> operations we provided earlier are still implementation details.</p><blockquote><p><em>Aside</em>: At the point where you are marking things <code>public</code>, now would be a <em>really</em> good time to write some documentation for them. Use triple-slash (<code>///</code>) or Doxygen-style (<code>/** ... **/</code>) comment headers and <a href="https://www.markdownguide.org">Markdown</a>, then use the excellent <a href="https://www.swift.org/documentation/docc/#">DocC</a> to generate beautiful documentation. Trust me, your users will thank you. It's also a good way to review your whole API the way your clients will see it.</p></blockquote><p>Technically, any declaration that doesn't have an access specifier on it is <code>internal</code>, meaning "internal to its module". You can write out the <code>internal</code> if you want, but it's pretty rare for folks to do that in Swift.</p><h3>Files, <code>fileprivate</code>, and <code>private</code></h3><p>A module is comprised of one or more source files. The names of those source files don't matter to the Swift language, only to us programmers. However, files are part of Swift's access control model, and you can limit access to a particular declaration to the source file in which is resides (<code>fileprivate</code>) or to just its enclosing type within that source file (<code>private</code>). For example, we might want to do this so that the actual storage representation of our <code>Point</code> type is only accessible within a single source file, making it easy to audit and change. Let's use a SIMD type just for fun:</p><pre><code><span class="comment">// in Point.swift</span>
<span class="keyword">public struct</span> Point {
  <span class="keyword">private var</span> storage: <span class="type">SIMD2</span>&lt;<span class="type">Double</span>&gt;
}

<span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">public var</span> x: <span class="type">Double</span> {
    <span class="keyword">get</span> { storage[<span class="number">0</span>] }
    <span class="keyword">set</span> { storage[<span class="number">0</span>] = newValue }
  }
  
  <span class="keyword">public var</span> y: <span class="type">Double</span> {
    <span class="keyword">get</span> { storage[<span class="number">1</span>] }
    <span class="keyword">set</span> { storage[<span class="number">1</span>] = newValue }
  }
  
  <span class="keyword">public init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(storage: [x, y])
  }
}
</code></pre><p>The code above is valid. If we tried to move any part of the extension to another source file, we would get an error because <code>Point.storage</code> is only accessible in this source file. Moreover, it's only accessible to <code>Point</code> and its extensions within this source file, so we can't even refer to it from free functions in the same file</p><pre><code><span class="comment">// also in Point.swift</span>
<span class="keyword">func</span> printPoint(<span class="keyword">_</span> point: <span class="type">Point</span>) {
  <span class="call">print</span>(<span class="string">"</span>\(point.<span class="property">storage</span>)<span class="string">"</span>) <span class="comment">// error: storage is not accessible outside of Point in this file</span>
}
</code></pre><p>If we want the ability to access <code>storage</code> from this free function, we can mark it <code>fileprivate</code> rather than <code>private</code>.</p><p>You can think of Swift's <code>fileprivate</code> and <code>private</code> as filling the same role as anonymous namespaces or (non-member) <code>static</code> functions do in C++ implementation files: a way to write code that never escapes that one implementation file, so it isn't available to any other part of your program. But unlike anonymous namespaces or <code>static</code>, there's no "<em>syn</em> tax": you can reduce a declaration's access down to a single file with <code>fileprivate</code> or <code>private</code> without changing any other code in that source file, whereas in C++ you'd have to go change the way it's used and possibly edit the corresponding header.</p><h3>Extensions and source file naming</h3><p>Swift programmers tend to keep source files fairly small and dedicated to a particular task. For example, the <code>Point.swift</code> described above, which provides only the type definition and the one extension allowing access via Cartesian coordinates, might be the entire contents of the source file. All other functionality for <code>Point</code> would go into a separate source file, which would contain extensions. For example, the support for Polar coordinates would go into a source file <code>Point+Polar.swift</code>, whereas printing support could go into <code>Point+Printing.swift</code>. If you look at a sizable Swift module, you'll see lots of the <code>&lt;type&gt;+&lt;purpose&gt;.swift</code> source files:</p><pre><code><span class="type">Line</span>.<span class="property">swift</span>
<span class="type">Line</span>+<span class="type">Transforms</span>.<span class="property">swift</span>
<span class="type">Point</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Cartesian</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Codable</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Polar</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Printing</span>.<span class="property">swift</span>
</code></pre><p>At first, this approach surprised me: why break things up into so many small pieces? However, it keeps each source file manageable and focused. Moreover, each source file can present its API for the rest of the world (whether it's just this module or beyond), and then hide its implementation details with <code>private</code> or <code>fileprivate</code>.</p><p>There is a rough analogue to this in C++, where a single large class has its implementation scattered across a number of different implementation files, each of which implements a few of the member functions. Each of those implementation files might use anonymous namespaces or <code>static</code> functions to hide some of its implementation details from the other source files. It works, and we use it extensively in the various C++ code bases I've worked on, but it still means having an enormous header file that you're always touching.</p><h3>Packages</h3><p>Swift packages provide a way to "package up" and distributed a set of Swift modules together for use in Swift programs, and are supported by the <a href="https://www.swift.org/documentation/package-manager/">Swift Package Manager</a>. A package is a group of modules that is developed together, and has its own access control level: <code>package</code>. Use <code>package</code> access control when you need access to a particular API across the modules within your own package, but you don't want to make them public for anyone else. The <code>package</code> access level is particularly useful for unit tests, which often want access to functionality that should not be part of the public API vended to clients.</p><p>There is a lot more to be said about Swift packages, but I will leave them to a separate post. There's more access control to be had.</p><h3>No peeking!</h3><p>C++ has two access-control features that have no counterpart in Swift, and allow entities outside of the normal scope to access the private members of the type: <code>protected</code> and <code>friend</code>. While we could debate the merits of these features, I'll point out that we've received very few requests to add them (or something like them) into Swift over the years, and leave it at that.</p><h3>Inheritance and overriding</h3><p>Swift's access control design is centered around the idea of never implicitly promising anything to clients outside of the module. If it isn't marked <code>public</code>, it's an implementation detail, so you can change it. That helps programmers prevent getting accidentally stuck with an accidentally-published API that has amassed clients who didn't know better.</p><p>With object-oriented programming, there are additional concerns that an implementer needs to consider beyond clients just using an API. For a class, an implementer needs to consider whether it makes sense for clients to subclass a class and, if so, which methods can be overridden by those clients. Most OO languages, including C++, allow any (virtual) method to be overridden by clients unless explicitly marked as <code>final</code> (or <code>sealed</code>). Swift takes a slightly different approach: within a module, one is free to subclass any non-<code>final</code> class or override any non-<code>final</code> method declared in the same module. These are implementation details that are not exposed to clients.</p><p>However, outside of a module, a <code>public</code> class cannot be subclassed and a <code>public</code> method cannot be overridden. This is because designing a class for inheritance or a method for overriding takes extra care to maintain backward compatibility: what if the method is called as an implementation detail of another method? If so, you might be stuck maintaining that call sequence forever, even if future implementations of the class don't need it. Instead, Swift makes this an opt-in behavior via the access specifier <code>open</code>: an <code>open</code> class can be subclassed by anyone, and an <code>open</code> method can be overridden by anyone. <code>open</code> is more permissive than <code>public</code>, meaning that all <code>open</code> entities are implicitly <code>public</code>, so they can be both overridden and also used from outside the module. Here's a quick example:</p><pre><code><span class="comment">// module A</span>
<span class="keyword">open class</span> Superclass {
  <span class="keyword">open func</span> f() { }
  <span class="keyword">public func</span> g() { }
  <span class="keyword">public final func</span> h() { }
}

<span class="keyword">class</span> OtherClass: <span class="type">Superclass</span> {
	<span class="keyword">override func</span> f() { ... } <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> g() { ... } <span class="comment">// okay, it's in the same module</span>
  <span class="keyword">override func</span> h() { ... } <span class="comment">// error, it's final</span>
}

<span class="comment">// module B</span>
<span class="keyword">import</span> A

<span class="keyword">class</span> Subclass: <span class="type">Superclass</span> { <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> f() { ... } <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> g() { ... } <span class="comment">// error, it's in a different module and isn't open</span>
}
</code></pre><p>The <code>open</code> access specifier makes it clear where the extension points in an object-oriented hierarchy are, making this complicated contract between implementer and client explicit and clear.</p><h2>Wrap-up</h2><p>Early on, I linked to a post about <a href="https://danielsieger.com/blog/2023/05/01/cpp-member-vs-free-functions.html">prefering free functions</a>. It is one of many in the C++ world, and links out to various guidelines and talks that all come to roughly the same conclusion. Here are the reasons listed in that post for prefering free functions to member functions in C++:</p><ul><li><strong>Loose Coupling:</strong> A free function is more loosely coupled to the class it is operating on. It only depends on the interface. This also enables generic functions being usable with different concrete classes.</li><li><strong>Encapsulation and Hiding:</strong> A free function promotes encapsulation and information hiding since it does not have access to the implementation details of the class.</li><li><strong>Flexibility and Extensibility:</strong> Adding another free function is cheap and easy and does not require modification of the class definition.</li><li><strong>Testing:</strong> A free function is generally easier to test due to increased independence. No hacks required to test those pesky private member functions.</li></ul><p>Swift's extensions and access control address all of those reasons directly. Encapsulation and hiding are based on the organization of code into files, modules, and packages. You can add a member to a type from anywhere with an extension. The result of these aspects being orthogonal is that you get all of the loose coupling, enapsulating, flexibility, and extensibility of C++ "free functions", with the ergonomics of member functions. It's lovely.</p><p>Extensions are also a key part of the next part of our story: generics.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-reference-types</guid><title>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</title><description>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-reference-types</link><pubDate>Sat, 10 Feb 2024 12:00:00 -0500</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</h1><p>In our first episode, we talked a lot about value types. In general, you should prefer value types in Swift whenever you can.</p><p>However, Object-Oriented Programming (OOP) is a reasonable approach when you need your objects to have identity and to form relationships amongst each other in arbitrary ways. For these cases, Swift has classes with support for inheritance, overriding, and subtyping. A class is defined in Swift with---you guessed it---the <code>class</code> keyword:</p><pre><code><span class="keyword">class</span> Person {
  <span class="keyword">var</span> name: <span class="type">String</span>
  <span class="keyword">var</span> age: <span class="type">Int</span>
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
    <span class="keyword">self</span>.<span class="property">age</span> = age
  }
  
  <span class="keyword">func</span> greet() {
    <span class="call">print</span>(<span class="string">"Hello</span> \(name)<span class="string">!"</span>)
  }
}
</code></pre><p>Classes look a lot like structs, with all the same basic ingredients: stored properties ("non-static data members" in C++ parlance), initializers, methods, etc. Each of these ingredients works basically the same way, so if you know how to write a struct, you're pretty close to writing a class. In fact, you could take nearly any <code>struct</code> from my value-types post and use the <code>class</code> keyword, and it would probably compile! However, even though it will compile, it will behave <em>radically</em> differently, because...</p><h2>Classes have reference semantics</h2><p>Let's say we have a little <code>Temperature</code> struct:</p><pre><code><span class="keyword">struct</span> Temperature {
  <span class="keyword">var</span> fahrenheit: <span class="type">Double</span>
  
  <span class="keyword">init</span>(fahrenheit: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="property">fahrenheit</span> = fahrenheit
  }
}
</code></pre><p>And some sensible-looking code:</p><pre><code><span class="keyword">var</span> temp = <span class="type">Temperature</span>(fahrenheit: <span class="number">70</span>)
home.<span class="property">thermostat</span>.<span class="property">temperature</span> = temp

temp.<span class="property">fahrenheit</span> = <span class="number">400</span>
home.<span class="property">oven</span>.<span class="property">temperature</span> = temp
home.<span class="property">oven</span>.<span class="call">bake</span>()
</code></pre><p>Fine, right?</p><p>If we change that <code>struct</code> to a <code>class</code>, everything will still compile fine... but it's going to get really, really hot in here. When <code>Temperature</code> is a class, it has reference semantics: there is one instance <code>temp</code> created in the first line, and that instance is shared between the thermostat and the oven, so changing the temperature on one affects the other.</p><p>There are times when reference semantics are the right way to model your problem, and classes are great for those. <code>Temperature</code> is an example of something that should remain a struct, because it is intrinsically a value. The key distinguishing characteristics for choosing a class is when you need <em>identity</em> and <em>sharing</em>, such that two different places in your code need to be able to refer to the same entity, and see the effects of each other's changes to that entity.</p><p>Coming from C++, there are other clues as to whether to choose <code>struct</code> or <code>class</code>. If in C++ you would always pass around the type by pointer or reference (whether a raw pointer or a smart pointer like <code>std::shared_ptr</code>), or ever comparing the address of the instances, or if you're going to be deleting the copy constructor, then you probably have reference semantics and should use a <code>class</code> in Swift. C++ features like <code>virtual</code> functions or <code>dynamic_cast</code> are also indicators of reference semantics, but they aren't as strong: these could be merely implementation mechanisms for something else.</p><p>Most importantly, in C++ we often use inheritance to get implementations for free in a new type, even without <code>virtual</code> functions. The <a href="https://en.cppreference.com/w/cpp/language/crtp">Curiously Recurring Template Pattern (CRTP)</a> is one such pattern that uses C++ inheritance even in types that have value semantics. This pattern does <em>not</em> translate well into Swift, and there are alternative ways to express this kind of polymorphism through the generics system and so-called "protocol extensions". The fact that one would use inheritance in C++ to model a problem is not a good indicator that one should use classes in Swift. Instead, it all comes back to reference semantics and identity.</p><h2>Inheritance &amp; overriding</h2><p>Swift classes allow single inheritance, with overriding of methods. Let's create a subclass of <code>Person</code> for employees of some company:</p><pre><code><span class="keyword">class</span> Employee: <span class="type">Person</span> {
  <span class="keyword">let</span> badgeNumber: <span class="type">Int</span>
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, badgeNumber: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">badgeNumber</span> = badgeNumber
    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)
  }
  
  <span class="keyword">override func</span> greet() {
    <span class="call">print</span>(<span class="string">"Hello</span> \(name)<span class="string">, your badge number is</span> \(badgeNumber)<span class="string">!"</span>)
  }
}
</code></pre><p>The base class (which we call the <em>superclass</em> in Swift) is specified after the colon. There can be at most one superclass, which keeps Objected-Oriented hierarchies a lot more simple and direct. The expressivity gap with C++'s support for multiple inheritance is mostly filled by the generics system, which we'll get to later (sorry, I keep saying that).</p><p>All inheritance is effectively <code>public</code>. There's no notion of <code>private</code> inheritance, and <code>protected</code> doesn't even exist in Swift. I'm going to ignore Swift's access control for a while longer, and note that when all of your code is in one Swift module, you often don't think about access control, and it's fine.</p><p>Our <code>Employee</code> type has an initializer and a <code>greet</code> method. The <code>greet</code> method overrides the one declared in <code>Person</code>, as indicated by the <code>override</code> keyword. Class members are effectively <code>virtual</code> by default, although one can explicitly mark a specific class or class member as <code>final</code> to cut off all subclassing or overriding for that entity for good. Subtyping and virtual dispatch works as one would expect:</p><pre><code><span class="keyword">let</span> person: <span class="type">Person</span> = <span class="type">Employee</span>(name: <span class="string">"Doug"</span>, age: <span class="number">39</span>, badgeNumber: <span class="number">1</span>)
person.<span class="call">greet</span>() <span class="comment">// prints "Hello Doug, your badge number is 1!"</span>
</code></pre><h2>Member initialization is... backwards?</h2><p>If you looked at the body of that initializer for <code>Employee</code>, it might have freaked you out a little bit:</p><pre><code>   <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, badgeNumber: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">badgeNumber</span> = badgeNumber
    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)
  }
</code></pre><p>Notice how we initialized the data members of our subclass (or "derived class" in C++ parlance) first, and <em>then</em> called the superclass initializer. Weird, right?</p><p>This is absolutely not how C++ works: C++ initializes the base classes first, and then the members of the derived class, and then executes the code in the constructor of the derived class. But the C++ model has some weird behaviors with virtual function calls <a href="https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors">in constructors</a> that fall out of it. Let's see what happens if we write the above classes in C++ and try to greet the person in the constructor:</p><pre><code><span class="keyword">class</span> Person {
public:
  std::string name;
  int age;
  
  <span class="type">Person</span>(const std::string &amp;name, int age) : <span class="call">name</span>(name), <span class="call">age</span>(age) {
    <span class="call">greet</span>()
  }
  
  virtual void <span class="call">greet</span>() {
    std::cout &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;
  }
}

<span class="keyword">class</span> Employee: <span class="keyword">public</span> <span class="type">Person</span> {
  int badgeNumber;
  
  <span class="type">Employee</span>(const std::string &amp;name, int age, int badgeNumber) 
    : <span class="type">Person</span>(name, age), <span class="call">badgeNumber</span>(badgeNumber) { }
  
  void <span class="call">greet</span>() <span class="keyword">override</span> {
    std::cout &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; name &lt;&lt; <span class="string">", your badge number is "</span> &lt;&lt; badgeNumber &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;
  }
}

<span class="type">Person</span> *person = new <span class="type">Employee</span>(<span class="string">"Doug"</span>, <span class="number">39</span>, <span class="number">1</span>) <span class="comment">// prints "Hello Doug!"</span>
person-&gt;<span class="call">greet</span>(); <span class="comment">// prints "Hello Doug, your badge number is 1!"</span>
</code></pre><p>Weird-er, right? The problem with calling virtual functions in constructors is that the base class constructor doesn't have a fully-formed object of the subclass type, because the members of the derived class haven't been initialized yet, and it would be undefined behavior to access them. So it's not safe for the <code>Person</code> constructor to treat the object as the <code>Employee</code> instance it will eventually be. Instead, it treats the object as an instance of <code>Person</code>, calling <code>Person::greet</code> instead of <code>Employee::greet</code>, causing the difference in behavior above. This is also the reason that it's possible to get errors at runtime due to calls to abstract virtual functions in C++, even though the language prevents you from creating an instance of an abstract type. Supporting this weird semantics is also awful for C++ compiler writes; <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-ctor">read this</a> if you'd like to feel bad for them.</p><p>Okay, back to Swift. If we go put a call to <code>greet</code> in the initializer for <code>Person</code>, we'll get consistent output:</p><pre><code><span class="type">Hello Doug</span>, your badge number <span class="keyword">is</span> <span class="number">1</span>
<span class="type">Hello Doug</span>, your badge number <span class="keyword">is</span> <span class="number">1</span>
</code></pre><p>The "backwards" initialization required by Swift, where you must initialize all of your own data members before calling your superclass initializer (via <code>super.init</code>), gives an important guarantee: the superclass initializer knows that all of it's subclasses have already initialized all of their own data members before it ever runs. Follow that logic all the way up to the root class's initializer (which has no superclass), and we know that once that initializer has initialized all of its own data members, the object is fully-initialized with its final type. Definite Initialization then makes <code>self</code> available (which happens after the <code>super.init</code> call in non-root classes), so you can call any overridden method in an initializer and get a consistent result. So the Swift approach, while weird at first, provides more consistent semantics with less syntax than C++, and doesn't require any kind of "default" state for data members. Sometimes weird is actually good, eh?</p><h2>Deinitializers</h2><p>Unlike structs and enums, an instance of a class has a well-defined point at which it is destroyed (when it is no longer used). At this point, one can execute cleanup code in the <em>deinitializer</em>. A Swift deinitializer is like a C++ destructor, except it's written as <code>deinit</code> like this:</p><pre><code><span class="comment">// in Person</span>
<span class="keyword">deinit</span> {
  <span class="call">print</span>(<span class="string">"</span>\(name) <span class="string">has expired"</span>)
}
</code></pre><p>Deinitializers are never overridden in the sense that methods are. Rather, all of the deinitializers in the class hierarchy are executed from the most-derived class to the root class, and then all of the data members are destroyed.</p><h2>Downcasting</h2><p>Let's say you have a <code>Person</code> and you want to check whether it's actually an instance of <code>Employee</code>. In C++, you would use <code>dynamic_cast</code> to perform the cast dynamically. In Swift, we use <code>as?</code>, like this:</p><pre><code><span class="keyword">func</span> checkIfEmployee(person: <span class="type">Person</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">if let</span> employee = person <span class="keyword">as</span>? <span class="type">Employee</span> {
    <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
    <span class="keyword">return true</span>
  }
  
  <span class="keyword">return false</span>
}
</code></pre><p>The way to read this is that we are attempting to downcast the <code>person</code> instance into an <code>Employee</code>. If it succeeds, we'll enter the body of the <code>if let</code> with the variable <code>employee</code> bound to the same instance as <code>person</code>, but with type <code>Employee</code>. If it fails, the <code>if</code> body doesn't run.</p><p>Now, sometimes we <em>know</em> based on other invariants in the program that a particular person instance must be an <code>Employee</code>. In C++, you would use a <code>static_cast</code> here (or a <code>dynamic_cast</code> on a reference to the type). In Swift, you can use <code>as!</code>, e.g.,</p><pre><code><span class="call">print</span>(<span class="string">"Employee badge number is #</span>\((person <span class="keyword">as</span>! <span class="type">Employee</span>).<span class="property">badgeNumber</span>)<span class="string">"</span>)
</code></pre><p>Swift is going to check this cast at runtime, and halt the program with an error message if <code>person</code> is not, in fact, an <code>Employee</code>. The <code>as!</code> cast should be used only in rare cases where you're unable to express what you need through the type system, and other invariants ensure that it will always succeed. Just like we always do with <code>static_cast</code> in C++, right? RIGHT?</p><h2>Optionals</h2><p>In bundling together the <code>as?</code> cast and the <code>if let</code> in the example above, I glossed over what's actually happening here. Specifically, the <code>as?</code> can be used anywhere, and it produces a value of <em>optional</em> type. If we were to write:</p><pre><code><span class="keyword">let</span> maybeEmployee = person <span class="keyword">as</span>? <span class="type">Employee</span>
</code></pre><p>The type of <code>maybeEmployee</code> is <code>Employee?</code>, where the question mark implies that might have an <code>Employee</code>, or we might have nothing. If you've used the C++ <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>, it's the same idea, but with syntactic sugar in Swift to make it more ergonomic. <code>if let</code> is one of the ways to check whether there's a value inside an optional:</p><pre><code><span class="keyword">if let</span> employee = maybeEmployee {
  <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
} <span class="keyword">else</span> {
  <span class="comment">// employee is not available</span>
}
</code></pre><p>Here, the <code>if let</code> is checking whether the optional value to the right-hand side of <code>=</code> actually contains a value. If so, it pulls that value out and puts it into the variable declared to the left of the <code>=</code>. Otherwise, the body of the <code>if</code> doesn't run, but the <code>else</code> block (if present) would be executed. The <code>else</code> block does not have access to the <code>employee</code> variable at all.</p><h3>Options for accessing optionals</h3><p><code>if let</code> is the most popular way to extract a value out of an optional, but it isn't the only one. There is also the dual to <code>if</code>, called <code>guard</code>, which helps with the "early returns" style of programming. We could refactor the code above to look like this:</p><pre><code><span class="keyword">guard let</span> employee = maybeEmployee <span class="keyword">else</span> {
  <span class="comment">// employee is not available</span>
  <span class="keyword">return false</span>
}

<span class="comment">// employee is an Employee instance. Use it for the rest of the function</span>
<span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
<span class="keyword">return true</span>
</code></pre><p>A <code>guard</code> statement checks that its conditions are true, which can involving introducing new variables. It also requires an <code>else</code> block that <em>must return</em>, so there is no way to fall out of the <code>else</code> block and into later code. Early returns are <a href="https://www.fluentcpp.com/2018/08/24/how-to-design-early-returns-in-c-based-on-procedural-programming/">surprisingly controversial</a> in C++, I think because you have to mentally dig for the <code>return</code> along all of the paths in the early-returning <code>if</code>. Swift's <code>guard</code> addresses those concerns by giving this pattern a specific keyword up front (<code>guard</code>), making the condition a positive one (you pass the guard if this condition holds), and ensuring that if the condition fails you always do an early return. Enough about <code>guard</code>; back to optionals, shall we?</p><p>The third way one can look into an optional is with a <code>switch</code>, because the <code>?</code> syntax is actually just synactic sugar for a use of the generic <code>Optional</code> type that's defined in the Swift standard library. It looks like this:</p><pre><code><span class="keyword">enum</span> Optional&lt;Wrapped&gt; {
  <span class="keyword">case</span> none
  <span class="keyword">case</span> some(<span class="type">Wrapped</span>)
}
</code></pre><p>The <code>none</code> case means there is no value, and the <code>some</code> case means that there is a value of type <code>Wrapped</code>. The angle brackets are for generics, as one would expect, declaring that <code>Optional</code> has a type parameter (akin to a <em>template type parameter</em> in C++). Given a value of optional type, you can switch on the two cases:</p><pre><code><span class="keyword">switch</span> maybeEmployee {
  <span class="keyword">case</span> .<span class="dotAccess">none</span>:
    <span class="keyword">return false
  
  case</span> .<span class="dotAccess">some</span>(<span class="keyword">let</span> employee):
    <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
    <span class="keyword">return true</span>
}
</code></pre><h3>Optionals for dictionary access</h3><p>Optionals can be formed from any type, and are useful for APIs that might return "no result". One great example of this is accessing elements within a Swift <a href="https://developer.apple.com/documentation/swift/dictionary"><code>Dictionary</code></a>, which is like a <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a>, by looking for an element with a specific key. Let's say we create a dictionary that maps from badge numbers to the employee with that badge number, like this:</p><pre><code><span class="comment">// Create a dictionary from (badgeNumber, employee) pairs</span>
<span class="keyword">let</span> employeesByBadgeNumber: [<span class="type">Int</span>: <span class="type">Employee</span>] = .<span class="keyword">init</span>(uniqueKeysWithValues: employees.<span class="call">map</span> { 
  employee <span class="keyword">in</span> (employee.<span class="property">badgeNumber</span>, employee)
})
</code></pre><p>The use of closures will be explained in a separate post, but if you're used to C++ lambdas, it probably looks familiar already. The <code>[Int: Employee]</code> syntax is sugar for a <code>Dictionary</code> mapping from <code>Int</code> keys to <code>Employee</code> values. It mirrors the syntax of dictionary literals, i.e., <code>[1: doug]</code> is a dictionary containing a single entry mapping <code>1</code> to the <code>doug</code> instance.</p><p>We can look for the employee with a given badge number by subscripting this dictionary. The result of the subscript is going to be an <code>Employee?</code>, i.e., it's the employee if one with that badge number was found, or <code>nil</code> otherwise, which works very nicely with <code>if let</code>:</p><pre><code><span class="keyword">if let</span> employee = employeesByBadgeNumber[<span class="number">17</span>] {
	employee.<span class="call">greet</span>()
}
</code></pre><p>again, the type system is helping here: the obvious way to find the value associated with a key is to use subscript, and it returns an optional so you're sure to handle the case where the value is missing. If you find yourself longing for the insert-a-default-if-nothing-is-there behavior of C++'s <code>std::map</code> and <code>std::unordered_map</code>, there's a special subscript just for you that also takes a default. You could use it like this, say, to count word frequency in a list of words:</p><pre><code><span class="keyword">var</span> frequency: [<span class="type">String</span>: <span class="type">Int</span>] = [:]
<span class="keyword">for</span> word <span class="keyword">in</span> words {
  frequency[word, default: <span class="number">0</span>] += <span class="number">1</span>
}
</code></pre><p>The subscript that takes a default value produces a non-optional value, because an entry <code>[word: 0]</code> will be added if one wasn't already present. So, we can increment the frequency of each word directly.</p><h3>Optional chaining</h3><p>Optionals are really common in Swift code, so the language has a number of affordances to make them easier to work with. For example, earlier we wanted to greet an employee with the given badge number, so we wrote this:</p><pre><code><span class="keyword">if let</span> employee = employeesByBadgeNumber[<span class="number">17</span>] {
	employee.<span class="call">greet</span>()
}
</code></pre><p>This code is fine. It will work. But it's a little bit verbose, with the whole <code>if-let</code> dance to create a new variable. Instead, one can use optional <em>chaining</em> to call the <code>greet</code> method only when there is an employee, like this:</p><pre><code>employeesByBadgeNumber[<span class="number">17</span>]?.<span class="call">greet</span>()
</code></pre><p>The <code>?</code> in this case means that we're doing optional chaining. It is followed by accesses into the instance (i.e., <code>.greet()</code>) that only happen when there is a value inside the optional. You can even chain multiple optional accesses together. For example, let's imagine that our <code>Employee</code> class added a <code>manager</code> data member, i.e.,</p><pre><code><span class="keyword">var</span> manager: <span class="type">Employee</span>? = <span class="keyword">nil</span>
</code></pre><p>We could get the name of the employee 17's manager like this:</p><pre><code><span class="keyword">let</span> managerName = employeesByBadgeNumber[<span class="number">17</span>]?.manager?.<span class="property">name</span>
<span class="comment">// &gt;----------------------------------------^--------^----&gt;
//                                          1        2</span>
</code></pre><p>Evaluation is left-to-right in Swift, so you can read this as looking in the dictionary for an employee with badge number 17. If that <code>Employee?</code> result contains an <code>Employee</code> (i.e., it is not <code>nil</code>) at the point marked #1, then we access the manager of that employee. If the manager data member contains an <code>Employee</code> at the point marked #2, then we access the name of that manager instance.</p><p>But what is the type of the <code>managerName</code> variable? Well, we know that <code>Employee.name</code> is a <code>String</code>, but of course at either #1 or #2 we might have encountered a <code>nil</code> and had to stop evaluation. We can't just leave <code>managerName</code> undefined (gasp!), so instead it gets type <code>String?</code>, where it either stores the result of completing the optional chain or it <code>nil</code> if a <code>nil</code> was encountered along the way.</p><h3>Optionals replace the dreaded NULL</h3><p>In Swift, an instance of class type can never be NULL. If you have a value <code>employee</code> of type <code>Employee</code>, there is always a valid instance there. Instead of NULL pointers, Swift uses optionals: <code>Employee?</code> is either a value employee, or it's <code>nil</code>. But unlike the C++ equivalent of <code>Employee*</code>, Swift has static affordances to make it easy to use optionals correctly. That means no NULL pointer dereferences, no defensive checks against NULL when you're not sure. Unless you're one of the few using a <a href="https://www.cppstories.com/2017/10/notnull/"><code>not_null</code> smart pointer type</a>), it may surprise you at just how liberating it is to stop thinking about the special case of NULL everywhere and let the type checker support you.</p><h3>Aside: How big is an optional?</h3><p>One last little fun bit of trivial: if I run this C++ code, what values should we expect to get?</p><pre><code><span class="keyword">class</span> Employee { };

int <span class="call">main</span>() {
  std::cout &lt;&lt; <span class="call">sizeof</span>(<span class="type">Employee</span>*) &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="call">sizeof</span>(std::optional&lt;<span class="type">Employee</span>*&gt;) &lt;&lt; std::endl;
}
</code></pre><p>On my system, I get 8 and 16, respectively. Using <code>std::optional</code> doubles the storage needed!</p><p>Now what happens with the Swift equivalent code?</p><pre><code><span class="keyword">class</span> Employee { }

<span class="call">print</span>(<span class="type">MemoryLayout</span>&lt;<span class="type">Employee</span>&gt;.<span class="property">size</span>)
<span class="call">print</span>(<span class="type">MemoryLayout</span>&lt;<span class="type">Employee</span>?&gt;.size)
</code></pre><p>I get 8 for both! Swift is doing an important space optimization behind the scenes: because an <code>Employee</code> must refer to a valid address, and the integral value of 0 is not a valid address, Swift will use the integer representation <code>0</code> to mean the <code>.none</code> of the optional (which corresponds to <code>nil</code>) and all other values to mean the <code>.some</code> case of the optional. Therefore, it can use a single pointer's width of storage to capture an optional value. This is generally good for memory usage, but it's also really important for interoperability with C++, because a C++ pointer value (that can be NULL) can be treated as a Swift optional, and vice-versa.</p><p>Now, if you were to create an optional integer, <code>Int?</code>, you would see that the optional takes more space than a single <code>Int</code>. That's because all possible bit representations in an <code>Int</code> are valid values of an <code>Int</code>, so we add an extra byte (from 8 to 9 on a 64-bit machine) to tell whether we're in the <code>.none</code> or the <code>.some</code> case.</p><p>But the thing is... spare bits and holes in bit representations are everywhere, and Swift will dig to try to find them. For example, let's add a <code>Contractor</code> class and create an enum with three cases:</p><pre><code><span class="keyword">enum</span> Payee {
  <span class="keyword">case</span> employee(<span class="type">Employee</span>)
  <span class="keyword">case</span> contractor(<span class="type">Contractor</span>)
  <span class="keyword">case</span> myself
}
</code></pre><p>How big are <code>Payee</code> and <code>Payee?</code>, based on what we've seen before?. In fact, both are the same 8 bytes on a 64-bit system. It's not magic, it's how computers work: a class like <code>Employee</code> or <code>Contractor</code> is going to be at least 8-byte-aligned, because of it's object header. That means that a valid reference to a class (basically, a pointer) will always have the lowest three bits be zero: anything else would be a misaligned pointer. So between those two cases, we have three common low bits we can use for whatever we want, and the third case (<code>myself</code>) has no data. Three bits is plenty of space to store a discriminator that says whether a given <code>Payee</code> instance is an <code>employee</code>, <code>contractor</code>, or <code>myself</code>: we need only mask off the upper bits to figure out what case we're in, and then mask off the lower bits to get a proper <code>Employee</code> or <code>Contractor</code> pointer when we know which one it is. Cool, right?</p><p>That explains <code>Payee</code>, but what about the optional <code>Payee?</code> size? The principle is the same: <code>Payee</code> only needed two of the three low bits to represent its three cases. That leaves one glorious extra bit to distinguish between the <code>some</code> and <code>none</code> cases, so <code>Payee?</code> still needs only 8 bytes.</p><p>You can do all of these optimization tricks in C++ with template metaprogramming. Clang uses LLVM's <a href="https://llvm.org/doxygen/classllvm_1_1PointerUnion.html"><code>PointerUnion</code></a> class template <em>extensively</em> to get this same kind of memory savings, but it's a whole lot nicer when the language just does it for you and you don't have to think about it.</p><h2>Automatic reference counting</h2><p>By now you've probably noted the lack of <code>delete</code> or <code>free</code> or any other kind of explicit deallocation. Swift provides automatic memory management using reference counting: a new instance of class type is allocated with a reference count of 1. Anything that needs to hold onto the object will increment its reference count to do so, and decrement the reference count when it is no longer needed. When the reference count hits zero, the object will be de-initialized and the memory freed.</p><p>The C++ standard library has a reference-counting smart pointer template, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>. If you've used <code>shared_ptr</code>, you already have a sense of how reference counting works in practice, and you can think of Swift's classes as using roughly the same semantic model but eliminating the syntactic overhead by bringing it into the language. Swift also has an analogue to <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a>, which is a non-owning reference to something that may be kept alive by other <code>shared_ptr</code> instances.</p><p>However, the <code>shared_ptr</code> analogy is somewhat flawed because <code>std::shared_ptr</code> makes a number of compromises so that it can be used to point to any type. A <code>shared_ptr</code> is often two pointers large, because it has to separate out the "control block" (which handles the reference count) from the raw object pointer. This isn't great for efficiency, and also makes the <code>get()</code> operation particularly dangerous: once you've extracted the raw object pointer, there's no way to get back to the safety of a <code>shared_ptr</code> unless you've also used <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this"><code>std::enable_shared_from_this</code></a>. A better comparison to Swift would be <a href="https://www.boost.org/doc/libs/1_84_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr"><code>boost::intrusive_ptr</code></a>, because the Swift reference count is embedded within the object itself. That means you're only passing around a single pointer to the object rather than the two pointers often needed for a <code>std::shared_ptr</code>, and reference-counting operations have better locality with the object.</p><h3>Weak references</h3><p>One problem with reference counting is the potential for reference cycles: if object <code>a</code> holds a reference to object <code>b</code>, and object <code>b</code> holds a reference to object <code>a</code>, then these two objects will keep each other alive even after the rest of the program has forgotten about them, resulting in a leak:</p><pre><code><span class="keyword">class</span> A {
  <span class="keyword">var</span> b: <span class="type">B</span>?
}

<span class="keyword">class</span> B {
  <span class="keyword">var</span> a: <span class="type">A</span>?
}
</code></pre><p>This problem exists in all reference counting implementationds whether it's the C++ <code>std::shared_ptr</code> or <a href="https://devguide.python.org/internals/garbage-collector/">Python</a>. Python has a built-in garbage collector to find these reference cycles and arbitrarily break them to free memory, but such an approach requires a fairly heavy runtime. Swift's approach is more like <code>std::shared_ptr</code>: the programmer is responsible for ensuring there are no reference cycles, and Swift provides tools to identify and deal with them when they happen.</p><p>Weak references are the primary mechanism for breaking cycles. A weak pointer points at an object but does not keep it alive. Weak references are introduced with the <code>weak</code> modifier on a variable, e.g.,</p><pre><code><span class="keyword">class</span> B {
  <span class="keyword">weak var</span> a: <span class="type">A</span>?
}
</code></pre><p>A <code>weak</code> variable must have optional type, because the object it points to might go away at any point. If the object it points to is destroyed, then the weak reference will get the value <code>nil</code>. Code that works with weak references will naturally "promote" the weak reference to a strong reference when working with it, because it's the same operation as determining whether any other optional has a value in it:</p><pre><code><span class="keyword">if let</span> a = b.<span class="property">a</span> {
  <span class="comment">// a has type A, a strong reference that keeps the object alive</span>
}
</code></pre><p>This is akin to the <code>lock()</code> operation of a <code>std::weak_ptr</code> returning a possibly-NULL <code>std::shared_ptr</code>, but benefits from all of the conveniences for optional types that Swift offers.</p><h3>Why reference counting?</h3><p>We opted for reference counting in Swift because we felt it hit the sweet spot for automatic memory management.</p><p>Unlike more traditional garbage collectors, reference counting is deterministic: when your reference count goes to zero, your object goes away. There's no delay until the garbage collector runs where you are using memory than you should be, nor is there ever a need to "pause" the program to run the garbage collector. Moreover, reference counting can be implemented with a tiny runtime footprint---just a couple of atomic operations---vs. a more elaborate garbage collector runtime. It also places no restrictions on the program beyond the need to correctly balance out "retains" and "releases", so you can freely mix reference-counted code with other code in the system (say, in other languages). Finally, reference counting is locally optimizable: if you can prove that an object is kept alive within a given scope, you don't need to perform any reference counting within that region of the code. That means you can optimize away all of the reference counts in a particularly performance-sensitive part of the code while not having to change the basic model used by the same classes elsewhere in the program.</p><p>At the other end of the spectrum from a traditional garbage collector are systems with unique ownership, such as <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>. This approach requires no overhead for automatic memory management, but makes it hard to express any data structure that isn't tree-like in nature. Reference counting can express arbitrary graphs of objects directly, making it more flexible than models based on unique ownership.</p><p>Coming from C++, the "automatic" part of Swift's automatic reference counting can be frustrating. The optimizer might not remove all of the reference counting that you want it to, and where in C++ you might just grab the raw pointer when your smart pointers aren't optimizing away, Swift makes it a little harder. My advice here is to profile your code: not some micro-benchmark that's does no work, but your actual code. If reference-counting is causing performance issues, <code>swift_retain</code> and <code>swift_release</code> will light up in your profiler and you can work on optimizing those hot spots. Swift has some tools for helping with this, such as <code>unowned(unsafe)</code> references (which are effectively raw pointers) as well as ways to be deliberate about ownership, such as <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md">the <code>consume</code> operation</a>. In my experience, most of the time the reference counting isn't in the way, and when it is a problem, one can optimize locally, usually without having to dip into unsafe code.</p><h2>Wrap-up and what's next?</h2><p>We dove into Swift's support for Object-Oriented Programming, which is based on classes with single inheritance and method overriding. We went over initialization (<em>weird</em>, but good) and de-initialization, as well as down casting.</p><p>That led us into the world of optionals, and how Swift uses them to eliminate NULL pointers from the language (Tony Hoare's self-proclaimed <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar mistake</a>). Optionals are a huge part of working with Swift, even if you stick to the value-semantic world of structs and enums, so it's worth getting a feel for the syntactic constructs that make them easy to work with.</p><p>We're going to take a break on introducing new kinds of types: structs, enums, and classes form the core of Swift's semantic model. Next, we're going to talk a bit about code organization in Swift, and how extensions take all of the fun out of the "free function or member function?" debate.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types</guid><title>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</title><description>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-value-types</link><pubDate>Thu, 1 Feb 2024 14:09:00 -0500</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</h1><p>There is a <a href="https://www.swift.org/getting-started/">Getting Started</a> guide for Swift that's good for a general audience. However, I've noticed that folks coming from C++ tend to struggle with certain aspects of Swift's design, and can get themselves stuck. I think I understand why: the two languages feel similar enough that someone familiar with C++ will take the idioms and patterns from C++ and project them on to Swift, which doesn't always end up well. So, I want to take a different approach to teaching Swift that is specifically geared toward C++ "practitioners": folks who write C++ day-to-day and understand not only the C++ language, but it's standard library and best practices. For you, dear C++ practitioner, I want to teach Swift by mapping from the idioms, patterns, and mental model of C++ into Swift. My hope is that you'll come through this series of posts not just learning Swift, but learning how to use Swift <em>well</em>.</p><p>As a C++ programmer, some parts of Swift will feel like magic, such as separately type-checked generics and value types that compose beautifully, and we'll revel in those. I'll show how some of the aspects of C++ that we've collectively come to view as problematic, such as wrong defaults or avoidable foot guns, are addressed by Swift's design. Other parts of Swift will grate against the sensibilities of a C++ practitioner, and we won't shy away from those, either. Instead, we'll explain what is different, why Swift is designed that way, and how to cope. I live in both worlds: I'm a Swift designer, implementer, and advocate, and yet I've a long history with C++ that includes being a code owner of Clang and spending a decade on the ISO C++ committee. Most of the code I write day-to-day is in the Swift compiler, which is mostly C++ but is migrating toward Swift.</p><blockquote><p><em>Note:</em> You may have heard about <a href="https://www.swift.org/documentation/cxx-interop/">Swift's interoperability with C++</a>. It's a fantastic tool for incrementally moving a C++ code base toward Swift or wrapping up a C++ library in a nicer Swift interface. However, it's the wrong place to start if you know C++ already and want to learn Swift. Instead, I recommend building something purely in Swift first, to get the feel for Swift without the "pull" of existing C++ code toward more C++-centric patterns. You'll be able to integrate Swift better into your existing code bases once you have a solid understanding of both languages.</p></blockquote><p>This is a multi-part series that will walk through the various features of Swift. We'll start with the obligatory "Hello, world" and then dive straight into <em>value types</em>.</p><h2>Hello, World!</h2><p>Okay, let's get this over with: this is "Hello, World" in Swift:</p><pre><code><span class="call">print</span>(<span class="string">"Hello, world!"</span>)
</code></pre><p>But it's more important to greet you, dear C++ practictioner, so let's customize it a little bit:</p><pre><code><span class="keyword">let</span> reader = <span class="string">"dear C++ practitioner"</span>
<span class="call">print</span>(<span class="string">"""
      Hello,</span> \(reader)<span class="string">!
      
      Today, we shall embark on learning a new programming language, Swift.
      """</span>)
</code></pre><p>The <code>let</code> is how we declare an immutable variable, like <code>const</code> in C++, but with stronger guarantees: we'll get to that later. We've omitted the type because Swift does type inference in a manner that's similar to <code>auto</code> in C++, but we could have written the type explicitly with <code>let reader: String</code>. The triple-quotes describe a <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals">multi-line string literal</a>, and the <code>\(...)</code> syntax within it is <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation">string interpolation</a>, a feature common in scripting languages that makes it easy to plug values into the middle of a string.</p><h2>Value types</h2><p>C++ provides rich support for <em>value types</em>, i.e., types for which each copy is completely independent of the original. Let's take a simple example with C++ vectors:</p><pre><code>std::vector&lt;std::string&gt; v1 = { <span class="string">"Hello"</span>, <span class="string">"original"</span> };
std::vector&lt;std::string&gt; v2 = v1;
v2[<span class="number">1</span>] = <span class="string">"copy"</span>;
</code></pre><p>Here, <code>v1</code> is a vector containing <code>"Hello"</code> and <code>"original"</code>. When we make a copy <code>v2</code>, that copy is completely independent of the original: the change to <code>v2</code> on the last line, so that it contains <code>"Hello"</code> and <code>"copy"</code> , doesn't modify the original <code>v1</code>.</p><p>Many C++ types are value types, from builtin types like integers and floating-point types to standard library containers like <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>. C++ lets you build your own value types by letting you control how a class type is created, copied, and destroyed, so long as you follow the <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">Rule of Three/Five/Zero</a>.</p><p>Swift also emphasizes value types because they aid <em>local reasoning</em>, which is the ability to look at code in isolation and reason about what it does, and whether it does so correctly. When you make copy a instance of a value type, you don't need to worry that something you do will affect the original. As in C++, many Swift types are value types, including <code>String</code>, <code>Array</code>, and <code>Dictionary</code>, which are analogous to <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>:</p><pre><code><span class="keyword">let</span> v1: [<span class="type">String</span>] = [<span class="string">"Hello"</span>, <span class="string">"original"</span>] <span class="comment">// [String] is an array type, can also be spelled Array&lt;String&gt;</span>
<span class="keyword">var</span> v2 = v1 <span class="comment">// inferred to also have type [String]</span>
v2[<span class="number">1</span>] = <span class="string">"copy"</span>
<span class="call">print</span>(v1) <span class="comment">// prints ["Hello", "original"]</span>
<span class="call">print</span>(v2) <span class="comment">// prints ["Hello", "copy"]</span>
</code></pre><p>Here we've introduced the <code>var</code> keyword: <code>var</code> introduces variables that can be modified (i.e., they are mutable), whereas <code>let</code> introduces variables that cannot be modified (they are immutable). In Swift, we prefer that you use <code>let</code> wherever you can, because immutability aids local reasoning: it's easier to reason about something if it isn't changing.</p><h3>Aggregating values in structs</h3><p>As in C++, Swift has structs to aggregate data together. While in C++ the difference between <code>struct</code> and <code>class</code> is almost cosmetic (it only impacts whether the defaults are <code>public</code> vs. <code>private</code>), in Swift they are completely different animals. A Swift <code>struct</code> is generally a value type, whereas a Swift <code>class</code> is a class in the Object-Oriented sense of the word, and has <em>reference semantics</em>: copies still refer to the same underlying instance. We'll get back to classes in a later post, because <code>struct</code>s are one way we build value types out of other value types:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
}
</code></pre><p>Structs containing other value types are themselves value types. For example, let's use that labeled point:</p><pre><code><span class="keyword">let</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
<span class="keyword">var</span> p2 = p1
p2.<span class="property">label</span> = <span class="string">"center"</span>

<span class="call">print</span>(p1) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "origin")</span>
<span class="call">print</span>(p2) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "center")</span>
</code></pre><p>That first line is creating a new instance of a <code>LabeledPoint</code>, calling an <em>initializer</em> (that's what Swift calls constructors) to produce the new value from the component parts. The result is on the stack, not the heap, just like you'd expect in C++. Copying the <code>p1</code> value into <code>p2</code> produces a completely separate value, just as you'd expect from the corresponding C++ code.</p><blockquote><p><strong>Labeled arguments</strong>: When creating the new <code>LabeledPoint</code> instance, notice that each of the arguments requires a label, e.g., <code>x:</code>, <code>y:</code>, and <code>label:</code>. By default, all function arguments must be labeled at the call site, which communicates information about what the function will be doing with the corresponding argument, aiding readability. This is particularly useful when combined with default arguments. A function can opt out of having a particular argument labeled, of course, and we'll get back to that later.</p></blockquote><h3>Initialization always goes through initializers</h3><p>C++ has a couple of different ways to initialize an instance of a <code>struct</code>, including constructor calls, initializer lists, default initialization, and copy initialization. Swift settles on one: calling an initializer. Initializers are responsible for initializing all of the fields of the struct before they return (no excuses). The creation of the <code>LabeledPoint</code> in the previous section is using the <em>memberwise</em> initializer that Swift provides automatically for structs, which initializes the fields in order from the corresponding parameters. We could go ahead and write out this initializer directly if we wanted to, like this:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
  
  <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">x</span> = x
    <span class="keyword">self</span>.<span class="property">y</span> = y
    <span class="keyword">self</span>.<span class="property">label</span> = label
  }
}
</code></pre><p>The <code>init</code> keyword is what defines an initializer, and is the equivalent of repeating the class name in C++ to define a constructor, but usually less verbose. <code>self</code> is the Swift equivalent to <code>this</code>, but think of it as being a like a C++ reference (<code>ClassName&amp;</code>) rather than a pointer like it would be in C++ (<code>ClassName*</code>).</p><p>There is no special syntax for initializing the fields in a <code>struct</code>, like there is in C++. Instead, it's just normal assignments to the fields, and the compiler checks that (1) you don't read a field before it's been assigned, and (2) all fields have been assigned before <code>self</code> is referenced as a whole object, including the function return. So let's try out a semantic disaster of an initializer that breaks both rules:</p><pre><code><span class="comment">// in LabeledPoint ...</span>
<span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
  <span class="keyword">self</span>.<span class="property">y</span> = <span class="keyword">self</span>.<span class="property">x</span>   <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  <span class="keyword">self</span>.<span class="property">x</span> = x
  <span class="keyword">if</span> <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>..&lt;<span class="number">2</span>) == <span class="number">1</span> {
    <span class="call">print</span>(<span class="keyword">self</span>) <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  }
} <span class="comment">//  error: return from initializer without initializing all stored properties</span>
</code></pre><p>Uses of uninitialized variables don't happen in Swift, because of a semantic guarantee called <em>definite initialization</em>: the compiler checks that every variable is initialized before it is used, in all execution paths. This applies equally to all code, and it helps define away a class of bugs that bite us in C++:</p><pre><code><span class="keyword">let</span> p: <span class="type">LabeledPoint</span>
<span class="keyword">if</span> y &gt; <span class="number">0</span> {
  p = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
<span class="call">print</span>(p) <span class="comment">// error: constant 'p' used before being initialized</span>
</code></pre><p>Because of definite initialization, Swift has no notion of a default constructor the way C++ does. The variable <code>p</code> <em>is not initialized</em> on the line where it is defined, the way a C++ class with a non-trivial default constructor would be. Rather, you assign to it, and the first assignment is an initialization. You can't read from it before initializing it, so there is no <em>undefined behavior</em> due to uninitialized values.</p><p>You could write an initializer that takes no arguments, and perhaps that makes sense for points to (say) create the origin point, but Swift will never automatically call it: you'll always call it explicitly. Let's write that out so we can demonstrate the Swift equivalent to C++ <a href="https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170">delegating constructors</a>:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>() {
  <span class="keyword">self</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
</code></pre><p>The call to <code>self.init</code> delegates the responsibility for initializing all of the fields of <code>self</code> to another initializer. The rules of definite initialization kick in here, too: you can't use (or initialize) any of the fields of <code>self</code> before the <code>self.init</code> call, and after that call <code>self</code> is fully initialized.</p><h3>Where's my copy constructor?</h3><p>By now, you've probably noted that we could write an initializer that looks very much like a copy constructor:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">self</span>.<span class="property">x</span> = other.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">y</span> = other.<span class="property">y</span>
  <span class="keyword">self</span>.<span class="property">label</span> = other.<span class="property">label</span>
}
</code></pre><p>The <code>_</code> in the declaration of <code>other</code> is a placeholder for "not named", and here it means that the argument to this initializer is not named. Therefore, we can call this initializer with the syntax <code>LabeledPoint(other)</code>, just like one would in C++. However, Swift will never <em>implicitly</em> call an initializer like this, because it's not special in any way.</p><p>Swift will copy, move, and destroy instances of structs by performing those operations directly on each instance property of the <code>struct</code>. In essence, a Swift <code>struct</code> always follows the C++ <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">rule of zero</a>, where one relies on the default implementations of all of the special constructors, assignment operators, and destructor. In practice, this means that it's not possible to observe when Swift is making copies of value types, so the compiler is free to make copies that are necessary for implementing the semantics of the program, and optimize away copies when they are no longer needed. The compiler can even implicitly turn a "copy" into a move when it determines that the source of the copy is going away.</p><p>For a type that needs hold on to resources, Swift has classes, which I've already noted will be the subject of another post. Swift also has a notion of "noncopyable" types, but those will come much later. For now, we'll dive deeper into value types.</p><h3>Immutability runs deep with value types</h3><p>Earlier, we introduced <code>let</code> as a way to create immutable local variables. With value types, immutability is the default. Parameters are immutable unless otherwise specified, which also includes <code>self</code>:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">func</span> badSwapX(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>  <span class="comment">// error: 'other' parameter is immutable</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX     <span class="comment">// error: 'self' parameter is immutable</span>
}
</code></pre><p>One can create methods that mutate <code>self</code> by putting the <code>mutating</code> modifier before the <code>func</code> keyword. Let's start with a sensible example:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> reflectOverXAxis() {
  y = -y
}
</code></pre><p>For other parameters, one can place <code>inout</code> on the parameter to indicate that it is meant to be modified by the function. Formally, <code>mutating</code> on the function is equivalant to <code>inout</code> on the <code>self</code> parameter, but Swift uses <code>mutating</code> because it reads better. With <code>inout</code> parameters and <code>mutating</code> methods, we can write a working version of the <code>badSwapX</code> method:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> swapX(<span class="keyword">_</span> other: <span class="keyword">inout</span> <span class="type">LabeledPoint</span>) {
  <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX
}
</code></pre><p>When calling a function with an <code>inout</code> argument, the argument must be prefixed with <code>&amp;</code> to indicate that we're passing it's (logical) address to the function. For example, here's a call to <code>swapX</code>:</p><pre><code><span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
p1.<span class="call">swapX</span>(&amp;p2)
</code></pre><p>If the value we are trying to apply <code>&amp;</code> to is immutable, the Swift compiler would produce an error. Note that there is no prefix <code>&amp;</code> on <code>p1</code>, even though it's calling a <code>mutable</code> method: it's not needed because the name of the method should <a href="https://www.swift.org/documentation/api-design-guidelines/">clearly imply the mutation</a>. Of course, if <code>p1</code> were immutable, it would still be an error.</p><p>There are two more important things to say about immutability before we move on to our next kind of value type, <code>enum</code>.</p><p>First, you <em>cannot cheat immutability</em> any more than you can cheat Death. There is no equivalent to the C++ <code>const_cast</code> in Swift. There are no <code>mutable</code> data members in Swift; even a <code>var</code> member of a struct can only be modified on a <code>var</code> instance of that struct. There are no <code>const T&amp;</code> parameters whose values can change out from underneath you: an immutable value is truly immutable, and the compiler makes sure that no matter how an immutable parameter is actually passed (by-value or by-reference), the underlying value won't change. This can be frustrating, because you've given up control about when to pass by-value, pass by <code>const</code> reference, or pass by rvalue reference to do a move. On the other hand, it is liberating: there's no spooky-action-at-a-distance when that <code>const&amp;</code> actually <em>does</em> change underneath you, and you can lean on immutability to make it easier to reason about your code.</p><p>That brings us to the second point: <em>there is no aliasing of inout parameters</em>. Aliasing, as I mean it here, is when two different pass-by-reference parameters actually refer to the same underlying instance. If you've ever had to go add an <code>if (this == &amp;other) { ... }</code> check into your copy or move assignment operator in C++, you know just how vicious unexpected aliasing of parameters can be for program semantics. In Swift, we have the <a href="https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity">law of exclusivity</a>, which prevents any such aliasing.</p><h3>Memory safety and the law of exclusivity</h3><p>Swift's <em>law of exclusivity</em> states that two accesses to a given value in memory can only occur simultaneously if both of them are reads, so it is an error to (for example) try to form a mutating access (such as passing something <code>inout</code>) while accessing that value. But this isn't some abstract rule that introduces undefined behavior when you mess up: Swift enforces the law of exclusivity through a combination of static checking (which can produce compiler errors if you produce aliasing) and dynamic checking (when it's not possible for the compiler to prove that there is no aliasing).</p><p>Static checking of the law of exclusivity applies when the value being accessed is sufficiently local that it's possible to reason about all possible accesses to that value. Value types are great for this, because two independent <code>var</code> instances of value type are guaranteed not to alias. The compiler can correctly determine that the two <code>inout</code> arguments in the call <code>p1.swapX(&amp;p2)</code> do not alias, because <code>p1</code> and <code>p2</code> are separate variables. If one instead wrote <code>p1.swapX(&amp;p1)</code>, the compiler would produce an error describing the problem:</p><pre><code>=== exclusivity.<span class="property">swift</span>:<span class="number">28</span> ===
   ┆
<span class="number">26</span> │   <span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="number">27</span> │   <span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
<span class="number">28</span> │   p1.<span class="call">swapX</span>(&amp;p1)
   │   │        ╰─ note: conflicting access <span class="keyword">is</span> here
   │   ╰─ error: overlapping accesses to 'p1', but modification requires exclusive access; consider copying to a local variable
<span class="number">29</span> │ 
</code></pre><p>Now, if we're dealing with a variable that isn't local---say it's a global variable (gasp!) or a member of a reference type like a <code>class</code>, then it's impossible to reason about all of the accesses. Let's build a small contrived example of this:</p><pre><code><span class="keyword">var</span> globalOrigin = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)

<span class="keyword">func</span> swapXWithGlobalOrigin(<span class="keyword">_</span> other: <span class="keyword">inout</span> <span class="type">LabeledPoint</span>) {
  other.<span class="call">swapX</span>(&amp;globalOrigin) <span class="comment">// is this safe?</span>
}

<span class="keyword">func</span> somewhereElse() {
  <span class="call">swapXWithGlobalOrigin</span>(&amp;globalOrigin) <span class="comment">// uh oh</span>
}
</code></pre><p>Within <code>swapXWithGlobalOrigin</code>, there is no way to know whether some other part of the program might access <code>globalOrigin</code> while it runs. So, the Swift compiler will insert a runtime check that tracks when <code>globalOrigin</code> is potentially being modified, and will stop the program if a simultaneous access occurs:</p><pre><code><span class="type">Simultaneous</span> accesses to 0x100e93008, but modification requires exclusive access.
<span class="type">Previous</span> access (a modification) started at t`<span class="call">somewhereElse</span>() + <span class="number">42</span> (0x100e8e95a).
<span class="type">Current</span> access (a modification) started at:
<span class="number">0</span>    libswiftCore.<span class="property">dylib</span>                 0x00007ff82b380890 swift::runtime::<span class="type">AccessSet</span>::<span class="call">insert</span>(swift::runtime::<span class="type">Access</span>*, void*, void*, swift::<span class="type">ExclusivityFlags</span>) + <span class="number">444
1</span>    libswiftCore.<span class="property">dylib</span>                 0x00007ff82b380ae0 swift_beginAccess + <span class="number">66
2</span>    t                                  0x0000000100e8e8d0 <span class="call">swapXWithGlobalOrigin</span>(<span class="keyword">_</span>:) + <span class="number">59
3</span>    t                                  0x0000000100e8e930 <span class="call">somewhereElse</span>() + <span class="number">51
4</span>    t                                  0x0000000100e8ea40 <span class="keyword">static</span> <span class="type">Main</span>.<span class="call">main</span>() + <span class="number">9
5</span>    t                                  0x0000000100e8ea50 <span class="keyword">static</span> <span class="type">Main</span>.<span class="property">$main</span>() + <span class="number">9
6</span>    t                                  0x0000000100e8ea70 main + <span class="number">9
7</span>    dyld                               0x00007ff81aaa9c10 start + <span class="number">1942</span>
<span class="type">Fatal</span> access conflict detected.
</code></pre><p>Most Swift programmers never think about the Law of Exclusivity: it's enforcement is there to prevent mistakes that would cause undefined behavior mayhem in C++, so it's critical to Swift's memory-safety story. But a lot of mutation in Swift works on local values, and the language helps you avoid most of these situations, so the runtime checking is rarely encountered in practice.</p><h3>Enums are the union of enums and unions</h3><p>Enums are one of Swift's loveliest little features. We borrowed them from <a href="https://en.wikipedia.org/wiki/CLU_(programming_language)">CLU</a>, and for a time before Swift 1.0 they even used the keyword <code>oneof</code> . A Swift enum is a type-safe variant, which subsumes C++'s <code>enum</code>, <code>union</code>, and <code>std::variant</code> in one nice little package. An enum can express one of a set of named cases, such as a font size expressed via semantic names:</p><pre><code><span class="keyword">enum</span> FontSize {
  <span class="keyword">case</span> title
  <span class="keyword">case</span> paragraph
  <span class="keyword">case</span> footnote
}
</code></pre><p>This enum works just like you'd expect the equivalent C++ <code>enum class</code>. For example:</p><pre><code><span class="keyword">let</span> fontSize: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>

<span class="keyword">switch</span> fontSize {
  <span class="keyword">case</span> .<span class="dotAccess">title</span>: <span class="call">print</span>(<span class="string">"Title"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">paragraph</span>: <span class="call">print</span>(<span class="string">"Paragraph"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">footnote</span>: <span class="call">print</span>(<span class="string">"Footnote"</span>)
}
</code></pre><p>I snuck a <code>switch</code> statement in there because one often uses switch statements to deal with each of the cases in an enum. Switch statements in Swift must always be exhaustive: if you don't handle all possible cases, you need to add a <code>default</code> clause. This eliminates accidents of omission when (for example) someone adds a new case, and is commonly a warning in C++ compilers. If you've been cringing about the missing <code>break</code> statements above, don't: Swift puts a <code>break</code> before the next case, and if you really want to fall through to the next case, you have to explicitly write <code>fallthrough</code> to do so.</p><p>Back to <code>FontSize</code>: the cases of <code>FontSize</code> are inside the type. If you want to refer to the <code>paragraph</code> case, you can do so with <code>FontSize.paragraph</code>. However, whenever there is type information, such as when you're initializing a variable of type <code>FontSize</code> or switching on a value of type <code>FontSize</code>, you can use the <em>leading dot syntax</em> like <code>.paragraph</code> and let Swift's type inference figure out the type. Compare the above to the corresponding C++ <code>enum class</code>:</p><pre><code><span class="keyword">enum class</span> FontSize {
  title,
  paragraph,
  footnote
};

auto fontSize = <span class="type">FontSize</span>::paragraph;
<span class="keyword">switch</span> (fontSize) {
  <span class="keyword">case</span> <span class="type">FontSize</span>::title: <span class="call">print</span>(<span class="string">"Title"</span>); <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="type">FontSize</span>::paragraph: <span class="call">print</span>(<span class="string">"Paragraph"</span>); <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="type">FontSize</span>::footnote: <span class="call">print</span>(<span class="string">"Footnote"</span>); <span class="keyword">break</span>;
}
</code></pre><p>It's the little things, but they really do add up to cleaner code. Swift's leading dot syntax works really nicely with labeled arguments, because the argument label implies the type of the argument, leading to very readable code. For example, let's imagine a <code>Font</code> struct that uses <code>FontSize</code> along with <code>FontStyle</code> and <code>FontWeight</code> enums, including some default values:</p><pre><code><span class="keyword">struct</span> Font {
  <span class="keyword">var</span> style: <span class="type">FontStyle</span> = .<span class="dotAccess">sanSerif</span>
  <span class="keyword">var</span> size: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>
  <span class="keyword">var</span> weight: <span class="type">FontWeight</span> = .<span class="dotAccess">regular</span>
}
</code></pre><p>Now, we can create a new <code>Font</code> like this:</p><pre><code><span class="keyword">let</span> font = <span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>)
</code></pre><p>Note how the argument labels <code>size</code> and <code>weight</code> naturally describe the arguments that follow them, and the types provide enough information so we don't need to write out the redundant <code>FontSize</code> and <code>FontWeight</code> types on those arguments. Moreover, we are able to use the default argument for <code>style</code> even though it's the first parameter: labeled arguments make default arguments work really well. These are simple design decisions for a language to make, but they reinforce readable code.</p><p>Alright, back to enums! Imagine that you wrote that <code>FontSize</code> as an <code>enum class</code> in C++. Hold it in your mind. It's simple, it works. Now, someone comes along and tells you that you need to support <em>custom</em> font sizes, which can be expressed in terms of points. Your nice <code>enum class</code> is out the window, because you can't enumerate all of the custom point sizes. Here's the pattern I would use in C++:</p><pre><code><span class="keyword">class</span> FontSize {
public:
  <span class="keyword">enum</span> Kind {
    title,
    paragraph,
    footnote,
    custom
  };

private:
  <span class="type">Kind</span> kind;
  int points; <span class="comment">// only valid when kind == custom</span>

public:
  <span class="type">FontSize</span>() : <span class="call">kind</span>(paragraph) { }
  <span class="type">FontSize</span>(<span class="type">Kind</span> kind) : <span class="call">kind</span>(kind) { <span class="call">assert</span>(kind != custom); }
  
  <span class="keyword">static</span> <span class="type">FontSize</span> <span class="call">forCustom</span>() { 
    <span class="type">FontSize</span> size;
    size.<span class="property">kind</span> = custom;
    size.<span class="property">points</span> = points;
    <span class="keyword">return</span> size;
  }
  
  explicit operator <span class="type">Kind</span>() <span class="call">const</span> { <span class="keyword">return</span> kind; } <span class="comment">// so we can switch</span>
  
  int <span class="call">getPoints</span>() <span class="call">const</span> {
    <span class="call">assert</span>(kind == custom);
    <span class="keyword">return</span> points;
  }
};
</code></pre><p>That is a <em>lot</em> of code. It is implementing a type-safe union that consists of the three simple cases, plus the one <code>custom</code> case. I cringe ever time I have to write one of these in C++ (which happens a lot), because it is so much boilerplate and it's so easy to make a silly mistake. I've yet to come across a C++ technique or library that makes this cleaner. Feel free to let me know if you have a significantly more elegant solution in C++.</p><p>In Swift, you add one case to <code>FontSize</code>:</p><pre><code><span class="keyword">case</span> custom(points: <span class="type">Int</span>)
</code></pre><p>Swift cases can carry values in them, which is why I said earlier that they also are like C++ unions---without all of the undefined behavior. Given this case, I can create a custom font size:</p><pre><code><span class="keyword">let</span> customFont: <span class="type">FontSize</span> = .<span class="call">custom</span>(points: <span class="number">32</span>)
</code></pre><p>And extend my <code>switch</code> statement accordingly:</p><pre><code><span class="keyword">switch</span> fontSize {
  <span class="keyword">case</span> .<span class="dotAccess">title</span>: <span class="call">print</span>(<span class="string">"Title"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">paragraph</span>: <span class="call">print</span>(<span class="string">"Paragraph"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">footnote</span>: <span class="call">print</span>(<span class="string">"Footnote"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">custom</span>(<span class="keyword">let</span> pt): <span class="call">print</span>(<span class="string">"</span>\(pt) <span class="string">points"</span>)
}
</code></pre><p>Swift provides pattern matching. When we match the <code>custom</code> case, we also declare a new variable <code>pt</code> to capture the <code>points</code> value. The value <code>pt</code> is only available when one is using a custom font size, so there's no need for runtime assertions like <code>kind == custom</code> like we had in C++.</p><p>Let's add one more case to our font size, which lets us take an existing font size and scale it by a given factor. It can be expressed like this:</p><pre><code><span class="keyword">indirect case</span> scaled(size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>)
</code></pre><p>This way, one can construct a font that is 20% larger than the paragraph font using, e.g.,</p><pre><code><span class="type">FontSize</span>.<span class="call">scaled</span>(size: .<span class="dotAccess">paragraph</span>, factor: <span class="number">1.2</span>)
</code></pre><p>The <code>indirect</code> is needed to indicate that the value associated with the case (called the <em>associated value</em> in Swift) needs to be stored <em>indirectly</em>, because the associated value contains an instance of <code>FontSize</code> itself. Enums are value types and generally use stack storage, so the <code>indirect</code> indicates when the value for the case needs to be moved off to the heap. If the <code>indirect</code> were missing, the compiler would complain because the <code>FontSize</code> type doesn't have a fixed size in memory:</p><pre><code>=== <span class="type">FontSize</span>.<span class="property">swift</span>:<span class="number">1</span> ===
 <span class="number">1</span> │ <span class="keyword">enum</span> FontSize {
   │      ╰─ error: recursive <span class="keyword">enum</span> '<span class="type">FontSize</span>' <span class="keyword">is</span> not marked '<span class="keyword">indirect</span>'
 <span class="number">2</span> │   <span class="keyword">case</span> title
 <span class="number">3</span> │   <span class="keyword">case</span> paragraph
 <span class="number">4</span> │   <span class="keyword">case</span> footnote
 <span class="number">5</span> │   <span class="keyword">case</span> custom(points: <span class="type">Int</span>)
 <span class="number">6</span> │   <span class="keyword">case</span> scaled(size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>)
   │        ╰─ note: cycle beginning here: (size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>) -&gt; (.<span class="number">0</span>: <span class="type">FontSize</span>)
 <span class="number">7</span> │ }
 <span class="number">8</span> │ 
</code></pre><p>Indirect enum cases are useful for building recursive data structures, like a binary tree. We'll come back to those when we can do it properly, with generics.</p><p>Now we can create a nice member function that scales the font instance we have by a specific factor:</p><pre><code><span class="comment">// in FontSize</span>
<span class="keyword">func</span> scaled(by factor: <span class="type">Double</span>) -&gt; <span class="type">Self</span> {
  .<span class="call">scaled</span>(size: <span class="keyword">self</span>, factor: factor)
}
</code></pre><p>This can be called as, e.g., <code>myFontSize.scaled(by: 1.2)</code>. There are a few little things to notice here. The first is that enums can have methods just like structs can. They can also have initializers, which must eventually assign one of the cases to <code>self</code>. Next, our function is returning <code>Self</code>, which is shorthand for "the type of <code>self</code>". Finally, look at how the parameter is named, "<code>by factor</code>": here, the <em>argument label</em> is <code>by</code> (it's used at the call site) and the <em>parameter name</em> is <code>factor</code> (it's used inside the body). This is because the argument label is there to describe the argument at the call site, i.e., we're scaling "<code>by</code> 1.2", whereas the parameter name is the noun of what the parameter actually is---the <code>factor</code> used in the computation. Before now, we've seen that the two names are generally the same, or the argument label is omitted, but separating the two can lead to elegant, readable code particularly when the argument label is a preposition.</p><h2>Collections</h2><p>The standard Swift collections types <code>Array</code>, <code>Dictionary</code>, and <code>Set</code> are value types when they are storing value types. For example, we could have an array of <code>Font</code> instances, which will behave as a value type:</p><pre><code><span class="keyword">var</span> fonts = [<span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>), <span class="type">Font</span>(size: .<span class="dotAccess">paragraph</span>)] <span class="comment">// infers type Array&lt;Font&gt;, also written [Font]</span>
<span class="keyword">var</span> oldFonts = fonts  <span class="comment">// copies the contents of fonts</span>
fonts.<span class="call">append</span>(<span class="type">Font</span>(size: .<span class="dotAccess">footnote</span>))
<span class="call">print</span>(fonts.<span class="property">count</span>)    <span class="comment">// 3</span>
<span class="call">print</span>(oldFonts.<span class="property">count</span>) <span class="comment">// 2</span>
fonts[<span class="number">1</span>].weight = .<span class="dotAccess">bold</span> <span class="comment">// doesn't affect oldFonts</span>
</code></pre><p>Dictionaries and sets work similarly. For example, let's build a dictionary that names all of our fonts:</p><pre><code><span class="keyword">var</span> fontsDict = [  <span class="comment">// infers type Dictionary&lt;String, Font&gt;, also written [String: Font]</span>
  <span class="string">"Title"</span> : <span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>), 
  <span class="string">"Paragraph"</span> : <span class="type">Font</span>(size: .<span class="dotAccess">paragraph</span>)
]

<span class="keyword">var</span> oldFontsDict = fontsDict <span class="comment">// make a copy</span>
fontsDict[<span class="string">"Footnote"</span>] = <span class="type">Font</span>(size: .<span class="dotAccess">footnote</span>) <span class="comment">// add an element</span>
<span class="call">print</span>(fontDict.<span class="property">count</span>)    <span class="comment">// 3</span>
<span class="call">print</span>(oldFontsDict.<span class="property">count</span>) <span class="comment">// 2</span>
</code></pre><p>The bracket syntax is used for both dictionary literals (when the elements are <code>key: value</code> pairs) and array literals (when the elements are just... elements). The literals are actually extensible: you can use an array literal to initialize a <code>Set</code>, or even your own type, by defining an appropriate initializer and opting in to be "expressible by" that literal type using the generics system. (More on that in a later post, I promise.)</p><h2>Regular types</h2><p>In C++ we sometimes talk about <a href="http://stepanovpapers.com/DeSt98.pdf">regular types</a>, defined by Alexander Stepanov, which are types that behave predictably with respect to value semantics: you can copy them, and the copy is equal to the original. They can be moved, destroyed, and swapped. C++20 has a <a href="https://en.cppreference.com/w/cpp/concepts/regular"><code>std::regular</code> concept</a> to capture these requirements.</p><p>Swift value types fulfill most of the requirements of a regular type by default, and are based on the same semantic contract. Swift value types are always copyable, destructible, assignable, and movable. Indeed, you can't really even express these ideas in Swift, it's just the way types behave.</p><p>However, there are some notable differences from the Stepanov or C++ standard definitions of a regular type. The first was noted earlier: Swift doesn't have a notion of "default construction" at all, so Swift value types are not "default constructible". You tend not to need this notion in Swift, though, because of definite initialization. There is a benefit here for the authors of types: you don't have to worry about inventing a "default" state if one doesn't make sense. For example, imagine an collection that is always non-empty: how would you give it a default constructor? You can't without doing something weird, like adding a single default-constructed element, so such a type can't be regular.</p><p>Regular types also have (in)equality operators (<code>==</code> and <code>!=</code>). Swift doesn't provide those for free, but you can either write them yourself with, e.g.,</p><pre><code><span class="comment">// in Font</span>
<span class="keyword">static func</span> ==(lhs: <span class="type">Font</span>, rhs: <span class="type">Font</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.<span class="property">style</span> == rhs.<span class="property">style</span> &amp;&amp; lhs.<span class="property">size</span> == rhs.<span class="property">size</span> &amp;&amp; lhs.<span class="property">weight</span> == rhs.<span class="property">weight</span>
}
</code></pre><p>or let the compiler do it for you, by putting <code>: Equatable</code> in the type definition:</p><pre><code><span class="keyword">struct</span> Font: <span class="type">Equatable</span> {
  <span class="keyword">var</span> style: <span class="type">FontStyle</span> = .<span class="dotAccess">sanSerif</span>
  <span class="keyword">var</span> size: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>
  <span class="keyword">var</span> weight: <span class="type">FontWeight</span> = .<span class="dotAccess">regular</span>
}
</code></pre><p>This says that the <code>Font</code> type is <code>Equatable</code>, and the compiler will synthesize both <code>==</code> and <code>!=</code> for you based on the data members. You can also put <code>Hashable</code> here to get a hash function that combines the data members, which then allows your type to be used as a key in a <code>Dictionary</code> or a value in a <code>Set</code>. Again, this is dipping our toes into Swift's generics system, but for now you can think of <code>Equatable</code> as being a little bit like a C++ concept (we call it a <em>protocol</em> in Swift), but... better.</p><h2>What's next?</h2><p>We've talked about value types---a lot. If you're writing Swift, you should use them often, because they provide excellent local reasoning and the ability to model most data in a straightforward manner: <code>struct</code>s and collections to aggregate data and <code>enum</code>s to capture different choices.</p><p>In the next part of this series, we'll talk about reference types. Specifically, classes, and how Swift supports Object-Oriented Programming.</p>]]></content:encoded></item></channel></rss>