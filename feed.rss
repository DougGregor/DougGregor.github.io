<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Doug's Compiler Corner</title><description>Musings on programming languages and compilers.</description><link>https://www.douggregor.net</link><language>en</language><lastBuildDate>Fri, 1 Mar 2024 22:16:04 -0800</lastBuildDate><pubDate>Fri, 1 Mar 2024 22:16:04 -0800</pubDate><ttl>250</ttl><atom:link href="https://www.douggregor.net/feed.rss" rel="self" type="application/rss+xml"/><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practitioners-extensions</guid><title>Swift for C++ Practitioners, Part 3: Extensions and Access Control</title><description></description><link>https://www.douggregor.net/posts/swift-for-cxx-practitioners-extensions</link><pubDate>Fri, 1 Mar 2024 22:14:08 -0800</pubDate><content:encoded><![CDATA[<p>---</p><p>date: 2024-03-01 10:14</p><p>description: Swift for C++ Practitioners, Part 3: Extensions &amp; Access Control</p><p>tags: Swift, C++</p><p>---</p><h1>Swift for C++ Practitioners, Part 3: Extensions and Access Control</h1><p>Let's take a short break from the Swift type system to talk a bit about code organization in Swift, which is quite different from how it's handled in C++. This post will cover Swift's extensions, modules, and access control. I'll throw in some other little expressivity tricks like computed properties and subscripts as well.</p><h2>Free function or member function?</h2><p>In C++, whenever we want to introduce a new function for a type <code>X</code>, we have two choices: create a "free function" (at namespace scope) or a member function (which lives inside the class). The choice impacts a number of things: the syntax you use to call the function (<code>f(x)</code> vs. <code>x.f()</code>), which header can declare the function, how access control works, and so on.</p><p>Much of the advice in the C++ community says that we should <a href="https://danielsieger.com/blog/2023/05/01/cpp-member-vs-free-functions.html">prefer free functions to member functions</a>. There are a number of very good reasons why:</p><ul><li>Free functions can be added by anyone, not just the author of the class, so they are more general.</li><li>Free functions can be kept local to a single implementation file (e.g., by making them <code>static</code> or putting them in an anonymous namespace).</li><li>Free functions make for better customization points in templates, because they can be added for any existing type, including built-in types. (This is why <a href="https://en.cppreference.com/w/cpp/iterator/begin"><code>std::begin</code></a> and <a href="https://en.cppreference.com/w/cpp/iterator/end"><code>std::end</code></a> exist, for example).</li></ul><p>The problem is that free functions are more clunky to use than member functions. Many functions naturally operate on some primary value, and writing <code>x.f()</code> or <code>x-&gt;g()</code> is clearer than <code>f(x)</code> or <code>g(*x)</code> for operating on a value of <code>x</code>. Member functions are more discoverable by documentation and tools---it's far easier to look at the documentation for members of <code>std::vector</code> than it is to look through all of the algorithms in <code>std::</code> that might apply to an instance of <a href="https://en.cppreference.com/w/cpp/container/vector"><code>std::vector</code></a>, and code completion after <code>x.</code> or <code>x-&gt;</code> gives useful context for finding the function you're looking for while writing code. Moreover, member functions compose together nicely when you're operating on the resulting value of each function, e.g., <code>x.f().g().h()</code>. Writing that same chained operation with free functions involves inverting the logic to <code>h(g(f(x)))</code>. It's okay, but it's harder to read, and harder to write.</p><p>All of these are small things by themselves, but together they make it hard to justify following the advice to "prefer free functions to member functions." The end result of following that advice might be more flexible, but it's harder to use. So we end up not following the advice, or duplicating functionality, like how <code>std::begin</code> wraps <code>std::vector::begin</code> because the former is more general but the latter is more usable.</p><h2>Extensions</h2><p>In Swift, you can add new members to any type by writing an <em>extension</em> of that type. For example, let's say that we have a simple struct representing a point in 2-D space:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
}
</code></pre><p>And then we'd like to add some new operations to <code>Point</code>. For example, let's create some operations that can help move the point around in space: one to move it by some amount in the x or y coordinates, another to flip it over the horizontal or vertical axis. These could be free functions, but it's nicer to use an extension to make them member functions like this:</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">func</span> translated(deltaX: <span class="type">Double</span>, deltaY: <span class="type">Double</span>) -&gt; <span class="type">Point</span> {
		<span class="type">Point</span>(x: x + deltaX, y: y + deltaY)
  }
  
  <span class="keyword">func</span> flipped(axis: <span class="type">Axis</span>) -&gt; <span class="type">Point</span> {
    <span class="keyword">switch</span> axis {
      <span class="keyword">case</span> .<span class="dotAccess">horizontal</span>: <span class="type">Point</span>(x: x, y: -y)
      <span class="keyword">case</span> .<span class="dotAccess">vertical</span>: <span class="type">Point</span>(x: -x, y: y)
    }
  }
}
</code></pre><p>Now, we can go ahead and use these member functions together:</p><pre><code><span class="keyword">let</span> p2 = p1.<span class="call">translated</span>(deltaX: <span class="number">1</span>, deltaY: -<span class="number">0.5</span>)
  .<span class="call">flipped</span>(axis: .<span class="dotAccess">horizontal</span>)
</code></pre><p>Anyone can add an extension to any type. So long as the extension is visible to you, the members added via extension are used exactly the same way as members that were defined with the original type. Extensions allow one to organize the different aspects of a type's API: the data members, initializers, primary operations, and (for a class) deinitializer and overridable methods go into the primary definition of the type, which must contain all of the information needed to determine how the type is laid out in memory. From there, any number of extensions can be used to provide different conceptual slices of the type's API. The <code>Point</code> extension above provides the APIs that move the point around in space. Another extension might provide serialization or printing support, with yet another extension containing distance computations between this point and other objects. Although we won't get to generics until the next post, I'll spoil things a little bit to say that extensions are critical there, too: they satisfy customization points and make it exceptionally easy to write generic algorithms that operate across all sets of types.</p><h3>Computed properties</h3><p>An extension can also add new properties to a type, but only if they are <em>computed</em> properties, i.e., ones whose values are computed from other existing values. For example, we could add computed property to determine the distance of a point from the origin, i.e., it's magnitude:</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">var</span> magnitude: <span class="type">Double</span> {
    <span class="call">sqrt</span>(x*x + y*y)
  }
}
</code></pre><p>The curly braces indicate that this property is a computed property, and contain the code that computes the property's value. The <code>magnitude</code> computed property works like any other property, e.g.,:</p><pre><code><span class="call">print</span>(<span class="string">"Point</span> \(p) <span class="string">has magnitude</span> \(p.<span class="property">magnitude</span>)<span class="string">"")</span>
</code></pre><p>Now, the <code>magnitude</code> property is read-only: there's no way to assign to it, or pass it <code>inout</code>, because it doesn't make sense to modify the magnitude of a point. However, we can define some read/write computed properties by writing out explicit <code>get</code> and <code>set</code> functions within the curly braces. Let's do it for one of our standard examples, a view on the point using polar coordinates (angle and radius):</p><pre><code><span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">var</span> angle: <span class="type">Double</span> {
    <span class="keyword">get</span> { <span class="call">atan2</span>(y, x) }
    <span class="keyword">set</span> { 
      <span class="keyword">self</span> = .<span class="keyword">init</span>(angle: newValue, radius: radius)
    }
  }
  
  <span class="keyword">var</span> radius: <span class="type">Double</span> {
    <span class="keyword">get</span> { magnitude }
    <span class="keyword">set</span> { 
      <span class="keyword">self</span> = .<span class="keyword">init</span>(angle: angle, radius: newRadius)
    }
  }

  <span class="keyword">init</span>(angle: <span class="type">Double</span>, radius: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(x: radius * <span class="call">cos</span>(angle), y: radius * <span class="call">sin</span>(theta))
  }
}
</code></pre><p>This extension has provided a fairly complete API for <code>Point</code> with polar coordinates: you can read or write <code>angle</code> and <code>radius</code> to manipulate the point's location via polar coordinates, or create a new <code>Point</code> instance from polar coordinates with the given initializer. Within the <code>set</code> functions, <code>newValue</code> is the name of an implement parameter containing new value to which the property is being set. If you want, you can rename it by providing a different name, e.g., <code>set(newAngle) { ... }</code>), but folks don't tend to do this often.</p><p>When manipulating a <code>Point</code> via the Polar APIs, the result is still always stored in terms of the Cartesian coordinates <code>x</code> and <code>y</code>. Indeed, without looking at the implementation of the <code>Point</code> type, you can't even necessarily tell whether you're dealing with a computed property or a stored property. This is generally a good thing, because it means that the type can be refactored to change the way it stores its data (say, to provide indirection or add a caching layer) without requiring that clients change their code at all. It's another small thing, but in Swift you choose between a function or a property based on the syntax you want for your API, not based on the implementation details. And you won't have to write spurious getter/setter functions for every single non-static data member "just in case" you need them later.</p><p>However, this abstraction from the actual storage can also be a bit unsettling as a user if you don't have a good mental model of how the types will perform, especially coming from C++ where you expect to be close to the machine model. The <a href="https://www.swift.org/documentation/api-design-guidelines/#naming">Swift API design guidelines</a> have something to say about this: computed properties should generally be cheap to compute (i.e., amortized constant time), and should refer to some aspect of the part of the type's state. If you have something that's expensive to compute (say, the smallest element in an array) or represents a transformation of the whole value (say, a view of an array with the elements reversed), it should be a function.</p><h3>Extending "standard" types</h3><p>Early in this post, I pointed out that free functions in C++ are used in templates because they can be implemented for built-in types. For example, there's no way to add a member function named <code>begin</code> to a C++ pointer or array type, but you can implement a <code>begin</code> operation as a free function on an array of fixed size:</p><pre><code>template&lt;typename <span class="type">T</span>, std::size_t <span class="type">N</span>&gt;
<span class="type">T</span>* <span class="call">begin</span>(<span class="type">T</span> (&amp;array)[<span class="type">N</span>]) {
  <span class="keyword">return</span> array;
}
</code></pre><p>In Swift, most of the types one thinks of as built-in---integers, floating point numbers, Booleans, optionals, arrays, etc.---are actually structs or enums provided by the standard library. Therefore, you can extend them with new functionality. For example, maybe we want to add a property that determines whether a given integer is prime. We can do so by extending <code>Int</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">Int</span> {
  <span class="keyword">var</span> isPrime: <span class="type">Bool</span> {
    <span class="keyword">switch</span> i {
      <span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">return false
      case</span> <span class="number">1</span>: <span class="keyword">return true
      default</span>: <span class="keyword">break</span>
    }
    
    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">1</span>..&lt;<span class="call">abs</span>(<span class="keyword">self</span>) {
      <span class="keyword">if self</span> % i == <span class="number">0</span> {
        <span class="keyword">return true</span>
      }
    }
    
    <span class="keyword">return false</span>
  }
}
</code></pre><p>This is where extensions show their value: you can extend any type, from anywhere, with new functionality without paying a "syntax penalty" (shall we call it a "<em>syn</em> tax"?) for being outside of the definition of the type or its enclosing module. "Free function or member function?" is a matter of API design, not a decision forced on you by the language. Once you get used to these in Swift, you'll really start to miss them in C++. I certainly do.</p><h3>Subscripts</h3><p>One of my favorite parlor tricks is to add support for manipulating specific bits within an integer by treating it like an array of <code>Bool</code> values, e.g.,</p><pre><code><span class="keyword">var</span> flags: <span class="type">UInt32</span> = 0b1001
flags[<span class="number">2</span>] = <span class="keyword">true</span>  <span class="comment">// set bit #2</span>
flags[<span class="number">0</span>] = <span class="keyword">false</span> <span class="comment">// clear bit #0</span>
</code></pre><p>The code is a straightforward extension of the <code>UInt32</code> type from the standard library, but it also requires that we introduce one more feature: the use of <code>subscript</code> to define a new subscript, which is the Swift equivalent of the C++ <code>operator[]</code>:</p><pre><code><span class="keyword">extension</span> <span class="type">UInt32</span> {
  <span class="keyword">subscript</span>(index: <span class="type">Int</span>) -&gt; <span class="type">Bool</span> {
    <span class="keyword">get</span> {
			(<span class="keyword">self</span> &amp; <span class="type">UInt32</span>(<span class="number">1</span>) &lt;&lt; index) != <span class="number">0</span>
    }
    
    <span class="keyword">set</span> {
      <span class="keyword">let</span> mask = <span class="type">UInt32</span>(<span class="number">1</span>) &lt;&lt; index
			<span class="keyword">self</span> = (<span class="keyword">self</span> &amp; ~mask) | (newValue ? mask : <span class="number">0</span>)
    }
  }
}
</code></pre><p>Note that subscripts in Swift are property-like: they can be read-only (just a <code>get</code>, optionally with the <code>get { ... }</code> elided) or read-write (if they also have a <code>set</code>). The subscript parameters are written in parentheses, like a function, and there can be any number of parameters. For example, a 2-D matrix type might take both the row and column:</p><pre><code><span class="keyword">extension</span> <span class="type">Matrix2D</span> {
  <span class="keyword">subscript</span>(i: <span class="type">Int</span>, j: <span class="type">Int</span>) -&gt; <span class="type">Double</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
}

<span class="call">print</span>(<span class="string">"Top level corner is</span> \(matrix[<span class="number">0</span>, <span class="number">0</span>])<span class="string">"</span>)
</code></pre><p>Subscripts can also have labeled arguments. For example, our same matrix type might want to provide subscript operations that provide access to an entire row or column as a vector:</p><pre><code><span class="keyword">extension</span> <span class="type">Matrix2D</span> {
  <span class="keyword">subscript</span>(row row: <span class="type">Int</span>) -&gt; <span class="type">Vector</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
  
  <span class="keyword">subscript</span>(column column: <span class="type">Int</span>) -&gt; <span class="type">Vector</span> {
    <span class="keyword">get</span> { ... }
    <span class="keyword">set</span> { ... }
  }
}

<span class="call">print</span>(<span class="string">"First row is</span> \(matrix[row: <span class="number">0</span>])<span class="string">"</span>)
</code></pre><p>The <code>row row</code> bit is a little weird, and might cause you to start humming a nursery rhyme. It's a bit of an inconsistency in Swift that for functions and initializers, arguments are labeled by default (you would only write <code>row: Int</code>) whereas in subscripts the arguments are unlabeled by default (so you have to write <code>row row: Int</code> so that the caller will need to provide <code>row:</code>). When we made this choice, we opted to align with common usage (very few subscripts <em>want</em> labeled arguments) rather than overall consistency. Now, it feels like a wart. Either way, you still get to choose when you define the <code>subscript</code> what the argument labels will be.</p><p>Extensions let you go ahead and add members to any type, from anywhere. That sounds a little cool, but also a little scary: how does this not break encapsulation? To understand that, we need to dive into how code is organized in Swift, along with its access control model.</p><h2>Code organization</h2><p>In C++, code is organized into header files and implementation files. Header files (<code>.h</code>, <code>.hpp</code>, etc.) are generally for the interfaces to things---function declarations, type definitions, and so on---whereas implementation files (<code>.cpp</code>, <code>.cxx</code>, etc.) are generally for the code that implements those interfaces. Implementation files are generally compiled once and linked into the program, whereas header files will be included in many different implementation files and potentially vended to other clients.</p><p>Now, these are somewhat purist definitions that don't really match reality, because C++ header files actually contain a lot more than just the interface: they also need to have a lot of implementation details that are necessary to make the interfaces usable. For example, you need the declarations of all of the members of your C++ classes (even the <code>private</code> ones!) because they can only be declared in the header. You also need the definitions of any templates or macros that are part of the interface, because otherwise clients can't instantiate the template or expand the macro. (No, don't talk to me about <code>export</code>, I don't want to hear it). Indeed, the desire to hide away the private details of a C++ class from clients is why we have the <a href="https://en.cppreference.com/w/cpp/language/pimpl">pImpl idiom</a>, and various other techniques to keep implementation details in the implementation files and out of headers.</p><p>Swift takes a different approach to code organization and access control.</p><h3>Modules</h3><p>A Swift program is comprised of a number of modules. A module is a collection of APIs, such as functions and types, along with their implementations. Each module has a name (e.g., <code>Geometry</code>) that can be used to reference it, and access its public APIs. To access the public APIs of the <code>Geometry</code> module from another module, one must import it:</p><pre><code><span class="keyword">import</span> Geometry
</code></pre><p>Once that's done, all of the public APIs in the <code>Geometry</code> module are now available to you.</p><p>The actual creation of a module exists somewhat outside the Swift language: your build system will say what source files are part of a given module, and the name of that module, and all of those source files will be compiled together. Groups of modules can be organized into <a href="https://www.swift.org/packages/">packages</a>.</p><p>The import relationships amongst the modules in a program must form a Directed Acyclic Graph, or DAG: there cannot be any cycles where module <code>A</code> imports module <code>B</code> imports module <code>A</code>. C++ headers let you get away with such tricks, if your linker cooperates, but it's generally a bad idea that will come back to bite you later. With Swift, it'll bite you sooner, but it's predictable.</p><h3>Going <code>public</code></h3><p>By default, any code within a module can access any other code within that module. One nice aspect of this is that, when your program is a single module, you don't have to think about modules or access control at all: just write your code and ignore this feature of the language. We call this <em>progressive disclosure</em>, the idea that one can ignore certain aspects of the language when starting out, and then learn about them only at the time when you need them, without invalidating any of your prior understanding of the language.</p><p>You need access control when your program gets big enough that you want to split it into modules, or when you want to start providing your modules for someone else to use. If you haven't used any access control in your module, it's public interface is empty. <em>All</em> promises made by a Swift module to outside clients are explicit, so if you want to make a type available to clients, you have to say so by marking it <code>public</code>. Perhaps we want to make the <code>Point</code> type available to clients, which we could do like so:</p><pre><code><span class="keyword">public struct</span> Point {
  <span class="keyword">public var</span> x: <span class="type">Double</span>
  <span class="keyword">public var</span> y: <span class="type">Double</span>
}
</code></pre><p>Now, a client that imports our module (let's keep calling it <code>Geometry</code>) can access the <code>Point</code> type and both its <code>x</code> and <code>y</code> values. However, the client cannot create an instance of the <code>Point</code> type, because we haven't explicitly provided a <code>public</code> initializer. Let's revise our type to do so:</p><pre><code><span class="keyword">public struct</span> Point {
  <span class="keyword">public var</span> x: <span class="type">Double</span>
  <span class="keyword">public var</span> y: <span class="type">Double</span>
  
  <span class="keyword">public init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="property">x</span> = x
    <span class="keyword">self</span>.<span class="property">y</span> = y
  }
}
</code></pre><p>That's it! We've exposed the API we wanted public, and anything we didn't explicitly promise is an implementation detail. For example, the <code>translated(deltaX:deltaY:)</code>, <code>flipped(axis:)</code>, and <code>magnitude</code> operations we provided earlier are still implementation details.</p><blockquote><p><em>Aside</em>: At the point where you are marking things <code>public</code>, now would be a <em>really</em> good time to write some documentation for them. Use triple-slash (<code>///</code>) or Doxygen-style (<code>/** ... **/</code>) comment headers and <a href="https://www.markdownguide.org">Markdown</a>, then use the excellent <a href="https://www.swift.org/documentation/docc/#">DocC</a> to generate beautiful documentation. Trust me, your users will thank you. It's also a good way to review your whole API the way your clients will see it.</p></blockquote><p>Technically, any declaration that doesn't have an access specifier on it is <code>internal</code>, meaning "internal to its module". You can write out the <code>internal</code> if you want, but it's pretty rare for folks to do that in Swift.</p><h3>Files, <code>fileprivate</code>, and <code>private</code></h3><p>A module is comprised of one or more source files. The names of those source files don't matter to the Swift language, only to us programmers. However, files are part of Swift's access control model, and you can limit access to a particular declaration to the source file in which is resides (<code>fileprivate</code>) or to just its enclosing type within that source file (<code>private</code>). For example, we might want to do this so that the actual storage representation of our <code>Point</code> type is only accessible within a single source file, making it easy to audit and change. Let's use a SIMD type just for fun:</p><pre><code><span class="comment">// in Point.swift</span>
<span class="keyword">public struct</span> Point {
  <span class="keyword">private var</span> storage: <span class="type">SIMD2</span>&lt;<span class="type">Double</span>&gt;
}

<span class="keyword">extension</span> <span class="type">Point</span> {
  <span class="keyword">public var</span> x: <span class="type">Double</span> {
    <span class="keyword">get</span> { storage[<span class="number">0</span>] }
    <span class="keyword">set</span> { storage[<span class="number">0</span>] = newValue }
  }
  
  <span class="keyword">public var</span> y: <span class="type">Double</span> {
    <span class="keyword">get</span> { storage[<span class="number">1</span>] }
    <span class="keyword">set</span> { storage[<span class="number">1</span>] = newValue }
  }
  
  <span class="keyword">public init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(storage: [x, y])
  }
}
</code></pre><p>The code above is valid. If we tried to move any part of the extension to another source file, we would get an error because <code>Point.storage</code> is only accessible in this source file. Moreover, it's only accessible to <code>Point</code> and its extensions within this source file, so we can't even refer to it from free functions in the same file</p><pre><code><span class="comment">// also in Point.swift</span>
<span class="keyword">func</span> printPoint(<span class="keyword">_</span> point: <span class="type">Point</span>) {
  <span class="call">print</span>(<span class="string">"</span>\(point.<span class="property">storage</span>)<span class="string">"</span>) <span class="comment">// error: storage is not accessible outside of Point in this file</span>
}
</code></pre><p>If we want the ability to access <code>storage</code> from this free function, we can mark it <code>fileprivate</code> rather than <code>private</code>.</p><p>You can think of Swift's <code>fileprivate</code> and <code>private</code> as filling the same role as anonymous namespaces or (non-member) <code>static</code> functions do in C++ implementation files: a way to write code that never escapes that one implementation file, so it isn't available to any other part of your program. But unlike anonymous namespaces or <code>static</code>, there's no "<em>syn</em> tax": you can reduce a declaration's access down to a single file with <code>fileprivate</code> or <code>private</code> without changing any other code in that source file, whereas in C++ you'd have to go change the way it's used and possibly edit the corresponding header.</p><h3>Extensions and source file naming</h3><p>Swift programmers tend to keep source files fairly small and dedicated to a particular task. For example, the <code>Point.swift</code> described above, which provides only the type definition and the one extension allowing access via Cartesian coordinates, might be the entire contents of the source file. All other functionality for <code>Point</code> would go into a separate source file, which would contain extensions. For example, the support for Polar coordinates would go into a source file <code>Point+Polar.swift</code>, whereas printing support could go into <code>Point+Printing.swift</code>. If you look at a sizable Swift module, you'll see lots of the <code>&lt;type&gt;+&lt;purpose&gt;.swift</code> source files:</p><pre><code><span class="type">Line</span>.<span class="property">swift</span>
<span class="type">Line</span>+<span class="type">Transforms</span>.<span class="property">swift</span>
<span class="type">Point</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Cartesian</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Codable</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Polar</span>.<span class="property">swift</span>
<span class="type">Point</span>+<span class="type">Printing</span>.<span class="property">swift</span>
</code></pre><p>At first, this approach surprised me: why break things up into so many small pieces? However, it keeps each source file manageable and focused. Moreover, each source file can present its API for the rest of the world (whether it's just this module or beyond), and then hide its implementation details with <code>private</code> or <code>fileprivate</code>.</p><p>There is a rough analogue to this in C++, where a single large class has its implementation scattered across a number of different implementation files, each of which implements a few of the member functions. Each of those implementation files might use anonymous namespaces or <code>static</code> functions to hide some of its implementation details from the other source files. It works, and we use it extensively in the various C++ code bases I've worked on, but it still means having an enormous header file that you're always touching.</p><h3>Packages</h3><p>Swift packages provide a way to "package up" and distributed a set of Swift modules together for use in Swift programs, and are supported by the <a href="https://www.swift.org/documentation/package-manager/">Swift Package Manager</a>. A package is a group of modules that is developed together, and has its own access control level: <code>package</code>. Use <code>package</code> access control when you need access to a particular API across the modules within your own package, but you don't want to make them public for anyone else. The <code>package</code> access level is particularly useful for unit tests, which often want access to functionality that should not be part of the public API vended to clients.</p><p>There is a lot more to be said about Swift packages, but I will leave them to a separate post. There's more access control to be had.</p><h3>No peeking!</h3><p>C++ has two access-control features that have no counterpart in Swift, and allow entities outside of the normal scope to access the private members of the type: <code>protected</code> and <code>friend</code>. While we could debate the merits of these features, I'll point out that we've received very few requests to add them (or something like them) into Swift over the years, and leave it at that.</p><h3>Inheritance and overriding</h3><p>Swift's access control design is centered around the idea of never implicitly promising anything to clients outside of the module. If it isn't marked <code>public</code>, it's an implementation detail, so you can change it. That helps programmers prevent getting accidentally stuck with an accidentally-published API that has amassed clients who didn't know better.</p><p>With object-oriented programming, there are additional concerns that an implementer needs to consider beyond clients just using an API. For a class, an implementer needs to consider whether it makes sense for clients to subclass a class and, if so, which methods can be overridden by those clients. Most OO languages, including C++, allow any (virtual) method to be overridden by clients unless explicitly marked as <code>final</code> (or <code>sealed</code>). Swift takes a slightly different approach: within a module, one is free to subclass any non-<code>final</code> class or override any non-<code>final</code> method declared in the same module. These are implementation details that are not exposed to clients.</p><p>However, outside of a module, a <code>public</code> class cannot be subclassed and a <code>public</code> method cannot be overridden. This is because designing a class for inheritance or a method for overriding takes extra care to maintain backward compatibility: what if the method is called as an implementation detail of another method? If so, you might be stuck maintaining that call sequence forever, even if future implementations of the class don't need it. Instead, Swift makes this an opt-in behavior via the access specifier <code>open</code>: an <code>open</code> class can be subclassed by anyone, and an <code>open</code> method can be overridden by anyone. <code>open</code> is more permissive than <code>public</code>, meaning that all <code>open</code> entities are implicitly <code>public</code>, so they can be both overridden and also used from outside the module. Here's a quick example:</p><pre><code><span class="comment">// module A</span>
<span class="keyword">open class</span> Superclass {
  <span class="keyword">open func</span> f() { }
  <span class="keyword">public func</span> g() { }
  <span class="keyword">public final func</span> h() { }
}

<span class="keyword">class</span> OtherClass: <span class="type">Superclass</span> {
	<span class="keyword">override func</span> f() { ... } <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> g() { ... } <span class="comment">// okay, it's in the same module</span>
  <span class="keyword">override func</span> h() { ... } <span class="comment">// error, it's final</span>
}

<span class="comment">// module B</span>
<span class="keyword">import</span> A

<span class="keyword">class</span> Subclass: <span class="type">Superclass</span> { <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> f() { ... } <span class="comment">// okay, it's open</span>
  <span class="keyword">override func</span> g() { ... } <span class="comment">// error, it's in a different module and isn't open</span>
}
</code></pre><p>The <code>open</code> access specifier makes it clear where the extension points in an object-oriented hierarchy are, making this complicated contract between implementer and client explicit and clear.</p><h2>Wrap-up</h2><p>Early on, I linked to a post about <a href="https://danielsieger.com/blog/2023/05/01/cpp-member-vs-free-functions.html">prefering free functions</a>. It is one of many in the C++ world, and links out to various guidelines and talks that all come to roughly the same conclusion. Here are the reasons listed in that post for prefering free functions to member functions in C++:</p><ul><li><strong>Loose Coupling:</strong> A free function is more loosely coupled to the class it is operating on. It only depends on the interface. This also enables generic functions being usable with different concrete classes.</li><li><strong>Encapsulation and Hiding:</strong> A free function promotes encapsulation and information hiding since it does not have access to the implementation details of the class.</li><li><strong>Flexibility and Extensibility:</strong> Adding another free function is cheap and easy and does not require modification of the class definition.</li><li><strong>Testing:</strong> A free function is generally easier to test due to increased independence. No hacks required to test those pesky private member functions.</li></ul><p>Swift's extensions and access control address all of those reasons directly. Encapsulation and hiding are based on the organization of code into files, modules, and packages. You can add a member to a type from anywhere with an extension. The result of these aspects being orthogonal is that you get all of the loose coupling, enapsulating, flexibility, and extensibility of C++ "free functions", with the ergonomics of member functions. It's lovely.</p><p>Extensions are also a key part of the next part of our story: generics.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practioners-reference-types</guid><title>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</title><description>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</description><link>https://www.douggregor.net/posts/swift-for-cxx-practioners-reference-types</link><pubDate>Sat, 10 Feb 2024 12:00:00 -0800</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 2: Reference Types &amp; Optionals</h1><p>In our first episode, we talked a lot about value types. In general, you should prefer value types in Swift whenever you can.</p><p>However, Object-Oriented Programming (OOP) is a reasonable approach when you need your objects to have identity and to form relationships amongst each other in arbitrary ways. For these cases, Swift has classes with support for inheritance, overriding, and subtyping. A class is defined in Swift with---you guessed it---the <code>class</code> keyword:</p><pre><code><span class="keyword">class</span> Person {
  <span class="keyword">var</span> name: <span class="type">String</span>
  <span class="keyword">var</span> age: <span class="type">Int</span>
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
    <span class="keyword">self</span>.<span class="property">age</span> = age
  }
  
  <span class="keyword">func</span> greet() {
    <span class="call">print</span>(<span class="string">"Hello</span> \(name)<span class="string">!"</span>)
  }
}
</code></pre><p>Classes look a lot like structs, with all the same basic ingredients: stored properties ("non-static data members" in C++ parlance), initializers, methods, etc. Each of these ingredients works basically the same way, so if you know how to write a struct, you're pretty close to writing a class. In fact, you could take nearly any <code>struct</code> from my value-types post and use the <code>class</code> keyword, and it would probably compile! However, even though it will compile, it will behave <em>radically</em> differently, because...</p><h2>Classes have reference semantics</h2><p>Let's say we have a little <code>Temperature</code> struct:</p><pre><code><span class="keyword">struct</span> Temperature {
  <span class="keyword">var</span> fahrenheit: <span class="type">Double</span>
  
  <span class="keyword">init</span>(fahrenheit: <span class="type">Double</span>) {
    <span class="keyword">self</span>.<span class="property">fahrenheit</span> = fahrenheit
  }
}
</code></pre><p>And some sensible-looking code:</p><pre><code><span class="keyword">var</span> temp = <span class="type">Temperature</span>(fahrenheit: <span class="number">70</span>)
home.<span class="property">thermostat</span>.<span class="property">temperature</span> = temp

temp.<span class="property">fahrenheit</span> = <span class="number">400</span>
home.<span class="property">oven</span>.<span class="property">temperature</span> = temp
home.<span class="property">oven</span>.<span class="call">bake</span>()
</code></pre><p>Fine, right?</p><p>If we change that <code>struct</code> to a <code>class</code>, everything will still compile fine... but it's going to get really, really hot in here. When <code>Temperature</code> is a class, it has reference semantics: there is one instance <code>temp</code> created in the first line, and that instance is shared between the thermostat and the oven, so changing the temperature on one affects the other.</p><p>There are times when reference semantics are the right way to model your problem, and classes are great for those. <code>Temperature</code> is an example of something that should remain a struct, because it is intrinsically a value. The key distinguishing characteristics for choosing a class is when you need <em>identity</em> and <em>sharing</em>, such that two different places in your code need to be able to refer to the same entity, and see the effects of each other's changes to that entity.</p><p>Coming from C++, there are other clues as to whether to choose <code>struct</code> or <code>class</code>. If in C++ you would always pass around the type by pointer or reference (whether a raw pointer or a smart pointer like <code>std::shared_ptr</code>), or ever comparing the address of the instances, or if you're going to be deleting the copy constructor, then you probably have reference semantics and should use a <code>class</code> in Swift. C++ features like <code>virtual</code> functions or <code>dynamic_cast</code> are also indicators of reference semantics, but they aren't as strong: these could be merely implementation mechanisms for something else.</p><p>Most importantly, in C++ we often use inheritance to get implementations for free in a new type, even without <code>virtual</code> functions. The <a href="https://en.cppreference.com/w/cpp/language/crtp">Curiously Recurring Template Pattern (CRTP)</a> is one such pattern that uses C++ inheritance even in types that have value semantics. This pattern does <em>not</em> translate well into Swift, and there are alternative ways to express this kind of polymorphism through the generics system and so-called "protocol extensions". The fact that one would use inheritance in C++ to model a problem is not a good indicator that one should use classes in Swift. Instead, it all comes back to reference semantics and identity.</p><h2>Inheritance &amp; overriding</h2><p>Swift classes allow single inheritance, with overriding of methods. Let's create a subclass of <code>Person</code> for employees of some company:</p><pre><code><span class="keyword">class</span> Employee: <span class="type">Person</span> {
  <span class="keyword">let</span> badgeNumber: <span class="type">Int</span>
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, badgeNumber: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">badgeNumber</span> = badgeNumber
    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)
  }
  
  <span class="keyword">override func</span> greet() {
    <span class="call">print</span>(<span class="string">"Hello</span> \(name)<span class="string">, your badge number is</span> \(badgeNumber)<span class="string">!"</span>)
  }
}
</code></pre><p>The base class (which we call the <em>superclass</em> in Swift) is specified after the colon. There can be at most one superclass, which keeps Objected-Oriented hierarchies a lot more simple and direct. The expressivity gap with C++'s support for multiple inheritance is mostly filled by the generics system, which we'll get to later (sorry, I keep saying that).</p><p>All inheritance is effectively <code>public</code>. There's no notion of <code>private</code> inheritance, and <code>protected</code> doesn't even exist in Swift. I'm going to ignore Swift's access control for a while longer, and note that when all of your code is in one Swift module, you often don't think about access control, and it's fine.</p><p>Our <code>Employee</code> type has an initializer and a <code>greet</code> method. The <code>greet</code> method overrides the one declared in <code>Person</code>, as indicated by the <code>override</code> keyword. Class members are effectively <code>virtual</code> by default, although one can explicitly mark a specific class or class member as <code>final</code> to cut off all subclassing or overriding for that entity for good. Subtyping and virtual dispatch works as one would expect:</p><pre><code><span class="keyword">let</span> person: <span class="type">Person</span> = <span class="type">Employee</span>(name: <span class="string">"Doug"</span>, age: <span class="number">39</span>, badgeNumber: <span class="number">1</span>)
person.<span class="call">greet</span>() <span class="comment">// prints "Hello Doug, your badge number is 1!"</span>
</code></pre><h2>Member initialization is... backwards?</h2><p>If you looked at the body of that initializer for <code>Employee</code>, it might have freaked you out a little bit:</p><pre><code>   <span class="keyword">init</span>(name: <span class="type">String</span>, age: <span class="type">Int</span>, badgeNumber: <span class="type">Int</span>) {
    <span class="keyword">self</span>.<span class="property">badgeNumber</span> = badgeNumber
    <span class="keyword">super</span>.<span class="keyword">init</span>(name: name, age: age)
  }
</code></pre><p>Notice how we initialized the data members of our subclass (or "derived class" in C++ parlance) first, and <em>then</em> called the superclass initializer. Weird, right?</p><p>This is absolutely not how C++ works: C++ initializes the base classes first, and then the members of the derived class, and then executes the code in the constructor of the derived class. But the C++ model has some weird behaviors with virtual function calls <a href="https://isocpp.org/wiki/faq/strange-inheritance#calling-virtuals-from-ctors">in constructors</a> that fall out of it. Let's see what happens if we write the above classes in C++ and try to greet the person in the constructor:</p><pre><code><span class="keyword">class</span> Person {
public:
  std::string name;
  int age;
  
  <span class="type">Person</span>(const std::string &amp;name, int age) : <span class="call">name</span>(name), <span class="call">age</span>(age) {
    <span class="call">greet</span>()
  }
  
  virtual void <span class="call">greet</span>() {
    std::cout &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; name &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;
  }
}

<span class="keyword">class</span> Employee: <span class="keyword">public</span> <span class="type">Person</span> {
  int badgeNumber;
  
  <span class="type">Employee</span>(const std::string &amp;name, int age, int badgeNumber) 
    : <span class="type">Person</span>(name, age), <span class="call">badgeNumber</span>(badgeNumber) { }
  
  void <span class="call">greet</span>() <span class="keyword">override</span> {
    std::cout &lt;&lt; <span class="string">"Hello "</span> &lt;&lt; name &lt;&lt; <span class="string">", your badge number is "</span> &lt;&lt; badgeNumber &lt;&lt; <span class="string">"!"</span> &lt;&lt; std::endl;
  }
}

<span class="type">Person</span> *person = new <span class="type">Employee</span>(<span class="string">"Doug"</span>, <span class="number">39</span>, <span class="number">1</span>) <span class="comment">// prints "Hello Doug!"</span>
person-&gt;<span class="call">greet</span>(); <span class="comment">// prints "Hello Doug, your badge number is 1!"</span>
</code></pre><p>Weird-er, right? The problem with calling virtual functions in constructors is that the base class constructor doesn't have a fully-formed object of the subclass type, because the members of the derived class haven't been initialized yet, and it would be undefined behavior to access them. So it's not safe for the <code>Person</code> constructor to treat the object as the <code>Employee</code> instance it will eventually be. Instead, it treats the object as an instance of <code>Person</code>, calling <code>Person::greet</code> instead of <code>Employee::greet</code>, causing the difference in behavior above. This is also the reason that it's possible to get errors at runtime due to calls to abstract virtual functions in C++, even though the language prevents you from creating an instance of an abstract type. Supporting this weird semantics is also awful for C++ compiler writes; <a href="https://itanium-cxx-abi.github.io/cxx-abi/abi.html#vtable-ctor">read this</a> if you'd like to feel bad for them.</p><p>Okay, back to Swift. If we go put a call to <code>greet</code> in the initializer for <code>Person</code>, we'll get consistent output:</p><pre><code><span class="type">Hello Doug</span>, your badge number <span class="keyword">is</span> <span class="number">1</span>
<span class="type">Hello Doug</span>, your badge number <span class="keyword">is</span> <span class="number">1</span>
</code></pre><p>The "backwards" initialization required by Swift, where you must initialize all of your own data members before calling your superclass initializer (via <code>super.init</code>), gives an important guarantee: the superclass initializer knows that all of it's subclasses have already initialized all of their own data members before it ever runs. Follow that logic all the way up to the root class's initializer (which has no superclass), and we know that once that initializer has initialized all of its own data members, the object is fully-initialized with its final type. Definite Initialization then makes <code>self</code> available (which happens after the <code>super.init</code> call in non-root classes), so you can call any overridden method in an initializer and get a consistent result. So the Swift approach, while weird at first, provides more consistent semantics with less syntax than C++, and doesn't require any kind of "default" state for data members. Sometimes weird is actually good, eh?</p><h2>Deinitializers</h2><p>Unlike structs and enums, an instance of a class has a well-defined point at which it is destroyed (when it is no longer used). At this point, one can execute cleanup code in the <em>deinitializer</em>. A Swift deinitializer is like a C++ destructor, except it's written as <code>deinit</code> like this:</p><pre><code><span class="comment">// in Person</span>
<span class="keyword">deinit</span> {
  <span class="call">print</span>(<span class="string">"</span>\(name) <span class="string">has expired"</span>)
}
</code></pre><p>Deinitializers are never overridden in the sense that methods are. Rather, all of the deinitializers in the class hierarchy are executed from the most-derived class to the root class, and then all of the data members are destroyed.</p><h2>Downcasting</h2><p>Let's say you have a <code>Person</code> and you want to check whether it's actually an instance of <code>Employee</code>. In C++, you would use <code>dynamic_cast</code> to perform the cast dynamically. In Swift, we use <code>as?</code>, like this:</p><pre><code><span class="keyword">func</span> checkIfEmployee(person: <span class="type">Person</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">if let</span> employee = person <span class="keyword">as</span>? <span class="type">Employee</span> {
    <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
    <span class="keyword">return true</span>
  }
  
  <span class="keyword">return false</span>
}
</code></pre><p>The way to read this is that we are attempting to downcast the <code>person</code> instance into an <code>Employee</code>. If it succeeds, we'll enter the body of the <code>if let</code> with the variable <code>employee</code> bound to the same instance as <code>person</code>, but with type <code>Employee</code>. If it fails, the <code>if</code> body doesn't run.</p><p>Now, sometimes we <em>know</em> based on other invariants in the program that a particular person instance must be an <code>Employee</code>. In C++, you would use a <code>static_cast</code> here (or a <code>dynamic_cast</code> on a reference to the type). In Swift, you can use <code>as!</code>, e.g.,</p><pre><code><span class="call">print</span>(<span class="string">"Employee badge number is #</span>\((person <span class="keyword">as</span>! <span class="type">Employee</span>).<span class="property">badgeNumber</span>)<span class="string">"</span>)
</code></pre><p>Swift is going to check this cast at runtime, and halt the program with an error message if <code>person</code> is not, in fact, an <code>Employee</code>. The <code>as!</code> cast should be used only in rare cases where you're unable to express what you need through the type system, and other invariants ensure that it will always succeed. Just like we always do with <code>static_cast</code> in C++, right? RIGHT?</p><h2>Optionals</h2><p>In bundling together the <code>as?</code> cast and the <code>if let</code> in the example above, I glossed over what's actually happening here. Specifically, the <code>as?</code> can be used anywhere, and it produces a value of <em>optional</em> type. If we were to write:</p><pre><code><span class="keyword">let</span> maybeEmployee = person <span class="keyword">as</span>? <span class="type">Employee</span>
</code></pre><p>The type of <code>maybeEmployee</code> is <code>Employee?</code>, where the question mark implies that might have an <code>Employee</code>, or we might have nothing. If you've used the C++ <a href="https://en.cppreference.com/w/cpp/utility/optional"><code>std::optional</code></a>, it's the same idea, but with syntactic sugar in Swift to make it more ergonomic. <code>if let</code> is one of the ways to check whether there's a value inside an optional:</p><pre><code><span class="keyword">if let</span> employee = maybeEmployee {
  <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
} <span class="keyword">else</span> {
  <span class="comment">// employee is not available</span>
}
</code></pre><p>Here, the <code>if let</code> is checking whether the optional value to the right-hand side of <code>=</code> actually contains a value. If so, it pulls that value out and puts it into the variable declared to the left of the <code>=</code>. Otherwise, the body of the <code>if</code> doesn't run, but the <code>else</code> block (if present) would be executed. The <code>else</code> block does not have access to the <code>employee</code> variable at all.</p><h3>Options for accessing optionals</h3><p><code>if let</code> is the most popular way to extract a value out of an optional, but it isn't the only one. There is also the dual to <code>if</code>, called <code>guard</code>, which helps with the "early returns" style of programming. We could refactor the code above to look like this:</p><pre><code><span class="keyword">guard let</span> employee = maybeEmployee <span class="keyword">else</span> {
  <span class="comment">// employee is not available</span>
  <span class="keyword">return false</span>
}

<span class="comment">// employee is an Employee instance. Use it for the rest of the function</span>
<span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
<span class="keyword">return true</span>
</code></pre><p>A <code>guard</code> statement checks that its conditions are true, which can involving introducing new variables. It also requires an <code>else</code> block that <em>must return</em>, so there is no way to fall out of the <code>else</code> block and into later code. Early returns are <a href="https://www.fluentcpp.com/2018/08/24/how-to-design-early-returns-in-c-based-on-procedural-programming/">surprisingly controversial</a> in C++, I think because you have to mentally dig for the <code>return</code> along all of the paths in the early-returning <code>if</code>. Swift's <code>guard</code> addresses those concerns by giving this pattern a specific keyword up front (<code>guard</code>), making the condition a positive one (you pass the guard if this condition holds), and ensuring that if the condition fails you always do an early return. Enough about <code>guard</code>; back to optionals, shall we?</p><p>The third way one can look into an optional is with a <code>switch</code>, because the <code>?</code> syntax is actually just synactic sugar for a use of the generic <code>Optional</code> type that's defined in the Swift standard library. It looks like this:</p><pre><code><span class="keyword">enum</span> Optional&lt;Wrapped&gt; {
  <span class="keyword">case</span> none
  <span class="keyword">case</span> some(<span class="type">Wrapped</span>)
}
</code></pre><p>The <code>none</code> case means there is no value, and the <code>some</code> case means that there is a value of type <code>Wrapped</code>. The angle brackets are for generics, as one would expect, declaring that <code>Optional</code> has a type parameter (akin to a <em>template type parameter</em> in C++). Given a value of optional type, you can switch on the two cases:</p><pre><code><span class="keyword">switch</span> maybeEmployee {
  <span class="keyword">case</span> .<span class="dotAccess">none</span>:
    <span class="keyword">return false
  
  case</span> .<span class="dotAccess">some</span>(<span class="keyword">let</span> employee):
    <span class="call">print</span>(<span class="string">"Yes, employee badge number is #</span>\(employee.<span class="property">badgeNumber</span>)<span class="string">"</span>)
    <span class="keyword">return true</span>
}
</code></pre><h3>Optionals for dictionary access</h3><p>Optionals can be formed from any type, and are useful for APIs that might return "no result". One great example of this is accessing elements within a Swift <a href="https://developer.apple.com/documentation/swift/dictionary"><code>Dictionary</code></a>, which is like a <a href="https://en.cppreference.com/w/cpp/container/unordered_map"><code>std::unordered_map</code></a>, by looking for an element with a specific key. Let's say we create a dictionary that maps from badge numbers to the employee with that badge number, like this:</p><pre><code><span class="comment">// Create a dictionary from (badgeNumber, employee) pairs</span>
<span class="keyword">let</span> employeesByBadgeNumber: [<span class="type">Int</span>: <span class="type">Employee</span>] = .<span class="keyword">init</span>(uniqueKeysWithValues: employees.<span class="call">map</span> { 
  employee <span class="keyword">in</span> (employee.<span class="property">badgeNumber</span>, employee)
})
</code></pre><p>The use of closures will be explained in a separate post, but if you're used to C++ lambdas, it probably looks familiar already. The <code>[Int: Employee]</code> syntax is sugar for a <code>Dictionary</code> mapping from <code>Int</code> keys to <code>Employee</code> values. It mirrors the syntax of dictionary literals, i.e., <code>[1: doug]</code> is a dictionary containing a single entry mapping <code>1</code> to the <code>doug</code> instance.</p><p>We can look for the employee with a given badge number by subscripting this dictionary. The result of the subscript is going to be an <code>Employee?</code>, i.e., it's the employee if one with that badge number was found, or <code>nil</code> otherwise, which works very nicely with <code>if let</code>:</p><pre><code><span class="keyword">if let</span> employee = employeesByBadgeNumber[<span class="number">17</span>] {
	employee.<span class="call">greet</span>()
}
</code></pre><p>again, the type system is helping here: the obvious way to find the value associated with a key is to use subscript, and it returns an optional so you're sure to handle the case where the value is missing. If you find yourself longing for the insert-a-default-if-nothing-is-there behavior of C++'s <code>std::map</code> and <code>std::unordered_map</code>, there's a special subscript just for you that also takes a default. You could use it like this, say, to count word frequency in a list of words:</p><pre><code><span class="keyword">var</span> frequency: [<span class="type">String</span>: <span class="type">Int</span>] = [:]
<span class="keyword">for</span> word <span class="keyword">in</span> words {
  frequency[word, default: <span class="number">0</span>] += <span class="number">1</span>
}
</code></pre><p>The subscript that takes a default value produces a non-optional value, because an entry <code>[word: 0]</code> will be added if one wasn't already present. So, we can increment the frequency of each word directly.</p><h3>Optional chaining</h3><p>Optionals are really common in Swift code, so the language has a number of affordances to make them easier to work with. For example, earlier we wanted to greet an employee with the given badge number, so we wrote this:</p><pre><code><span class="keyword">if let</span> employee = employeesByBadgeNumber[<span class="number">17</span>] {
	employee.<span class="call">greet</span>()
}
</code></pre><p>This code is fine. It will work. But it's a little bit verbose, with the whole <code>if-let</code> dance to create a new variable. Instead, one can use optional <em>chaining</em> to call the <code>greet</code> method only when there is an employee, like this:</p><pre><code>employeesByBadgeNumber[<span class="number">17</span>]?.<span class="call">greet</span>()
</code></pre><p>The <code>?</code> in this case means that we're doing optional chaining. It is followed by accesses into the instance (i.e., <code>.greet()</code>) that only happen when there is a value inside the optional. You can even chain multiple optional accesses together. For example, let's imagine that our <code>Employee</code> class added a <code>manager</code> data member, i.e.,</p><pre><code><span class="keyword">var</span> manager: <span class="type">Employee</span>? = <span class="keyword">nil</span>
</code></pre><p>We could get the name of the employee 17's manager like this:</p><pre><code><span class="keyword">let</span> managerName = employeesByBadgeNumber[<span class="number">17</span>]?.manager?.<span class="property">name</span>
<span class="comment">// &gt;----------------------------------------^--------^----&gt;
//                                          1        2</span>
</code></pre><p>Evaluation is left-to-right in Swift, so you can read this as looking in the dictionary for an employee with badge number 17. If that <code>Employee?</code> result contains an <code>Employee</code> (i.e., it is not <code>nil</code>) at the point marked #1, then we access the manager of that employee. If the manager data member contains an <code>Employee</code> at the point marked #2, then we access the name of that manager instance.</p><p>But what is the type of the <code>managerName</code> variable? Well, we know that <code>Employee.name</code> is a <code>String</code>, but of course at either #1 or #2 we might have encountered a <code>nil</code> and had to stop evaluation. We can't just leave <code>managerName</code> undefined (gasp!), so instead it gets type <code>String?</code>, where it either stores the result of completing the optional chain or it <code>nil</code> if a <code>nil</code> was encountered along the way.</p><h3>Optionals replace the dreaded NULL</h3><p>In Swift, an instance of class type can never be NULL. If you have a value <code>employee</code> of type <code>Employee</code>, there is always a valid instance there. Instead of NULL pointers, Swift uses optionals: <code>Employee?</code> is either a value employee, or it's <code>nil</code>. But unlike the C++ equivalent of <code>Employee*</code>, Swift has static affordances to make it easy to use optionals correctly. That means no NULL pointer dereferences, no defensive checks against NULL when you're not sure. Unless you're one of the few using a <a href="https://www.cppstories.com/2017/10/notnull/"><code>not_null</code> smart pointer type</a>), it may surprise you at just how liberating it is to stop thinking about the special case of NULL everywhere and let the type checker support you.</p><h3>Aside: How big is an optional?</h3><p>One last little fun bit of trivial: if I run this C++ code, what values should we expect to get?</p><pre><code><span class="keyword">class</span> Employee { };

int <span class="call">main</span>() {
  std::cout &lt;&lt; <span class="call">sizeof</span>(<span class="type">Employee</span>*) &lt;&lt; std::endl;
  std::cout &lt;&lt; <span class="call">sizeof</span>(std::optional&lt;<span class="type">Employee</span>*&gt;) &lt;&lt; std::endl;
}
</code></pre><p>On my system, I get 8 and 16, respectively. Using <code>std::optional</code> doubles the storage needed!</p><p>Now what happens with the Swift equivalent code?</p><pre><code><span class="keyword">class</span> Employee { }

<span class="call">print</span>(<span class="type">MemoryLayout</span>&lt;<span class="type">Employee</span>&gt;.<span class="property">size</span>)
<span class="call">print</span>(<span class="type">MemoryLayout</span>&lt;<span class="type">Employee</span>?&gt;.size)
</code></pre><p>I get 8 for both! Swift is doing an important space optimization behind the scenes: because an <code>Employee</code> must refer to a valid address, and the integral value of 0 is not a valid address, Swift will use the integer representation <code>0</code> to mean the <code>.none</code> of the optional (which corresponds to <code>nil</code>) and all other values to mean the <code>.some</code> case of the optional. Therefore, it can use a single pointer's width of storage to capture an optional value. This is generally good for memory usage, but it's also really important for interoperability with C++, because a C++ pointer value (that can be NULL) can be treated as a Swift optional, and vice-versa.</p><p>Now, if you were to create an optional integer, <code>Int?</code>, you would see that the optional takes more space than a single <code>Int</code>. That's because all possible bit representations in an <code>Int</code> are valid values of an <code>Int</code>, so we add an extra byte (from 8 to 9 on a 64-bit machine) to tell whether we're in the <code>.none</code> or the <code>.some</code> case.</p><p>But the thing is... spare bits and holes in bit representations are everywhere, and Swift will dig to try to find them. For example, let's add a <code>Contractor</code> class and create an enum with three cases:</p><pre><code><span class="keyword">enum</span> Payee {
  <span class="keyword">case</span> employee(<span class="type">Employee</span>)
  <span class="keyword">case</span> contractor(<span class="type">Contractor</span>)
  <span class="keyword">case</span> myself
}
</code></pre><p>How big are <code>Payee</code> and <code>Payee?</code>, based on what we've seen before?. In fact, both are the same 8 bytes on a 64-bit system. It's not magic, it's how computers work: a class like <code>Employee</code> or <code>Contractor</code> is going to be at least 8-byte-aligned, because of it's object header. That means that a valid reference to a class (basically, a pointer) will always have the lowest three bits be zero: anything else would be a misaligned pointer. So between those two cases, we have three common low bits we can use for whatever we want, and the third case (<code>myself</code>) has no data. Three bits is plenty of space to store a discriminator that says whether a given <code>Payee</code> instance is an <code>employee</code>, <code>contractor</code>, or <code>myself</code>: we need only mask off the upper bits to figure out what case we're in, and then mask off the lower bits to get a proper <code>Employee</code> or <code>Contractor</code> pointer when we know which one it is. Cool, right?</p><p>That explains <code>Payee</code>, but what about the optional <code>Payee?</code> size? The principle is the same: <code>Payee</code> only needed two of the three low bits to represent its three cases. That leaves one glorious extra bit to distinguish between the <code>some</code> and <code>none</code> cases, so <code>Payee?</code> still needs only 8 bytes.</p><p>You can do all of these optimization tricks in C++ with template metaprogramming. Clang uses LLVM's <a href="https://llvm.org/doxygen/classllvm_1_1PointerUnion.html"><code>PointerUnion</code></a> class template <em>extensively</em> to get this same kind of memory savings, but it's a whole lot nicer when the language just does it for you and you don't have to think about it.</p><h2>Automatic reference counting</h2><p>By now you've probably noted the lack of <code>delete</code> or <code>free</code> or any other kind of explicit deallocation. Swift provides automatic memory management using reference counting: a new instance of class type is allocated with a reference count of 1. Anything that needs to hold onto the object will increment its reference count to do so, and decrement the reference count when it is no longer needed. When the reference count hits zero, the object will be de-initialized and the memory freed.</p><p>The C++ standard library has a reference-counting smart pointer template, <a href="https://en.cppreference.com/w/cpp/memory/shared_ptr"><code>std::shared_ptr</code></a>. If you've used <code>shared_ptr</code>, you already have a sense of how reference counting works in practice, and you can think of Swift's classes as using roughly the same semantic model but eliminating the syntactic overhead by bringing it into the language. Swift also has an analogue to <a href="https://en.cppreference.com/w/cpp/memory/weak_ptr"><code>std::weak_ptr</code></a>, which is a non-owning reference to something that may be kept alive by other <code>shared_ptr</code> instances.</p><p>However, the <code>shared_ptr</code> analogy is somewhat flawed because <code>std::shared_ptr</code> makes a number of compromises so that it can be used to point to any type. A <code>shared_ptr</code> is often two pointers large, because it has to separate out the "control block" (which handles the reference count) from the raw object pointer. This isn't great for efficiency, and also makes the <code>get()</code> operation particularly dangerous: once you've extracted the raw object pointer, there's no way to get back to the safety of a <code>shared_ptr</code> unless you've also used <a href="https://en.cppreference.com/w/cpp/memory/enable_shared_from_this"><code>std::enable_shared_from_this</code></a>. A better comparison to Swift would be <a href="https://www.boost.org/doc/libs/1_84_0/libs/smart_ptr/doc/html/smart_ptr.html#intrusive_ptr"><code>boost::intrusive_ptr</code></a>, because the Swift reference count is embedded within the object itself. That means you're only passing around a single pointer to the object rather than the two pointers often needed for a <code>std::shared_ptr</code>, and reference-counting operations have better locality with the object.</p><h3>Weak references</h3><p>One problem with reference counting is the potential for reference cycles: if object <code>a</code> holds a reference to object <code>b</code>, and object <code>b</code> holds a reference to object <code>a</code>, then these two objects will keep each other alive even after the rest of the program has forgotten about them, resulting in a leak:</p><pre><code><span class="keyword">class</span> A {
  <span class="keyword">var</span> b: <span class="type">B</span>?
}

<span class="keyword">class</span> B {
  <span class="keyword">var</span> a: <span class="type">A</span>?
}
</code></pre><p>This problem exists in all reference counting implementationds whether it's the C++ <code>std::shared_ptr</code> or <a href="https://devguide.python.org/internals/garbage-collector/">Python</a>. Python has a built-in garbage collector to find these reference cycles and arbitrarily break them to free memory, but such an approach requires a fairly heavy runtime. Swift's approach is more like <code>std::shared_ptr</code>: the programmer is responsible for ensuring there are no reference cycles, and Swift provides tools to identify and deal with them when they happen.</p><p>Weak references are the primary mechanism for breaking cycles. A weak pointer points at an object but does not keep it alive. Weak references are introduced with the <code>weak</code> modifier on a variable, e.g.,</p><pre><code><span class="keyword">class</span> B {
  <span class="keyword">weak var</span> a: <span class="type">A</span>?
}
</code></pre><p>A <code>weak</code> variable must have optional type, because the object it points to might go away at any point. If the object it points to is destroyed, then the weak reference will get the value <code>nil</code>. Code that works with weak references will naturally "promote" the weak reference to a strong reference when working with it, because it's the same operation as determining whether any other optional has a value in it:</p><pre><code><span class="keyword">if let</span> a = b.<span class="property">a</span> {
  <span class="comment">// a has type A, a strong reference that keeps the object alive</span>
}
</code></pre><p>This is akin to the <code>lock()</code> operation of a <code>std::weak_ptr</code> returning a possibly-NULL <code>std::shared_ptr</code>, but benefits from all of the conveniences for optional types that Swift offers.</p><h3>Why reference counting?</h3><p>We opted for reference counting in Swift because we felt it hit the sweet spot for automatic memory management.</p><p>Unlike more traditional garbage collectors, reference counting is deterministic: when your reference count goes to zero, your object goes away. There's no delay until the garbage collector runs where you are using memory than you should be, nor is there ever a need to "pause" the program to run the garbage collector. Moreover, reference counting can be implemented with a tiny runtime footprint---just a couple of atomic operations---vs. a more elaborate garbage collector runtime. It also places no restrictions on the program beyond the need to correctly balance out "retains" and "releases", so you can freely mix reference-counted code with other code in the system (say, in other languages). Finally, reference counting is locally optimizable: if you can prove that an object is kept alive within a given scope, you don't need to perform any reference counting within that region of the code. That means you can optimize away all of the reference counts in a particularly performance-sensitive part of the code while not having to change the basic model used by the same classes elsewhere in the program.</p><p>At the other end of the spectrum from a traditional garbage collector are systems with unique ownership, such as <a href="https://en.cppreference.com/w/cpp/memory/unique_ptr"><code>std::unique_ptr</code></a>. This approach requires no overhead for automatic memory management, but makes it hard to express any data structure that isn't tree-like in nature. Reference counting can express arbitrary graphs of objects directly, making it more flexible than models based on unique ownership.</p><p>Coming from C++, the "automatic" part of Swift's automatic reference counting can be frustrating. The optimizer might not remove all of the reference counting that you want it to, and where in C++ you might just grab the raw pointer when your smart pointers aren't optimizing away, Swift makes it a little harder. My advice here is to profile your code: not some micro-benchmark that's does no work, but your actual code. If reference-counting is causing performance issues, <code>swift_retain</code> and <code>swift_release</code> will light up in your profiler and you can work on optimizing those hot spots. Swift has some tools for helping with this, such as <code>unowned(unsafe)</code> references (which are effectively raw pointers) as well as ways to be deliberate about ownership, such as <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0366-move-function.md">the <code>consume</code> operation</a>. In my experience, most of the time the reference counting isn't in the way, and when it is a problem, one can optimize locally, usually without having to dip into unsafe code.</p><h2>Wrap-up and what's next?</h2><p>We dove into Swift's support for Object-Oriented Programming, which is based on classes with single inheritance and method overriding. We went over initialization (<em>weird</em>, but good) and de-initialization, as well as down casting.</p><p>That led us into the world of optionals, and how Swift uses them to eliminate NULL pointers from the language (Tony Hoare's self-proclaimed <a href="https://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare/">billion-dollar mistake</a>). Optionals are a huge part of working with Swift, even if you stick to the value-semantic world of structs and enums, so it's worth getting a feel for the syntactic constructs that make them easy to work with.</p><p>We're going to take a break on introducing new kinds of types: structs, enums, and classes form the core of Swift's semantic model. Next, we're going to talk a bit about code organization in Swift, and how extensions take all of the fun out of the "free function or member function?" debate.</p>]]></content:encoded></item><item><guid isPermaLink="true">https://www.douggregor.net/posts/swift-for-cxx-practioners-value-types</guid><title>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</title><description>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</description><link>https://www.douggregor.net/posts/swift-for-cxx-practioners-value-types</link><pubDate>Thu, 1 Feb 2024 14:09:00 -0800</pubDate><content:encoded><![CDATA[<h1>Swift for C++ Practitioners, Part 1: Intro &amp; Value Types</h1><p>There is a <a href="https://www.swift.org/getting-started/">Getting Started</a> guide for Swift that's good for a general audience. However, I've noticed that folks coming from C++ tend to struggle with certain aspects of Swift's design, and can get themselves stuck. I think I understand why: the two languages feel similar enough that someone familiar with C++ will take the idioms and patterns from C++ and project them on to Swift, which doesn't always end up well. So, I want to take a different approach to teaching Swift that is specifically geared toward C++ "practitioners": folks who write C++ day-to-day and understand not only the C++ language, but it's standard library and best practices. For you, dear C++ practitioner, I want to teach Swift by mapping from the idioms, patterns, and mental model of C++ into Swift. My hope is that you'll come through this series of posts not just learning Swift, but learning how to use Swift <em>well</em>.</p><p>As a C++ programmer, some parts of Swift will feel like magic, such as separately type-checked generics and value types that compose beautifully, and we'll revel in those. I'll show how some of the aspects of C++ that we've collectively come to view as problematic, such as wrong defaults or avoidable foot guns, are addressed by Swift's design. Other parts of Swift will grate against the sensibilities of a C++ practitioner, and we won't shy away from those, either. Instead, we'll explain what is different, why Swift is designed that way, and how to cope. I live in both worlds: I'm a Swift designer, implementer, and advocate, and yet I've a long history with C++ that includes being a code owner of Clang and spending a decade on the ISO C++ committee. Most of the code I write day-to-day is in the Swift compiler, which is mostly C++ but is migrating toward Swift.</p><blockquote><p><em>Note:</em> You may have heard about <a href="https://www.swift.org/documentation/cxx-interop/">Swift's interoperability with C++</a>. It's a fantastic tool for incrementally moving a C++ code base toward Swift or wrapping up a C++ library in a nicer Swift interface. However, it's the wrong place to start if you know C++ already and want to learn Swift. Instead, I recommend building something purely in Swift first, to get the feel for Swift without the "pull" of existing C++ code toward more C++-centric patterns. You'll be able to integrate Swift better into your existing code bases once you have a solid understanding of both languages.</p></blockquote><p>This is a multi-part series that will walk through the various features of Swift. We'll start with the obligatory "Hello, world" and then dive straight into <em>value types</em>.</p><h2>Hello, World!</h2><p>Okay, let's get this over with: this is "Hello, World" in Swift:</p><pre><code><span class="call">print</span>(<span class="string">"Hello, world!"</span>)
</code></pre><p>But it's more important to greet you, dear C++ practictioner, so let's customize it a little bit:</p><pre><code><span class="keyword">let</span> reader = <span class="string">"dear C++ practitioner"</span>
<span class="call">print</span>(<span class="string">"""
      Hello,</span> \(reader)<span class="string">!
      
      Today, we shall embark on learning a new programming language, Swift.
      """</span>)
</code></pre><p>The <code>let</code> is how we declare an immutable variable, like <code>const</code> in C++, but with stronger guarantees: we'll get to that later. We've omitted the type because Swift does type inference in a manner that's similar to <code>auto</code> in C++, but we could have written the type explicitly with <code>let reader: String</code>. The triple-quotes describe a <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#Multiline-String-Literals">multi-line string literal</a>, and the <code>\(...)</code> syntax within it is <a href="https://docs.swift.org/swift-book/documentation/the-swift-programming-language/stringsandcharacters#String-Interpolation">string interpolation</a>, a feature common in scripting languages that makes it easy to plug values into the middle of a string.</p><h2>Value types</h2><p>C++ provides rich support for <em>value types</em>, i.e., types for which each copy is completely independent of the original. Let's take a simple example with C++ vectors:</p><pre><code>std::vector&lt;std::string&gt; v1 = { <span class="string">"Hello"</span>, <span class="string">"original"</span> };
std::vector&lt;std::string&gt; v2 = v1;
v2[<span class="number">1</span>] = <span class="string">"copy"</span>;
</code></pre><p>Here, <code>v1</code> is a vector containing <code>"Hello"</code> and <code>"original"</code>. When we make a copy <code>v2</code>, that copy is completely independent of the original: the change to <code>v2</code> on the last line, so that it contains <code>"Hello"</code> and <code>"copy"</code> , doesn't modify the original <code>v1</code>.</p><p>Many C++ types are value types, from builtin types like integers and floating-point types to standard library containers like <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>. C++ lets you build your own value types by letting you control how a class type is created, copied, and destroyed, so long as you follow the <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">Rule of Three/Five/Zero</a>.</p><p>Swift also emphasizes value types because they aid <em>local reasoning</em>, which is the ability to look at code in isolation and reason about what it does, and whether it does so correctly. When you make copy a instance of a value type, you don't need to worry that something you do will affect the original. As in C++, many Swift types are value types, including <code>String</code>, <code>Array</code>, and <code>Dictionary</code>, which are analogous to <code>std::string</code>, <code>std::vector</code>, and <code>std::map</code>:</p><pre><code><span class="keyword">let</span> v1: [<span class="type">String</span>] = [<span class="string">"Hello"</span>, <span class="string">"original"</span>] <span class="comment">// [String] is an array type, can also be spelled Array&lt;String&gt;</span>
<span class="keyword">var</span> v2 = v1 <span class="comment">// inferred to also have type [String]</span>
v2[<span class="number">1</span>] = <span class="string">"copy"</span>
<span class="call">print</span>(v1) <span class="comment">// prints ["Hello", "original"]</span>
<span class="call">print</span>(v2) <span class="comment">// prints ["Hello", "copy"]</span>
</code></pre><p>Here we've introduced the <code>var</code> keyword: <code>var</code> introduces variables that can be modified (i.e., they are mutable), whereas <code>let</code> introduces variables that cannot be modified (they are immutable). In Swift, we prefer that you use <code>let</code> wherever you can, because immutability aids local reasoning: it's easier to reason about something if it isn't changing.</p><h3>Aggregating values in structs</h3><p>As in C++, Swift has structs to aggregate data together. While in C++ the difference between <code>struct</code> and <code>class</code> is almost cosmetic (it only impacts whether the defaults are <code>public</code> vs. <code>private</code>), in Swift they are completely different animals. A Swift <code>struct</code> is generally a value type, whereas a Swift <code>class</code> is a class in the Object-Oriented sense of the word, and has <em>reference semantics</em>: copies still refer to the same underlying instance. We'll get back to classes in a later post, because <code>struct</code>s are one way we build value types out of other value types:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
}
</code></pre><p>Structs containing other value types are themselves value types. For example, let's use that labeled point:</p><pre><code><span class="keyword">let</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
<span class="keyword">var</span> p2 = p1
p2.<span class="property">label</span> = <span class="string">"center"</span>

<span class="call">print</span>(p1) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "origin")</span>
<span class="call">print</span>(p2) <span class="comment">// LabeledPoint(x: 0, y: 0, label: "center")</span>
</code></pre><p>That first line is creating a new instance of a <code>LabeledPoint</code>, calling an <em>initializer</em> (that's what Swift calls constructors) to produce the new value from the component parts. The result is on the stack, not the heap, just like you'd expect in C++. Copying the <code>p1</code> value into <code>p2</code> produces a completely separate value, just as you'd expect from the corresponding C++ code.</p><blockquote><p><strong>Labeled arguments</strong>: When creating the new <code>LabeledPoint</code> instance, notice that each of the arguments requires a label, e.g., <code>x:</code>, <code>y:</code>, and <code>label:</code>. By default, all function arguments must be labeled at the call site, which communicates information about what the function will be doing with the corresponding argument, aiding readability. This is particularly useful when combined with default arguments. A function can opt out of having a particular argument labeled, of course, and we'll get back to that later.</p></blockquote><h3>Initialization always goes through initializers</h3><p>C++ has a couple of different ways to initialize an instance of a <code>struct</code>, including constructor calls, initializer lists, default initialization, and copy initialization. Swift settles on one: calling an initializer. Initializers are responsible for initializing all of the fields of the struct before they return (no excuses). The creation of the <code>LabeledPoint</code> in the previous section is using the <em>memberwise</em> initializer that Swift provides automatically for structs, which initializes the fields in order from the corresponding parameters. We could go ahead and write out this initializer directly if we wanted to, like this:</p><pre><code><span class="keyword">struct</span> LabeledPoint {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  <span class="keyword">var</span> label: <span class="type">String</span>
  
  <span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">x</span> = x
    <span class="keyword">self</span>.<span class="property">y</span> = y
    <span class="keyword">self</span>.<span class="property">label</span> = label
  }
}
</code></pre><p>The <code>init</code> keyword is what defines an initializer, and is the equivalent of repeating the class name in C++ to define a constructor, but usually less verbose. <code>self</code> is the Swift equivalent to <code>this</code>, but think of it as being a like a C++ reference (<code>ClassName&amp;</code>) rather than a pointer like it would be in C++ (<code>ClassName*</code>).</p><p>There is no special syntax for initializing the fields in a <code>struct</code>, like there is in C++. Instead, it's just normal assignments to the fields, and the compiler checks that (1) you don't read a field before it's been assigned, and (2) all fields have been assigned before <code>self</code> is referenced as a whole object, including the function return. So let's try out a semantic disaster of an initializer that breaks both rules:</p><pre><code><span class="comment">// in LabeledPoint ...</span>
<span class="keyword">init</span>(x: <span class="type">Double</span>, y: <span class="type">Double</span>, label: <span class="type">String</span>) {
  <span class="keyword">self</span>.<span class="property">y</span> = <span class="keyword">self</span>.<span class="property">x</span>   <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  <span class="keyword">self</span>.<span class="property">x</span> = x
  <span class="keyword">if</span> <span class="type">Int</span>.<span class="call">random</span>(in: <span class="number">0</span>..&lt;<span class="number">2</span>) == <span class="number">1</span> {
    <span class="call">print</span>(<span class="keyword">self</span>) <span class="comment">// error: 'self' used before all stored properties are initialized</span>
  }
} <span class="comment">//  error: return from initializer without initializing all stored properties</span>
</code></pre><p>Uses of uninitialized variables don't happen in Swift, because of a semantic guarantee called <em>definite initialization</em>: the compiler checks that every variable is initialized before it is used, in all execution paths. This applies equally to all code, and it helps define away a class of bugs that bite us in C++:</p><pre><code><span class="keyword">let</span> p: <span class="type">LabeledPoint</span>
<span class="keyword">if</span> y &gt; <span class="number">0</span> {
  p = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
<span class="call">print</span>(p) <span class="comment">// error: constant 'p' used before being initialized</span>
</code></pre><p>Because of definite initialization, Swift has no notion of a default constructor the way C++ does. The variable <code>p</code> <em>is not initialized</em> on the line where it is defined, the way a C++ class with a non-trivial default constructor would be. Rather, you assign to it, and the first assignment is an initialization. You can't read from it before initializing it, so there is no <em>undefined behavior</em> due to uninitialized values.</p><p>You could write an initializer that takes no arguments, and perhaps that makes sense for points to (say) create the origin point, but Swift will never automatically call it: you'll always call it explicitly. Let's write that out so we can demonstrate the Swift equivalent to C++ <a href="https://learn.microsoft.com/en-us/cpp/cpp/delegating-constructors?view=msvc-170">delegating constructors</a>:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>() {
  <span class="keyword">self</span>.<span class="keyword">init</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)
}
</code></pre><p>The call to <code>self.init</code> delegates the responsibility for initializing all of the fields of <code>self</code> to another initializer. The rules of definite initialization kick in here, too: you can't use (or initialize) any of the fields of <code>self</code> before the <code>self.init</code> call, and after that call <code>self</code> is fully initialized.</p><h3>Where's my copy constructor?</h3><p>By now, you've probably noted that we could write an initializer that looks very much like a copy constructor:</p><pre><code><span class="comment">// also in LabeledPoint</span>
<span class="keyword">init</span>(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">self</span>.<span class="property">x</span> = other.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">y</span> = other.<span class="property">y</span>
  <span class="keyword">self</span>.<span class="property">label</span> = other.<span class="property">label</span>
}
</code></pre><p>The <code>_</code> in the declaration of <code>other</code> is a placeholder for "not named", and here it means that the argument to this initializer is not named. Therefore, we can call this initializer with the syntax <code>LabeledPoint(other)</code>, just like one would in C++. However, Swift will never <em>implicitly</em> call an initializer like this, because it's not special in any way.</p><p>Swift will copy, move, and destroy instances of structs by performing those operations directly on each instance property of the <code>struct</code>. In essence, a Swift <code>struct</code> always follows the C++ <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Rc-zero">rule of zero</a>, where one relies on the default implementations of all of the special constructors, assignment operators, and destructor. In practice, this means that it's not possible to observe when Swift is making copies of value types, so the compiler is free to make copies that are necessary for implementing the semantics of the program, and optimize away copies when they are no longer needed. The compiler can even implicitly turn a "copy" into a move when it determines that the source of the copy is going away.</p><p>For a type that needs hold on to resources, Swift has classes, which I've already noted will be the subject of another post. Swift also has a notion of "noncopyable" types, but those will come much later. For now, we'll dive deeper into value types.</p><h3>Immutability runs deep with value types</h3><p>Earlier, we introduced <code>let</code> as a way to create immutable local variables. With value types, immutability is the default. Parameters are immutable unless otherwise specified, which also includes <code>self</code>:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">func</span> badSwapX(<span class="keyword">_</span> other: <span class="type">LabeledPoint</span>) {
  <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>  <span class="comment">// error: 'other' parameter is immutable</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX     <span class="comment">// error: 'self' parameter is immutable</span>
}
</code></pre><p>One can create methods that mutate <code>self</code> by putting the <code>mutating</code> modifier before the <code>func</code> keyword. Let's start with a sensible example:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> reflectOverXAxis() {
  y = -y
}
</code></pre><p>For other parameters, one can place <code>inout</code> on the parameter to indicate that it is meant to be modified by the function. Formally, <code>mutating</code> on the function is equivalant to <code>inout</code> on the <code>self</code> parameter, but Swift uses <code>mutating</code> because it reads better. With <code>inout</code> parameters and <code>mutating</code> methods, we can write a working version of the <code>badSwapX</code> method:</p><pre><code><span class="comment">// in LabeledPoint</span>
<span class="keyword">mutating func</span> swapX(<span class="keyword">_</span> other: <span class="keyword">inout</span> <span class="type">LabeledPoint</span>) {
  <span class="keyword">let</span> tmpX = other.<span class="property">x</span>
  other.<span class="property">x</span> = <span class="keyword">self</span>.<span class="property">x</span>
  <span class="keyword">self</span>.<span class="property">x</span> = tmpX
}
</code></pre><p>When calling a function with an <code>inout</code> argument, the argument must be prefixed with <code>&amp;</code> to indicate that we're passing it's (logical) address to the function. For example, here's a call to <code>swapX</code>:</p><pre><code><span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
p1.<span class="call">swapX</span>(&amp;p2)
</code></pre><p>If the value we are trying to apply <code>&amp;</code> to is immutable, the Swift compiler would produce an error. Note that there is no prefix <code>&amp;</code> on <code>p1</code>, even though it's calling a <code>mutable</code> method: it's not needed because the name of the method should <a href="https://www.swift.org/documentation/api-design-guidelines/">clearly imply the mutation</a>. Of course, if <code>p1</code> were immutable, it would still be an error.</p><p>There are two more important things to say about immutability before we move on to our next kind of value type, <code>enum</code>.</p><p>First, you <em>cannot cheat immutability</em> any more than you can cheat Death. There is no equivalent to the C++ <code>const_cast</code> in Swift. There are no <code>mutable</code> data members in Swift; even a <code>var</code> member of a struct can only be modified on a <code>var</code> instance of that struct. There are no <code>const T&amp;</code> parameters whose values can change out from underneath you: an immutable value is truly immutable, and the compiler makes sure that no matter how an immutable parameter is actually passed (by-value or by-reference), the underlying value won't change. This can be frustrating, because you've given up control about when to pass by-value, pass by <code>const</code> reference, or pass by rvalue reference to do a move. On the other hand, it is liberating: there's no spooky-action-at-a-distance when that <code>const&amp;</code> actually <em>does</em> change underneath you, and you can lean on immutability to make it easier to reason about your code.</p><p>That brings us to the second point: <em>there is no aliasing of inout parameters</em>. Aliasing, as I mean it here, is when two different pass-by-reference parameters actually refer to the same underlying instance. If you've ever had to go add an <code>if (this == &amp;other) { ... }</code> check into your copy or move assignment operator in C++, you know just how vicious unexpected aliasing of parameters can be for program semantics. In Swift, we have the <a href="https://github.com/apple/swift/blob/main/docs/OwnershipManifesto.md#the-law-of-exclusivity">law of exclusivity</a>, which prevents any such aliasing.</p><h3>Memory safety and the law of exclusivity</h3><p>Swift's <em>law of exclusivity</em> states that two accesses to a given value in memory can only occur simultaneously if both of them are reads, so it is an error to (for example) try to form a mutating access (such as passing something <code>inout</code>) while accessing that value. But this isn't some abstract rule that introduces undefined behavior when you mess up: Swift enforces the law of exclusivity through a combination of static checking (which can produce compiler errors if you produce aliasing) and dynamic checking (when it's not possible for the compiler to prove that there is no aliasing).</p><p>Static checking of the law of exclusivity applies when the value being accessed is sufficiently local that it's possible to reason about all possible accesses to that value. Value types are great for this, because two independent <code>var</code> instances of value type are guaranteed not to alias. The compiler can correctly determine that the two <code>inout</code> arguments in the call <code>p1.swapX(&amp;p2)</code> do not alias, because <code>p1</code> and <code>p2</code> are separate variables. If one instead wrote <code>p1.swapX(&amp;p1)</code>, the compiler would produce an error describing the problem:</p><pre><code>=== exclusivity.<span class="property">swift</span>:<span class="number">28</span> ===
   
<span class="number">26</span>    <span class="keyword">var</span> p1 = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"Origin"</span>)
<span class="number">27</span>    <span class="keyword">var</span> p2 = <span class="type">LabeledPoint</span>(x: <span class="number">1</span>, y: <span class="number">1</span>, label: <span class="string">"Upper right unit"</span>)
<span class="number">28</span>    p1.<span class="call">swapX</span>(&amp;p1)
               note: conflicting access <span class="keyword">is</span> here
       error: overlapping accesses to 'p1', but modification requires exclusive access; consider copying to a local variable
<span class="number">29</span>  
</code></pre><p>Now, if we're dealing with a variable that isn't local---say it's a global variable (gasp!) or a member of a reference type like a <code>class</code>, then it's impossible to reason about all of the accesses. Let's build a small contrived example of this:</p><pre><code><span class="keyword">var</span> globalOrigin = <span class="type">LabeledPoint</span>(x: <span class="number">0</span>, y: <span class="number">0</span>, label: <span class="string">"origin"</span>)

<span class="keyword">func</span> swapXWithGlobalOrigin(<span class="keyword">_</span> other: <span class="keyword">inout</span> <span class="type">LabeledPoint</span>) {
  other.<span class="call">swapX</span>(&amp;globalOrigin) <span class="comment">// is this safe?</span>
}

<span class="keyword">func</span> somewhereElse() {
  <span class="call">swapXWithGlobalOrigin</span>(&amp;globalOrigin) <span class="comment">// uh oh</span>
}
</code></pre><p>Within <code>swapXWithGlobalOrigin</code>, there is no way to know whether some other part of the program might access <code>globalOrigin</code> while it runs. So, the Swift compiler will insert a runtime check that tracks when <code>globalOrigin</code> is potentially being modified, and will stop the program if a simultaneous access occurs:</p><pre><code><span class="type">Simultaneous</span> accesses to 0x100e93008, but modification requires exclusive access.
<span class="type">Previous</span> access (a modification) started at t`<span class="call">somewhereElse</span>() + <span class="number">42</span> (0x100e8e95a).
<span class="type">Current</span> access (a modification) started at:
<span class="number">0</span>    libswiftCore.<span class="property">dylib</span>                 0x00007ff82b380890 swift::runtime::<span class="type">AccessSet</span>::<span class="call">insert</span>(swift::runtime::<span class="type">Access</span>*, void*, void*, swift::<span class="type">ExclusivityFlags</span>) + <span class="number">444
1</span>    libswiftCore.<span class="property">dylib</span>                 0x00007ff82b380ae0 swift_beginAccess + <span class="number">66
2</span>    t                                  0x0000000100e8e8d0 <span class="call">swapXWithGlobalOrigin</span>(<span class="keyword">_</span>:) + <span class="number">59
3</span>    t                                  0x0000000100e8e930 <span class="call">somewhereElse</span>() + <span class="number">51
4</span>    t                                  0x0000000100e8ea40 <span class="keyword">static</span> <span class="type">Main</span>.<span class="call">main</span>() + <span class="number">9
5</span>    t                                  0x0000000100e8ea50 <span class="keyword">static</span> <span class="type">Main</span>.<span class="property">$main</span>() + <span class="number">9
6</span>    t                                  0x0000000100e8ea70 main + <span class="number">9
7</span>    dyld                               0x00007ff81aaa9c10 start + <span class="number">1942</span>
<span class="type">Fatal</span> access conflict detected.
</code></pre><p>Most Swift programmers never think about the Law of Exclusivity: it's enforcement is there to prevent mistakes that would cause undefined behavior mayhem in C++, so it's critical to Swift's memory-safety story. But a lot of mutation in Swift works on local values, and the language helps you avoid most of these situations, so the runtime checking is rarely encountered in practice.</p><h3>Enums are the union of enums and unions</h3><p>Enums are one of Swift's loveliest little features. We borrowed them from <a href="https://en.wikipedia.org/wiki/CLU_(programming_language)">CLU</a>, and for a time before Swift 1.0 they even used the keyword <code>oneof</code> . A Swift enum is a type-safe variant, which subsumes C++'s <code>enum</code>, <code>union</code>, and <code>std::variant</code> in one nice little package. An enum can express one of a set of named cases, such as a font size expressed via semantic names:</p><pre><code><span class="keyword">enum</span> FontSize {
  <span class="keyword">case</span> title
  <span class="keyword">case</span> paragraph
  <span class="keyword">case</span> footnote
}
</code></pre><p>This enum works just like you'd expect the equivalent C++ <code>enum class</code>. For example:</p><pre><code><span class="keyword">let</span> fontSize: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>

<span class="keyword">switch</span> fontSize {
  <span class="keyword">case</span> .<span class="dotAccess">title</span>: <span class="call">print</span>(<span class="string">"Title"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">paragraph</span>: <span class="call">print</span>(<span class="string">"Paragraph"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">footnote</span>: <span class="call">print</span>(<span class="string">"Footnote"</span>)
}
</code></pre><p>I snuck a <code>switch</code> statement in there because one often uses switch statements to deal with each of the cases in an enum. Switch statements in Swift must always be exhaustive: if you don't handle all possible cases, you need to add a <code>default</code> clause. This eliminates accidents of omission when (for example) someone adds a new case, and is commonly a warning in C++ compilers. If you've been cringing about the missing <code>break</code> statements above, don't: Swift puts a <code>break</code> before the next case, and if you really want to fall through to the next case, you have to explicitly write <code>fallthrough</code> to do so.</p><p>Back to <code>FontSize</code>: the cases of <code>FontSize</code> are inside the type. If you want to refer to the <code>paragraph</code> case, you can do so with <code>FontSize.paragraph</code>. However, whenever there is type information, such as when you're initializing a variable of type <code>FontSize</code> or switching on a value of type <code>FontSize</code>, you can use the <em>leading dot syntax</em> like <code>.paragraph</code> and let Swift's type inference figure out the type. Compare the above to the corresponding C++ <code>enum class</code>:</p><pre><code><span class="keyword">enum class</span> FontSize {
  title,
  paragraph,
  footnote
};

auto fontSize = <span class="type">FontSize</span>::paragraph;
<span class="keyword">switch</span> (fontSize) {
  <span class="keyword">case</span> <span class="type">FontSize</span>::title: <span class="call">print</span>(<span class="string">"Title"</span>); <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="type">FontSize</span>::paragraph: <span class="call">print</span>(<span class="string">"Paragraph"</span>); <span class="keyword">break</span>;
  <span class="keyword">case</span> <span class="type">FontSize</span>::footnote: <span class="call">print</span>(<span class="string">"Footnote"</span>); <span class="keyword">break</span>;
}
</code></pre><p>It's the little things, but they really do add up to cleaner code. Swift's leading dot syntax works really nicely with labeled arguments, because the argument label implies the type of the argument, leading to very readable code. For example, let's imagine a <code>Font</code> struct that uses <code>FontSize</code> along with <code>FontStyle</code> and <code>FontWeight</code> enums, including some default values:</p><pre><code><span class="keyword">struct</span> Font {
  <span class="keyword">var</span> style: <span class="type">FontStyle</span> = .<span class="dotAccess">sanSerif</span>
  <span class="keyword">var</span> size: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>
  <span class="keyword">var</span> weight: <span class="type">FontWeight</span> = .<span class="dotAccess">regular</span>
}
</code></pre><p>Now, we can create a new <code>Font</code> like this:</p><pre><code><span class="keyword">let</span> font = <span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>)
</code></pre><p>Note how the argument labels <code>size</code> and <code>weight</code> naturally describe the arguments that follow them, and the types provide enough information so we don't need to write out the redundant <code>FontSize</code> and <code>FontWeight</code> types on those arguments. Moreover, we are able to use the default argument for <code>style</code> even though it's the first parameter: labeled arguments make default arguments work really well. These are simple design decisions for a language to make, but they reinforce readable code.</p><p>Alright, back to enums! Imagine that you wrote that <code>FontSize</code> as an <code>enum class</code> in C++. Hold it in your mind. It's simple, it works. Now, someone comes along and tells you that you need to support <em>custom</em> font sizes, which can be expressed in terms of points. Your nice <code>enum class</code> is out the window, because you can't enumerate all of the custom point sizes. Here's the pattern I would use in C++:</p><pre><code><span class="keyword">class</span> FontSize {
public:
  <span class="keyword">enum</span> Kind {
    title,
    paragraph,
    footnote,
    custom
  };

private:
  <span class="type">Kind</span> kind;
  int points; <span class="comment">// only valid when kind == custom</span>

public:
  <span class="type">FontSize</span>() : <span class="call">kind</span>(paragraph) { }
  <span class="type">FontSize</span>(<span class="type">Kind</span> kind) : <span class="call">kind</span>(kind) { <span class="call">assert</span>(kind != custom); }
  
  <span class="keyword">static</span> <span class="type">FontSize</span> <span class="call">forCustom</span>() { 
    <span class="type">FontSize</span> size;
    size.<span class="property">kind</span> = custom;
    size.<span class="property">points</span> = points;
    <span class="keyword">return</span> size;
  }
  
  explicit operator <span class="type">Kind</span>() <span class="call">const</span> { <span class="keyword">return</span> kind; } <span class="comment">// so we can switch</span>
  
  int <span class="call">getPoints</span>() <span class="call">const</span> {
    <span class="call">assert</span>(kind == custom);
    <span class="keyword">return</span> points;
  }
};
</code></pre><p>That is a <em>lot</em> of code. It is implementing a type-safe union that consists of the three simple cases, plus the one <code>custom</code> case. I cringe ever time I have to write one of these in C++ (which happens a lot), because it is so much boilerplate and it's so easy to make a silly mistake. I've yet to come across a C++ technique or library that makes this cleaner. Feel free to let me know if you have a significantly more elegant solution in C++.</p><p>In Swift, you add one case to <code>FontSize</code>:</p><pre><code><span class="keyword">case</span> custom(points: <span class="type">Int</span>)
</code></pre><p>Swift cases can carry values in them, which is why I said earlier that they also are like C++ unions---without all of the undefined behavior. Given this case, I can create a custom font size:</p><pre><code><span class="keyword">let</span> customFont: <span class="type">FontSize</span> = .<span class="call">custom</span>(points: <span class="number">32</span>)
</code></pre><p>And extend my <code>switch</code> statement accordingly:</p><pre><code><span class="keyword">switch</span> fontSize {
  <span class="keyword">case</span> .<span class="dotAccess">title</span>: <span class="call">print</span>(<span class="string">"Title"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">paragraph</span>: <span class="call">print</span>(<span class="string">"Paragraph"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">footnote</span>: <span class="call">print</span>(<span class="string">"Footnote"</span>)
  <span class="keyword">case</span> .<span class="dotAccess">custom</span>(<span class="keyword">let</span> pt): <span class="call">print</span>(<span class="string">"</span>\(pt) <span class="string">points"</span>)
}
</code></pre><p>Swift provides pattern matching. When we match the <code>custom</code> case, we also declare a new variable <code>pt</code> to capture the <code>points</code> value. The value <code>pt</code> is only available when one is using a custom font size, so there's no need for runtime assertions like <code>kind == custom</code> like we had in C++.</p><p>Let's add one more case to our font size, which lets us take an existing font size and scale it by a given factor. It can be expressed like this:</p><pre><code><span class="keyword">indirect case</span> scaled(size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>)
</code></pre><p>This way, one can construct a font that is 20% larger than the paragraph font using, e.g.,</p><pre><code><span class="type">FontSize</span>.<span class="call">scaled</span>(size: .<span class="dotAccess">paragraph</span>, factor: <span class="number">1.2</span>)
</code></pre><p>The <code>indirect</code> is needed to indicate that the value associated with the case (called the <em>associated value</em> in Swift) needs to be stored <em>indirectly</em>, because the associated value contains an instance of <code>FontSize</code> itself. Enums are value types and generally use stack storage, so the <code>indirect</code> indicates when the value for the case needs to be moved off to the heap. If the <code>indirect</code> were missing, the compiler would complain because the <code>FontSize</code> type doesn't have a fixed size in memory:</p><pre><code>=== <span class="type">FontSize</span>.<span class="property">swift</span>:<span class="number">1</span> ===
 <span class="number">1</span>  <span class="keyword">enum</span> FontSize {
          error: recursive <span class="keyword">enum</span> '<span class="type">FontSize</span>' <span class="keyword">is</span> not marked '<span class="keyword">indirect</span>'
 <span class="number">2</span>    <span class="keyword">case</span> title
 <span class="number">3</span>    <span class="keyword">case</span> paragraph
 <span class="number">4</span>    <span class="keyword">case</span> footnote
 <span class="number">5</span>    <span class="keyword">case</span> custom(points: <span class="type">Int</span>)
 <span class="number">6</span>    <span class="keyword">case</span> scaled(size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>)
            note: cycle beginning here: (size: <span class="type">FontSize</span>, factor: <span class="type">Double</span>) -&gt; (.<span class="number">0</span>: <span class="type">FontSize</span>)
 <span class="number">7</span>  }
 <span class="number">8</span>  
</code></pre><p>Indirect enum cases are useful for building recursive data structures, like a binary tree. We'll come back to those when we can do it properly, with generics.</p><p>Now we can create a nice member function that scales the font instance we have by a specific factor:</p><pre><code><span class="comment">// in FontSize</span>
<span class="keyword">func</span> scaled(by factor: <span class="type">Double</span>) -&gt; <span class="type">Self</span> {
  .<span class="call">scaled</span>(size: <span class="keyword">self</span>, factor: factor)
}
</code></pre><p>This can be called as, e.g., <code>myFontSize.scaled(by: 1.2)</code>. There are a few little things to notice here. The first is that enums can have methods just like structs can. They can also have initializers, which must eventually assign one of the cases to <code>self</code>. Next, our function is returning <code>Self</code>, which is shorthand for "the type of <code>self</code>". Finally, look at how the parameter is named, "<code>by factor</code>": here, the <em>argument label</em> is <code>by</code> (it's used at the call site) and the <em>parameter name</em> is <code>factor</code> (it's used inside the body). This is because the argument label is there to describe the argument at the call site, i.e., we're scaling "<code>by</code> 1.2", whereas the parameter name is the noun of what the parameter actually is---the <code>factor</code> used in the computation. Before now, we've seen that the two names are generally the same, or the argument label is omitted, but separating the two can lead to elegant, readable code particularly when the argument label is a preposition.</p><h2>Collections</h2><p>The standard Swift collections types <code>Array</code>, <code>Dictionary</code>, and <code>Set</code> are value types when they are storing value types. For example, we could have an array of <code>Font</code> instances, which will behave as a value type:</p><pre><code><span class="keyword">var</span> fonts = [<span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>), <span class="type">Font</span>(size: .<span class="dotAccess">paragraph</span>)] <span class="comment">// infers type Array&lt;Font&gt;, also written [Font]</span>
<span class="keyword">var</span> oldFonts = fonts  <span class="comment">// copies the contents of fonts</span>
fonts.<span class="call">append</span>(<span class="type">Font</span>(size: .<span class="dotAccess">footnote</span>))
<span class="call">print</span>(fonts.<span class="property">count</span>)    <span class="comment">// 3</span>
<span class="call">print</span>(oldFonts.<span class="property">count</span>) <span class="comment">// 2</span>
fonts[<span class="number">1</span>].weight = .<span class="dotAccess">bold</span> <span class="comment">// doesn't affect oldFonts</span>
</code></pre><p>Dictionaries and sets work similarly. For example, let's build a dictionary that names all of our fonts:</p><pre><code><span class="keyword">var</span> fontsDict = [  <span class="comment">// infers type Dictionary&lt;String, Font&gt;, also written [String: Font]</span>
  <span class="string">"Title"</span> : <span class="type">Font</span>(size: .<span class="dotAccess">title</span>, weight: .<span class="dotAccess">bold</span>), 
  <span class="string">"Paragraph"</span> : <span class="type">Font</span>(size: .<span class="dotAccess">paragraph</span>)
]

<span class="keyword">var</span> oldFontsDict = fontsDict <span class="comment">// make a copy</span>
fontsDict[<span class="string">"Footnote"</span>] = <span class="type">Font</span>(size: .<span class="dotAccess">footnote</span>) <span class="comment">// add an element</span>
<span class="call">print</span>(fontDict.<span class="property">count</span>)    <span class="comment">// 3</span>
<span class="call">print</span>(oldFontsDict.<span class="property">count</span>) <span class="comment">// 2</span>
</code></pre><p>The bracket syntax is used for both dictionary literals (when the elements are <code>key: value</code> pairs) and array literals (when the elements are just... elements). The literals are actually extensible: you can use an array literal to initialize a <code>Set</code>, or even your own type, by defining an appropriate initializer and opting in to be "expressible by" that literal type using the generics system. (More on that in a later post, I promise.)</p><h2>Regular types</h2><p>In C++ we sometimes talk about <a href="http://stepanovpapers.com/DeSt98.pdf">regular types</a>, defined by Alexander Stepanov, which are types that behave predictably with respect to value semantics: you can copy them, and the copy is equal to the original. They can be moved, destroyed, and swapped. C++20 has a <a href="https://en.cppreference.com/w/cpp/concepts/regular"><code>std::regular</code> concept</a> to capture these requirements.</p><p>Swift value types fulfill most of the requirements of a regular type by default, and are based on the same semantic contract. Swift value types are always copyable, destructible, assignable, and movable. Indeed, you can't really even express these ideas in Swift, it's just the way types behave.</p><p>However, there are some notable differences from the Stepanov or C++ standard definitions of a regular type. The first was noted earlier: Swift doesn't have a notion of "default construction" at all, so Swift value types are not "default constructible". You tend not to need this notion in Swift, though, because of definite initialization. There is a benefit here for the authors of types: you don't have to worry about inventing a "default" state if one doesn't make sense. For example, imagine an collection that is always non-empty: how would you give it a default constructor? You can't without doing something weird, like adding a single default-constructed element, so such a type can't be regular.</p><p>Regular types also have (in)equality operators (<code>==</code> and <code>!=</code>). Swift doesn't provide those for free, but you can either write them yourself with, e.g.,</p><pre><code><span class="comment">// in Font</span>
<span class="keyword">static func</span> ==(lhs: <span class="type">Font</span>, rhs: <span class="type">Font</span>) -&gt; <span class="type">Bool</span> {
  <span class="keyword">return</span> lhs.<span class="property">style</span> == rhs.<span class="property">style</span> &amp;&amp; lhs.<span class="property">size</span> == rhs.<span class="property">size</span> &amp;&amp; lhs.<span class="property">weight</span> == rhs.<span class="property">weight</span>
}
</code></pre><p>or let the compiler do it for you, by putting <code>: Equatable</code> in the type definition:</p><pre><code><span class="keyword">struct</span> Font: <span class="type">Equatable</span> {
  <span class="keyword">var</span> style: <span class="type">FontStyle</span> = .<span class="dotAccess">sanSerif</span>
  <span class="keyword">var</span> size: <span class="type">FontSize</span> = .<span class="dotAccess">paragraph</span>
  <span class="keyword">var</span> weight: <span class="type">FontWeight</span> = .<span class="dotAccess">regular</span>
}
</code></pre><p>This says that the <code>Font</code> type is <code>Equatable</code>, and the compiler will synthesize both <code>==</code> and <code>!=</code> for you based on the data members. You can also put <code>Hashable</code> here to get a hash function that combines the data members, which then allows your type to be used as a key in a <code>Dictionary</code> or a value in a <code>Set</code>. Again, this is dipping our toes into Swift's generics system, but for now you can think of <code>Equatable</code> as being a little bit like a C++ concept (we call it a <em>protocol</em> in Swift), but... better.</p><h2>What's next?</h2><p>We've talked about value types---a lot. If you're writing Swift, you should use them often, because they provide excellent local reasoning and the ability to model most data in a straightforward manner: <code>struct</code>s and collections to aggregate data and <code>enum</code>s to capture different choices.</p><p>In the next part of this series, we'll talk about reference types. Specifically, classes, and how Swift supports Object-Oriented Programming.</p>]]></content:encoded></item></channel></rss>