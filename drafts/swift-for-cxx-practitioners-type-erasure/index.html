<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-type-erasure"/><meta name="twitter:url" content="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-type-erasure"/><meta property="og:url" content="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-type-erasure"/><title>Swift for C++ Practitioners, Part 5: Type erasure | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 5: Type erasure | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 5: Type erasure | Doug's Compiler Corner"/><meta name="description" content="Musings on programming languages and compilers."/><meta name="twitter:description" content="Musings on programming languages and compilers."/><meta property="og:description" content="Musings on programming languages and compilers."/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts">Posts</a></li></ul></nav></div></header><div class="wrapper"><p>---</p><p>date: 2024-04-07 10:14</p><p>description: Swift for C++ Practitioners, Part 5: Type erasure</p><p>tags: Swift, C++</p><p>---</p><h1>Swift for C++ Practitioners, Part 5: Type erasure</h1><p>What do you do in C++ when you want to support different types, but don't want to have one template instantiation per type? Yes, you can introduce a class hierarchy with virtual functions, but more often a better answer is to use <em>type erasure</em>. Type erasure is a mechanism for <em>runtime polymorphism</em>, allowing you to provide different types at runtime while using the same code through a single, concrete type. The C++ standard library contains two type-erased utility types: <a href="https://en.cppreference.com/w/cpp/utility/any"><code>std::any</code></a> and <a href="https://en.cppreference.com/w/cpp/utility/functional/function"><code>std::function</code></a>. In both cases, you can have a concrete value whose underlying type can change:</p><pre><code>std::any a = <span class="number">17</span>;              <span class="comment">// okay, stores an int</span>
a = std::<span class="call">string</span>(<span class="string">"hello"</span>);     <span class="comment">// now it stores a std::string!</span>

std::function&lt;<span class="call">int</span>(int, int)&gt; op = [](int a, int b) { <span class="keyword">return</span> a + b; }; <span class="comment">// okay, it adds integers</span>
op = [](int a, int b) { <span class="keyword">return</span> a * b; }                               <span class="comment">// now it multiplies them!</span>
</code></pre><p>Type erasure in C++ has been around for a long time, and it's a useful technique. <a href="https://www.boost.org/doc/libs/1_84_0/doc/html/any.html">Boost.Any</a> popularized the idea, and now there are numerous blog posts describing implementation techniques and C++ libraries implementing them.</p><p>In Swift, it's part of the language, and you can type-erase any protocol using the keyword <code>any</code>. In this post, we're going to dive into how Swift handles type erasure, and explore related features like <em>metatypes</em> and <em>opaque types</em>.</p><h2>The basics of type erasure</h2><p>For example, let's bring that the <code>Quantifiable</code> protocol from the last post. It looked like this:</p><pre><code><span class="keyword">protocol</span> Quantifiable {
  <span class="keyword">func</span> cost() -&gt; <span class="type">Double</span>
}
</code></pre><p>One can conform types to <code>Quantifiable</code> and write generic algorithms using <code>Quantifiable</code> as a constraint. If we want to use runtime polymorphism to store a value of any <code>Quantifiable</code> type, we can do so with <code>any Quantifiable</code> like this:</p><pre><code><span class="keyword">var</span> q: any <span class="type">Quantifiable</span> = <span class="number">1</span>   <span class="comment">// okay, Int conforms to Quantifiable</span>
<span class="call">print</span>(q.<span class="call">cost</span>())               <span class="comment">// can use the members of the Quantifiable protocol</span>

q = <span class="string">"Hello"</span>                   <span class="comment">// okay, String conforms to Quantifiable</span>
</code></pre><p>You can think of the type of <code>q</code> as being "anything that is <code>Quantifiable</code>": the actual type isn't known until runtime, and can change by reassigning the variable to another value with a different type.</p><p>One can compose multiple protocols together using the <code>&amp;</code> sign. For example, a value of type <code>any Quantifiable &amp; Describable</code> can hold a value of any type that conforms to both <code>Quantifiable</code> and <code>Describable</code>, and you can use any operations that are available to a <code>Describable</code> type or <code>Quantifiable</code> type:</p><pre><code><span class="keyword">var</span> dq: any <span class="type">Quantifiable</span> &amp; <span class="type">Describable</span> = <span class="number">1</span>
dq.<span class="call">cost</span>()
dq.<span class="call">describe</span>()
</code></pre><p>The Swift equivalent to <code>std::any</code> is called, simply, <code>Any</code>: it is effectively an <code>any</code> type with no protocols listed, so it can store a value of any type in it. Now, just like with <code>std::any</code>, you can't do much with a value of type <code>Any</code> other than copy it around, because there are aren't many operations that work on all types.</p><h2>Dynamic casting</h2><p>One thing you can do with values of <code>Any</code> type is to perform a runtime check of the actual stored type. This is accomplished with the same <code>as?</code> cast we introduced for downcasting to a subclass. For example, here's a function that checks whether a value of type <code>Any</code> is actually an <code>Int</code>:</p><pre><code><span class="keyword">func</span> maybeIntValue(<span class="keyword">_</span> value: <span class="type">Any</span>) -&gt; <span class="type">Int</span>? {
  <span class="keyword">if let</span> integer = value <span class="keyword">as</span>? <span class="type">Int</span> {
    <span class="keyword">return</span> integer
  }
  
  <span class="keyword">return nil</span>
}
</code></pre><p>The same works for <code>switch</code> statements, if one wants to enumerate potential types:</p><pre><code><span class="keyword">func</span> whatAmI(<span class="keyword">_</span> value: <span class="type">Any</span>) {
  <span class="keyword">switch</span> value {
    <span class="keyword">case let</span> bool <span class="keyword">as</span> <span class="type">Bool</span>: <span class="call">print</span>(<span class="string">"Bool</span> \(bool)<span class="string">"</span>)
    <span class="keyword">case let</span> integer <span class="keyword">as</span> <span class="type">Int</span>: <span class="call">print</span>(<span class="string">"Integer</span> \(integer)<span class="string">"</span>)
    <span class="keyword">case let</span> double <span class="keyword">as</span> <span class="type">Double</span>: <span class="call">print</span>(<span class="string">"Double</span> \(double)<span class="string">"</span>)
    <span class="keyword">case let</span> string <span class="keyword">as</span> <span class="type">String</span>: <span class="call">print</span>(<span class="string">"String</span> \(string)<span class="string">"</span>)
    <span class="keyword">default</span>: <span class="call">print</span>(<span class="string">"I don't know what this is"</span>)
  }
}
</code></pre><p>Such a <code>switch</code> must have a <code>default</code> clause, because there's no way to enumerate every type. The Swift compiler will produce an error <code>switch must be exhaustive</code> if you forget.</p><p>One particularly important aspect of dynamic casting is that you can cast to an <code>any</code> type, which lets you discover the capabilities of a value at runtime. For example, one can cast to <code>any Quantifiable</code> to determine whether a value conforms to <code>Quantifiable</code>.</p><pre><code><span class="keyword">var</span> value: <span class="type">Any</span> = <span class="number">1</span>
<span class="keyword">if let</span> q = value <span class="keyword">as</span>? any <span class="type">Quantifiable</span> {
  <span class="call">print</span>(<span class="string">"Cost is</span> \(q.<span class="call">cost</span>())<span class="string">"</span>)
}
</code></pre><p>Dynamic casting allows one to rediscover type information that has been remove by type erasure. It's common in very dynamic programs where values are dynamically produced in one place, such as via a global registry or deserialization, and consumed elsewhere. To build something like that, which dynamically creates values of potentially unknown type, we need one more Swift feature: metatypes.</p><h2>Metatypes</h2><p>In the prior post on generics, I noted that Swift doesn't have an equivalent to the <code>decltype</code> type in C++. Swift does, however, have a function named <code>type(of:)</code>, which produces the type of its argument. However, it's not producing a type, but a value representing the type, i.e., a <em>metatype</em>.</p><p>Metatypes in Swift are spelled with the <code>.Type</code> suffix, so if we have a type <code>Point</code>:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Double</span>
  <span class="keyword">var</span> y: <span class="type">Double</span>
  
  <span class="keyword">static var</span> origin: <span class="type">Double</span> = <span class="type">Person</span>(x: <span class="number">0</span>, y: <span class="number">0</span>)
}
</code></pre><p>The metatype of <code>Point</code> has the type <code>Point.Type</code>. One can form a value of this type with the expression <code>Point.self</code>.</p><pre><code><span class="keyword">let</span> pointType: <span class="type">Point</span>.<span class="type">Type</span> = <span class="type">Point</span>.<span class="keyword">self</span>
</code></pre><p>What can you do with a metatype? For one thing, you can access static methods and properties, or call an initializer of that type to produce a new value, like this:</p><pre><code><span class="keyword">let</span> point = pointType.<span class="keyword">init</span>(x: <span class="number">0.0</span>, y: <span class="number">0.0</span>)
<span class="keyword">let</span> origin = pointType.<span class="property">origin</span>
</code></pre><p>Technically, when you write <code>Point(x: 0.0, y: 0.0)</code>, you're using syntactic sugar for <code>PointType.self.init(x: 0.0, y: 0.0)</code>.</p><p>The <code>type(of:)</code> operation has this generic signature:</p><pre><code><span class="keyword">func</span> type&lt;T&gt;(of value: <span class="type">T</span>) -&gt; <span class="type">T</span>.<span class="type">Type</span>
</code></pre><p>So if we pass an instance of <code>Point</code> to <code>type(of:)</code>, we get back a <code>Point.Type</code> instance.</p><h3>Class metatypes</h3><p>Metatypes of structs and enums, by themselves, aren't very interesting, because you could generally just refer to the type. With classes, metatypes become a lot more interesting because an instance of class type could actually store one of its subclasses. Let's build a small class hierarchy:</p><pre><code><span class="keyword">class</span> Person {
  <span class="keyword">var</span> name: <span class="type">String</span>
  
  <span class="keyword">required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="property">name</span> = name
  }
  
  <span class="keyword">class var</span> serializedClassName: <span class="type">String</span> { <span class="string">"PERSON"</span>}
}

<span class="keyword">class</span> Programmer: <span class="type">Person</span> {
  <span class="keyword">var</span> favoriteLanguage: <span class="type">String</span>? = <span class="keyword">nil
  
  required init</span>(name: <span class="type">String</span>) {
    <span class="keyword">self</span>.<span class="keyword">init</span>(name: name, favoriteLanguage: <span class="keyword">nil</span>)
  }
  
  <span class="keyword">init</span>(name: <span class="type">String</span>, favoriteLanguage: <span class="type">String</span>?) {
    <span class="keyword">self</span>.<span class="property">favoriteLanguage</span> = favoriteLanguage
	  <span class="keyword">super</span>.<span class="keyword">init</span>(name: name)
  }
  
  <span class="keyword">override class var</span> serializedClassName: <span class="type">String</span> { <span class="string">"PROGRAMMER"</span> }
}
</code></pre><p>Please ignore the <code>required</code> and <code>class var</code> for the moment---we'll get there shortly. First, let's imagine that we have a <code>person</code> instance, and we ask for its type via <code>type(of: person)</code>:</p><pre><code><span class="keyword">var</span> person: <span class="type">Person</span> = <span class="comment">/*build some kind of person */</span>
<span class="keyword">var</span> personType: <span class="type">Person</span>.<span class="type">Type</span> = <span class="call">type</span>(of: person)
</code></pre><p>Statically, the type of <code>person</code> can only be expressed as <code>Person.Type</code>. But dynamically, the <code>person</code> instance can store a <code>Person</code> object, or a <code>Programmer</code> object, or any instance of any other subclass of <code>Person</code>. The <code>type(of:)</code> operation produces a value of (static) type <code>Person.Type</code>, which dynamically could be <code>Person.self</code>, <code>Programmer.self</code>, or any other subclass's metatype. It's obvious, and a little mind-bending, but then it's obvious again.</p><p>What can we do with a metatype? For one, we can use <code>class</code> methods and properties, which are the overridable equivalent of <code>static</code> methods and properties. (Within a class, <code>static</code> is a synonym for <code>class final</code>). For example, the following:</p><pre><code><span class="call">print</span>(personType.<span class="property">serializecClassName</span>)
</code></pre><p>If <code>person</code> dynamically stores a <code>Person</code> instance, the metatype in <code>personType</code> will be <code>Person.self</code>, and it'll print <code>PERSON</code>. If <code>person</code> dynamically stores a <code>Programmer</code> instance, the metatype in <code>personType</code> will be <code>Programmer.self</code> and it'll print <code>PROGRAMMER</code>.</p><p>We can also initialize a new object by calling <code>personType.init(name:)</code>:</p><pre><code><span class="keyword">let</span> newPerson = personType.<span class="keyword">init</span>(name: <span class="string">"Doug"</span>)
</code></pre><p>and <code>newPerson</code> will have the same type as <code>person</code>. Note that this needs the initializer to be marked <code>required</code>: a <code>required</code> initializer must be implemented by every subclass. They're also needed to satisfying <code>init</code> requirements of a protocol to which the class conformances. For example:</p><pre><code><span class="keyword">protocol</span> InitByName {
  <span class="keyword">init</span>(name: <span class="type">String</span>)
}

<span class="keyword">extension</span> <span class="type">Person</span>: <span class="type">InitByName</span> { 
  <span class="comment">// okay, because init(name:) is a required initializer</span>
}
</code></pre><p>This is important because making <code>Person</code> conform to <code>InitByName</code> implies that every subclass of person conforms to <code>InitByName</code>, and therefore must be properly initializable via <code>init(name:)</code>. It also hints at our next step in the generalization of this idea...</p><h3><code>any</code> metatypes</h3><h3>Primary associated types</h3><h3>Implicit "opening"</h3><h3>Metatypes</h3><h2>Equality of types</h2><h3>Opaque types</h3></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>