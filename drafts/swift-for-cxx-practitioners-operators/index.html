<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"/><meta property="og:site_name" content="Doug's Compiler Corner"/><link rel="canonical" href="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-operators"/><meta name="twitter:url" content="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-operators"/><meta property="og:url" content="https://www.douggregor.net/drafts/swift-for-cxx-practitioners-operators"/><title>Swift for C++ Practitioners, Part 10: Operator Overloading | Doug's Compiler Corner</title><meta name="twitter:title" content="Swift for C++ Practitioners, Part 10: Operator Overloading | Doug's Compiler Corner"/><meta property="og:title" content="Swift for C++ Practitioners, Part 10: Operator Overloading | Doug's Compiler Corner"/><meta name="description" content="Swift for C++ Practitioners, Part 10: Operator Overloading"/><meta name="twitter:description" content="Swift for C++ Practitioners, Part 10: Operator Overloading"/><meta property="og:description" content="Swift for C++ Practitioners, Part 10: Operator Overloading"/><meta name="twitter:card" content="summary"/><link rel="stylesheet" href="/styles.css" type="text/css"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><link rel="shortcut icon" href="/images/favicon.png" type="image/png"/><link rel="alternate" href="/feed.rss" type="application/rss+xml" title="Subscribe to Doug's Compiler Corner"/></head><body><header><div class="wrapper"><a href="/" class="site-name">Doug's Compiler Corner</a><nav><ul><li><a href="/about">About</a></li><li><a href="/posts">Posts</a></li></ul></nav></div></header><div class="wrapper"><h1>Swift for C++ Practitioners, Part 10: Operator Overloading</h1><p>One of the ways in which C++ lets you define library types that feel like built-in types is operator overloading: you can define you own type (say, an big integer or a matrix type), and along with it a reasonable set of operators like <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Operator overloading also lets you treat classes like functions and introduce subscripts. Swift provides a rather more... extensive... operator overloading system, along with related features that help with building DSLs. Let's start with operator overloading, and along the way we'll also tackle Swift "key paths", which are conceptually similar to pointer-to-members in C++.</p><h2>Operator overloading</h2><p>C++ operator overloading can be (and has been) abused: the standard library's use of the left-shift operator (<code>&lt;&lt;</code>) for output streaming is a little bit sus, because "shift left" and "output to a stream" really have no business being the same operator, and the arithmetic <code>&lt;&lt;</code> doesn't necessarily have the precedence you want for output streaming. Some libraries (Boost.Spirit (TODO: cite) is a favorite example) take operator overloading to the extreme, providing a completely different meaning for each of the standard operators. Sometimes it works, sometimes it creates confusion.</p><p>In Swift, we wanted operator overloading for its expressive power in libraries, but were concerned about falling into the same trap where the same set of operators have very different meanings in different libraries. Perhaps we could have created some restrictions to avoid having different meanings for the same operators, but instead we went the completely opposite direction in a delightful bit of over-engineering: in Swift, libraries can define their <em>own sets of operators</em> with their own precedence relationships. If you need some operators to make your library API great, and the meanings don't match with the standard set of operators, <em>no problem</em>: define your own operator so there's no confusion.</p><h3>Operators &amp; precedence groups</h3><p>Swift has two kinds of declarations for producing the standard operators: <code>operator</code> and <code>precedencegroup</code>. The <code>operator</code> declaration spells out the name of an operator along with its kind (<code>infix</code>, <code>prefix</code>, or <code>postfix</code>). For example, let's say we deeply miss C+'s prefix <code>*</code> for pointer syntax. We can declare such an operator like this:</p><pre><code>prefix operator *
</code></pre><p>And then we can go ahead and add a <code>*</code> implementation to <code>UnsafePointer</code> to read the value:</p><pre><code><span class="keyword">extension</span> <span class="type">UnsafePointer</span> {
  <span class="keyword">static prefix func</span> *(<span class="keyword">_</span> pointer: <span class="type">Self</span>) -&gt; <span class="type">Pointee</span> { pointee }
}
</code></pre><p>Infix (binary) operators have a precedence group associated with them. The precedence group is given a name, associativity (<code>left</code> or <code>right</code>), and relationship to other precedence groups. For example, let's say we want to create a <code>&lt;&lt;&lt;</code> operator that streams out values but doesn't stomp on the bit-shift operator. It's an infix operator that could look like this:</p><pre><code>infix operator &lt;&lt;&lt;: <span class="type">OutputStreaming</span>
</code></pre><p>Here, <code>OutputStreaming</code> is a precedence group. We could define it to be a standalone precedence group, unrelated to all others, like this:</p><pre><code>precedencegroup <span class="type">OutputStreaming</span> { }
</code></pre><p>Now, we can use <code>&lt;&lt;&lt;</code> as an infix operator. Here's a little <code>OutputStream</code> class to show how we can define such an operator for use:</p><pre><code><span class="keyword">class</span> OutputStream {
    <span class="keyword">static func</span> &lt;&lt;&lt;(lhs: <span class="type">OutputStream</span>, rhs: <span class="type">Int</span>) -&gt; <span class="type">OutputStream</span> {
        <span class="comment">// stream it</span>
        <span class="keyword">return</span> lhs
    }
}
</code></pre><p>Now if we have value <code>os</code> of type <code>OutputStream</code>, we can write the expression <code>os &lt;&lt;&lt; 17</code>.</p><p>But... what happens if we write the expression <code>os &lt;&lt;&lt; 17 &lt;&lt;&lt; 42</code>? We get an error:</p><pre><code>error: adjacent operators are <span class="keyword">in</span> non-associative precedence group '<span class="type">OutputStreaming</span>'
</code></pre><p>The problem here is that we haven't specified whether the <code>&lt;&lt;&lt;</code> operator should be read as the left-associative <code>(os &lt;&lt;&lt; 17) &lt;&lt; 42</code> or the right-associative <code>os &lt;&lt;&lt; (17 &lt;&lt;&lt; 42)</code>. Since our design is mimicking C++ output streaming by returning the left-hand operand, we meant to make it left-associative, so let's specify that:</p><pre><code>precedencegroup <span class="type">OutputStreaming</span> { 
    associativity: left
}
</code></pre><p>Now, our expression parses. The next thing to consider is how <code>&lt;&lt;&lt;</code> works along with other operators. For example, how should the expression <code>os &lt;&lt;&lt; 17 + 25</code> be handled? It could be treated as <code>(os &lt;&lt; 17) + 25</code> or <code>os &lt;&lt; (17 + 25)</code>, or could even be considered an error that requires the user to write parentheses. The default behavior is an error, like this:</p><pre><code>error: adjacent operators are <span class="keyword">in</span> unordered precedence groups '<span class="type">OutputStreaming</span>' and '<span class="type">AdditionPrecedence</span>'
</code></pre><p>What's this <code>AdditionPrecedence</code> thing, you say? Well, it comes... from the Swift standard library.</p><h3>Standard operators</h3><p>As I've mentioned before, the "standard" types in Swift are expressed using the same tools that are available to all Swift libraries. We saw it with types like <code>Int</code> and <code>Array</code> being defined in the standard library (not the language), and more recently with extensibility of literals. The same principle applies to the "standard" operators that we think of as being part of the language: the full set of arithmetic and Boolean operators are defined in the standard library with precedence relations. Here is the full set of standard precedence groups:</p><pre><code>precedencegroup <span class="type">AssignmentPrecedence</span> {
  associativity: right
  assignment: <span class="keyword">true</span>
}
precedencegroup <span class="type">FunctionArrowPrecedence</span> {
  associativity: right
  higherThan: <span class="type">AssignmentPrecedence</span>
}
precedencegroup <span class="type">TernaryPrecedence</span> {
  associativity: right
  higherThan: <span class="type">FunctionArrowPrecedence</span>
}
precedencegroup <span class="type">DefaultPrecedence</span> {
  higherThan: <span class="type">TernaryPrecedence</span>
}
precedencegroup <span class="type">LogicalDisjunctionPrecedence</span> {
  associativity: left
  higherThan: <span class="type">TernaryPrecedence</span>
}
precedencegroup <span class="type">LogicalConjunctionPrecedence</span> {
  associativity: left
  higherThan: <span class="type">LogicalDisjunctionPrecedence</span>
}
precedencegroup <span class="type">ComparisonPrecedence</span> {
  higherThan: <span class="type">LogicalConjunctionPrecedence</span>
}
precedencegroup <span class="type">NilCoalescingPrecedence</span> {
  associativity: right
  higherThan: <span class="type">ComparisonPrecedence</span>
}
precedencegroup <span class="type">CastingPrecedence</span> {
  higherThan: <span class="type">NilCoalescingPrecedence</span>
}
precedencegroup <span class="type">RangeFormationPrecedence</span> {
  higherThan: <span class="type">CastingPrecedence</span>
}
precedencegroup <span class="type">AdditionPrecedence</span> {
  associativity: left
  higherThan: <span class="type">RangeFormationPrecedence</span>
}
precedencegroup <span class="type">MultiplicationPrecedence</span> {
  associativity: left
  higherThan: <span class="type">AdditionPrecedence</span>
}
precedencegroup <span class="type">BitwiseShiftPrecedence</span> {
  higherThan: <span class="type">MultiplicationPrecedence</span>
}
</code></pre><p>The various operators available in the Swift standard library use these precedence groups:</p><pre><code>infix operator &lt;&lt; : <span class="type">BitwiseShiftPrecedence</span>
infix operator &amp;&lt;&lt; : <span class="type">BitwiseShiftPrecedence</span>
infix operator &gt;&gt; : <span class="type">BitwiseShiftPrecedence</span>
infix operator &amp;&gt;&gt; : <span class="type">BitwiseShiftPrecedence</span>

infix operator * : <span class="type">MultiplicationPrecedence</span>
infix operator &amp;* : <span class="type">MultiplicationPrecedence</span>
infix operator / : <span class="type">MultiplicationPrecedence</span>
infix operator % : <span class="type">MultiplicationPrecedence</span>
infix operator &amp; : <span class="type">MultiplicationPrecedence</span>

infix operator + : <span class="type">AdditionPrecedence</span>
infix operator &amp;+ : <span class="type">AdditionPrecedence</span>
infix operator - : <span class="type">AdditionPrecedence</span>
infix operator &amp;- : <span class="type">AdditionPrecedence</span>
infix operator | : <span class="type">AdditionPrecedence</span>
infix operator ^ : <span class="type">AdditionPrecedence</span>

infix operator ... : <span class="type">RangeFormationPrecedence</span>
infix operator ..&lt; : <span class="type">RangeFormationPrecedence</span>

infix operator ?? : <span class="type">NilCoalescingPrecedence</span>

infix operator &lt; : <span class="type">ComparisonPrecedence</span>
infix operator &lt;= : <span class="type">ComparisonPrecedence</span>
infix operator &gt; : <span class="type">ComparisonPrecedence</span>
infix operator &gt;= : <span class="type">ComparisonPrecedence</span>
infix operator == : <span class="type">ComparisonPrecedence</span>
infix operator != : <span class="type">ComparisonPrecedence</span>

infix operator === : <span class="type">ComparisonPrecedence</span>
infix operator !== : <span class="type">ComparisonPrecedence</span>
infix operator ~= : <span class="type">ComparisonPrecedence</span>

infix operator &amp;&amp; : <span class="type">LogicalConjunctionPrecedence</span>

infix operator || : <span class="type">LogicalDisjunctionPrecedence</span>

infix operator *= : <span class="type">AssignmentPrecedence</span>
infix operator &amp;*= : <span class="type">AssignmentPrecedence</span>
infix operator /= : <span class="type">AssignmentPrecedence</span>
infix operator %= : <span class="type">AssignmentPrecedence</span>
infix operator += : <span class="type">AssignmentPrecedence</span>
infix operator &amp;+= : <span class="type">AssignmentPrecedence</span>
infix operator -= : <span class="type">AssignmentPrecedence</span>
infix operator &amp;-= : <span class="type">AssignmentPrecedence</span>
infix operator &lt;&lt;= : <span class="type">AssignmentPrecedence</span>
infix operator &amp;&lt;&lt;= : <span class="type">AssignmentPrecedence</span>
infix operator &gt;&gt;= : <span class="type">AssignmentPrecedence</span>
infix operator &amp;&gt;&gt;= : <span class="type">AssignmentPrecedence</span>
infix operator &amp;= : <span class="type">AssignmentPrecedence</span>
infix operator ^= : <span class="type">AssignmentPrecedence</span>
infix operator |= : <span class="type">AssignmentPrecedence</span>
</code></pre><p>There are some Swift-specific ones in there (<code>...</code>, <code>..&lt;</code>, and <code>??</code>, for example) that line up with specific precedence groups (<code>NilCoalescingPrecedence</code>, <code>CastingPrecedence</code>, etc.), but for the most part these operators reflect those of C(++) and where they do, the precedence and associativity is the same.</p><p>Most Swift programs just use this standard set of operators, and that's good! It's why they are standard. But if your library calls for its own operators (say, to express another domain), make sure to think about both their associativity and their relationship to the standard operators. For our output streaming operator, we expect it to have a relatively low precedence, so we can use other operators to compute the values we stream out. Making <code>OutputStreaming</code> have a lower precedence than the logical disjunction (<code>||</code>) works well:</p><pre><code>precedencegroup <span class="type">OutputStreaming</span> { 
    associativity: left
    lowerThan: <span class="type">LogicalDisjunctionPrecedence</span>
}
</code></pre><h3>Aside: "unused result" warnings</h3><p>If you've been coding along with the examples above, you've probably noticed that we get an "unused result" warning for expressions like <code>os &lt;&lt;&lt; 17</code>. By default, Swift emits these warnings for calls that return a non-<code>Void</code> result. To suppress the warning at the use site, assign the expression to the placeholder value <code>_</code>. For our <code>&lt;&lt;&lt;</code> operator, that also means making its precedence <code>higherThan: AssignmentPrecedence</code>.</p><p>However, for this particular function, we don't actually care whether the user discards the result, because the important part is the output streaming effect. Therefore, we can put the <code>@discardableResult</code> result attribute on the function to squash the warning for all uses:</p><pre><code><span class="keyword">@discardableResult
static func</span> &lt;&lt;&lt;(lhs: <span class="type">OutputStream</span>, rhs: <span class="type">Int</span>) -&gt; <span class="type">OutputStream</span> { ... }
</code></pre><p>Think of this as flipping the default for the C++ <code>warn_on_unused</code> attribute (TODO: is this a C++ thing or just a GCC/Clang thing).</p><h2>Calling a value as a function</h2><p>C++ lets you create classes that behave like functions by implementing an <code>operator()</code> method. Indeed, this is the basis of C++ lambdas and all other C++ "function objects".</p><p>Swift has a similar capability, but it's far less commonly-used and offers a somewhat disjoint feature set. The basic idea is the same: in Swift, you can introduce a method named <code>callAsFunction</code> that will be used when calling an instance of the value as a function. For example, here's a Swift "function object" that binds the first value of a function, like the old school C++ <code>bind1st</code> (TODO: cite), albeit using variadic generics:</p><pre><code><span class="keyword">struct</span> BindFirst&lt;Result, First, each <span class="type">Rest</span>&gt; {
    <span class="keyword">var</span> fn: (<span class="type">First</span>, repeat each <span class="type">Rest</span>) -&gt; <span class="type">Result</span>
    <span class="keyword">let</span> first: <span class="type">First</span>
    
    <span class="keyword">func</span> callAsFunction(<span class="keyword">_</span> rest: <span class="keyword">repeat</span> each <span class="type">Rest</span>) -&gt; <span class="type">Result</span> {
        <span class="call">fn</span>(first, repeat each rest)
    }
}
</code></pre><p>Here's how it works:</p><pre><code><span class="keyword">func</span> f(x: <span class="type">Int</span>, y: <span class="type">Double</span>) -&gt; <span class="type">String</span> { <span class="string">"</span>\(x) <span class="string">-&gt;</span> \(y)<span class="string">"</span> }

<span class="keyword">let</span> bf = <span class="type">BindFirst</span>(fn: f, first: <span class="number">17</span>)
<span class="call">bf</span>(<span class="number">3.14159</span>)
</code></pre><p>The <code>BindFirst</code> initializer takes a function and a first argument for that function. In our example, the function <code>f</code> has a first argument of type <code>Int</code>. It then acts as a function that takes the remaining arguments (in our example, one parameter of type <code>Double</code>). When invoked, it passes along the stored first argument along with the remaining arguments (<code>repeat each rest</code>) and returns the result, so it acts as a forwarding function.</p><p>While this illustrates how <code>callAsFunction</code> <em>works</em>, it doesn't really illustrate how it's used: in Swift, one would probably just use a closure instead of <code>BindFirst</code> (and <code>bind1st</code> was removed from C++ after lambdas came along. TODO CHECK THIS). More importantly, since there's no "Callable"-style protocol in Swift, you can't really abstract over function objects in the same way that you do in C++. Rather, one tends to use values of function type and closures in Swift.</p><p>TODO: I thought callAsFunction had a form that got named arguments? That's where we should go with this, because it's a much stronger motivation for proper use of the feature. Mention its use in PythonKit, for example.</p><h2>Pointer-to-member, Swift style</h2><p>C++ pointer-to-members are a mechanism for referring to a non-static member (data or function) without specifying the actual instance for <code>this</code>. At a later point, one can supply a <code>this</code> using the <code>.*</code> or <code>-&gt;*</code> operators. Here's a quick refresher:</p><pre><code><span class="keyword">class</span> Point {
public:
  int x, y;
  <span class="type">Point</span> <span class="call">flippedOverXAxis</span>() { ... }
  <span class="type">Point</span> <span class="call">flippedOverYAxis</span>() { ... }
};

<span class="comment">// Form pointers to specific members.</span>
<span class="type">Point</span> (<span class="type">Point</span>::*memberFunction)() = &amp;<span class="type">Point</span>::flipOverXAxis;
int (<span class="type">Point</span>::*member) = &amp;<span class="type">Point</span>::x;

<span class="comment">// Supply an instance to refer to the referenced members.</span>
<span class="type">Point</span> p{<span class="number">1</span>, <span class="number">2</span>};
p.*member = <span class="number">3</span>;         <span class="comment">// updates x</span>
p = (p.*memberFunction)(); <span class="comment">// flipped over X axis</span>
</code></pre><p>Swift permits the same use cases, but... differently.</p><h3>Curried instance methods</h3><p>In Swift, it's possible to refer to an instance method of a type as a member of the type itself. Imagine a <code>Point</code> struct similar to the C++ class above:</p><pre><code><span class="keyword">struct</span> Point {
  <span class="keyword">var</span> x: <span class="type">Int</span>
  <span class="keyword">var</span> y: <span class="type">Int</span>
  
  <span class="keyword">func</span> flippedOverXAxis() -&gt; <span class="type">Point</span> { ... }
  <span class="keyword">func</span> flippedOverYAxis() -&gt; <span class="type">Point</span> { ... }
}
</code></pre><p>If I refer to <code>Point.flippedOverXAxis</code>, I will get back a value of type <code>(Point) -&gt; () -&gt; Point</code>, i.e., a function that accepts a <code>Point</code> (i.e., the <code>self</code> instance) and then returns a function. The returned function takes no arguments and returns a <code>Point</code> for its result.</p><blockquote><p>Aside: Note that <code>-&gt;</code> is right-associative, so this function type is read as <code>(Point) -&gt; (() -&gt; Point)</code>. This is documented by the <code>FunctionArrowPrecedence</code> precedence group earlier in this point, which is also important for handling the <code>-&gt;</code> operator when it shows up in expressions.</p></blockquote><p>Because referring to an instance method on the type produces a function, we don't need any special syntax like <code>.*</code> to deal with "pointer-to-member-function" in Swift: it's just function calls.</p><pre><code><span class="keyword">let</span> memberFunction = <span class="type">Point</span>.<span class="property">flippedOverXAxis</span>

<span class="keyword">var</span> p = <span class="type">Point</span>(x: <span class="number">1</span>, y: <span class="number">2</span>)
p = <span class="call">memberFunction</span>(p)()
</code></pre><h3>Key paths</h3><p>Swift's equivalent to pointer-to-data-members are their own special feature called <em>key paths</em>. The simplest use of a key path</p><h3>Key-path member access</h3><h3>String-based member access</h3></div><footer><p>Generated using <a href="https://github.com/johnsundell/publish">Publish</a></p><p><a href="/feed.rss">RSS feed</a></p></footer></body></html>